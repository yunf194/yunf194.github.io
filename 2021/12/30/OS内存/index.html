<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统-进程管理 | fengyun's Blog</title><meta name="keywords" content="OS"><meta name="author" content="长烟"><meta name="copyright" content="长烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程程序是一个指令序列  早期计算机只支持单道程序，一道时间段仅有一个程序执行内存里也只有一个固定的程序段和数据段  多道程序技术引入后，内存里就有多个程序段数据段了 内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢?因此系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB) ，用来描述进程的各种信息(如程序代码存放位置) 程序段、数">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-进程管理">
<meta property="og:url" content="http://yunf194.github.io/2021/12/30/OS%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="fengyun&#39;s Blog">
<meta property="og:description" content="进程程序是一个指令序列  早期计算机只支持单道程序，一道时间段仅有一个程序执行内存里也只有一个固定的程序段和数据段  多道程序技术引入后，内存里就有多个程序段数据段了 内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢?因此系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB) ，用来描述进程的各种信息(如程序代码存放位置) 程序段、数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yunf194.github.io/images/cover/os.jpg">
<meta property="article:published_time" content="2021-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-28T10:00:47.036Z">
<meta property="article:author" content="长烟">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yunf194.github.io/images/cover/os.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://yunf194.github.io/2021/12/30/OS%E5%86%85%E5%AD%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b5317a4316878223f02ccad7d028fa5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-进程管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-28 18:00:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunf194.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/os.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">fengyun's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-进程管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-29T16:00:00.000Z" title="发表于 2021-12-30 00:00:00">2021-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-28T10:00:47.036Z" title="更新于 2022-03-28 18:00:47">2022-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-进程管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序是一个指令序列</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323152904999.png" alt="image-20220323152904999"></p>
<p>早期计算机只支持单道程序，一道时间段仅有一个程序执行<br>内存里也<strong>只有一个固定的程序段和数据段</strong></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323153216819.png" alt="image-20220323153216819"></p>
<p>多道程序技术引入后，内存里就有多个程序段数据段了</p>
<p>内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢?<br>因此<strong>系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)</strong> ，用来描述进程的各种信息(如程序代码存放位置)</p>
<p><strong>程序段、数据段、PCB三部分</strong>组成了<strong>进程实体</strong>(进程映像)。一般情况下，我们把进程实体就简称为进程,例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p><strong>注意: PCB是进程存在的唯一标志!</strong></p>
<p>引入进程实体的概念后，可把进程定义为:<br><strong>进程</strong>是进程实体的<strong>运行</strong>过程，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p>
<p>PCB组成：</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323153614377.png" alt="image-20220323153614377"></p>
<p>如何管理PCB？</p>
<ul>
<li>链接方式：按照<strong>进程状态</strong>（执行，阻塞，就绪）将PCB分为多个队列，操作系统持有指向各个队列的指针</li>
</ul>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323153908078.png" alt="image-20220323153908078"></p>
<ul>
<li>索引方式：<strong>根据进程状态的不同</strong>，建立几张索引表，操作系统持有指向各个索引表的指针</li>
</ul>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323154004761.png" alt="image-20220323154004761"></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>运行态(Running) <strong>占有CPU</strong>，并在CPU上运行<br>就绪态(Ready) **已经具备运行条件，但由于没有空闲CPU,**而暂时不能运行<br>阻塞态(Waiting/Blocked, 又称:等待态) 因等待某一事件而暂时不能运行</p>
<p>注意:单核处理机环境下，每时刻最多只有一个进程处于运行(双核环境下可以同时有两个进程处于运行态)</p>
<p>创建态(New, 又称:新建态)  进程正在被创建，操作系统为进程分配资源、初始化PCB<br>终止态(Terminated, 又称:结束态)  进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323154657521.png" alt="image-20220323154657521"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制就是要实现进程状态转换</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323155040115.png" alt="image-20220323155040115"></p>
<p>进程状态的改变操作应该是不被打断的，应该要用原语实现进程控制。PCB放到一个队列中并且修改PCB的状态</p>
<p>学习技巧:进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情:<br>1.<strong>更新PCB中的信息</strong>(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>    a.所有的进程控制原语一定都会修改进程状态标志<br>    b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>    c.某进程开始运行前必然要恢复期运行环境<br>2.将PCB<strong>插入合适的队列</strong></p>
<p>3.<strong>分配/回收资源</strong></p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>顾名思义，进程通信就是指进程之间的信息交换。<br>进程是分配系统资源的单位(包括内存地址空间)，因此<strong>各进程拥有的内存地址空间相互独立</strong>。</p>
<p>为了保证安全，一个进程<strong>不能直接访问</strong>另一个进程的地址空间。<br>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ul>
<li>信号</li>
<li>管道</li>
<li>信号量</li>
<li>共享内存</li>
<li>消息队列</li>
<li>套接字</li>
</ul>
<p>对比：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>传输的信息量</th>
<th>使用场景</th>
<th>关键词</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td>少量</td>
<td>任何</td>
<td>硬件来源、软件来源 / 信号队列</td>
</tr>
<tr>
<td>管道</td>
<td>大量</td>
<td>亲缘进程间</td>
<td>单向流动 / 内核缓冲区 / 循环队列 / 没有格式的字节流 / 操作系统负责同步</td>
</tr>
<tr>
<td>命名管道</td>
<td>大量</td>
<td>任何</td>
<td>磁盘文件 / 访问权限 / 无数据块 / 内核缓冲区 / 操作系统负责同步</td>
</tr>
<tr>
<td>信号量</td>
<td>N</td>
<td>任何</td>
<td>互斥同步 / 原子性 / P 减 V 增</td>
</tr>
<tr>
<td>共享内存</td>
<td>大量</td>
<td>多个进程</td>
<td>内存映射 / 简单快速 / 操作系统不保证同步</td>
</tr>
<tr>
<td>消息队列</td>
<td>比信号多，但有限制</td>
<td>任何</td>
<td>有格式 / 按消息类型过滤 / 操作系统负责同步</td>
</tr>
<tr>
<td>套接字</td>
<td>大量</td>
<td>不同主机的进程</td>
<td>读缓存区 / 写缓冲区 / 操作系统负责同步</td>
</tr>
</tbody></table>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号 Signal"></a>信号 Signal</h3><p>信号是 Linux 系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。这是一种“订阅-发布”的模式。</p>
<p>信号来源分为硬件来源和软件来源。</p>
<ol>
<li>硬件来源。如按下 CTRL+C、除 0、非法内存访问等等</li>
<li>软件来源。如 Kill 命令、Alarm Clock 超时、当 Reader 中止之后又向管道写数据，等等</li>
</ol>
<p>发送信号的机制：</p>
<ol>
<li>用 <code>/bin/kill</code> 程序发送信号</li>
<li>从键盘发送信号，比如按下 Ctrl+C 发送 SIGINT 信号、按下 Ctrl+Z 发送 SIGTSTP 信号</li>
<li>用 <code>kill</code> 函数发送信号</li>
<li>用 <code>alarm</code> 函数向自己发送 SIGLALRM 信号</li>
</ol>
<p>一般的信号是都是由一个错误产生的。以除 0 为例。在 x86 机器上 DIV 或 IDIV 指令除数为 0 时，会引发 0 号中断，编号 #DE(Divide Error)，即所谓除零异常。这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT 中的中断处理程序。而操作系统处理这个异常的方法，就是**向进程发送一个信号 <code>SIGFPE</code>**。如果进程设置了相应的 signal handler，就执行进程的处理方法。否则，执行操作系统的默认操作，一般这种信号的默认操作是杀死进程。</p>
<p>同理，溢出、非法内存访问（越界）、非法指令等也都属于硬件中断，由操作系统处理。<strong>操作系统会将这些硬件异常包装成“信号”发送给进程</strong>。如果进程不处理这几个异常信号，那么默认的行为就是挂掉。</p>
<p>但是，信号也可以作为进程间通信的一种方式，明确地由一个进程发送给另一个进程。</p>
<p>进程如何发送信号？</p>
<ul>
<li>操作系统提供发送信号的系统调用（<code>int kill(pid_t pid, int sig);</code>，<code>int raise(int sig);</code>,<code>unsigned int alarm(unsigned int seconds)</code>）</li>
<li>该系统调用会将信号放到目标进程的信号队列中</li>
<li>如果目标进程未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程</li>
</ul>
<p>进程如何接收信号？</p>
<ul>
<li>每个进程有一个信号队列，放其他进程发给它、等待它处理的信号</li>
<li>进程在执行过程中的特定时刻，检查并处理自己的信号队列。如从系统空间返回到用户空间之前</li>
<li>发送信号时，必须指明发送目标进程的号码。一般用在具有亲缘关系的进程之间</li>
</ul>
<p>用户进程对信号的处理过程有三种：</p>
<ol>
<li>处理信号。定义信号处理函数，当信号发生时，执行相应的处理函数</li>
<li>忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理</li>
<li>不处理也不忽略。执行默认操作，linux 对每种信号都规定了默认操作</li>
</ol>
<p>有的信号，用户进程是无法处理也无法忽略的，比如<code>SIGSTOP</code>、<code>SIGKILL</code> 等。</p>
<p>关于信号的更详细的内容，可以查看<a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/09/trap-interrupt-exception.html#signal">这篇文章</a>。</p>
<h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 Pipe"></a>管道 Pipe</h3><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所<strong>以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区</strong>,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p>
<p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同，而 pipe就是提供这份公共资源的形式的一种。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;<span class="comment">//返回:成功返回0，出错返回-1     </span></span><br></pre></td></tr></table></figure>

<p> fd参数返回两个文件描述符,fd[0]指向管道的读端,fd[1]指向管道的写端。fd[1]的输出是fd[0]的输入。</p>
<h4 id="管道如何实现进程间的通信"><a href="#管道如何实现进程间的通信" class="headerlink" title="管道如何实现进程间的通信"></a>管道如何实现进程间的通信</h4><p>（1）父进程创建管道，得到两个⽂件描述符指向管道的两端</p>
<p>（2）父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。</p>
<p>（3）父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323161354903.png" alt="image-20220323161354903"></p>
<h4 id="管道读取数据的四种的情况"><a href="#管道读取数据的四种的情况" class="headerlink" title="管道读取数据的四种的情况"></a>管道读取数据的四种的情况</h4><p>（1）读端不读，写端一直写<br><img src="/../images/OS%E5%86%85%E5%AD%98/SouthEast.png" alt="这里写图片描述"><br>（2）写端不写，但是读端一直读<br><img src="/../images/OS%E5%86%85%E5%AD%98/SouthEast-16480233939282.png" alt="这里写图片描述"></p>
<p>（3）读端一直读，且fd[0]保持打开，而写端写了一部分数据不写了，并且关闭fd[1]。<br><img src="/../images/OS%E5%86%85%E5%AD%98/SouthEast-16480233939303.png" alt="这里写图片描述"></p>
<p>如果一个管道读端一直在读数据，而管道写端的引⽤计数⼤于0决定管道是否会堵塞，引用计数大于0，只读不写会导致管道堵塞。</p>
<p>（4）读端读了一部分数据，不读了且关闭fd[0]，写端一直在写且f[1]还保持打开状态。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/SouthEast-16480233939304.png" alt="这里写图片描述"></p>
<h4 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h4><ul>
<li><p>1.管道只允许具有血缘关系的进程间通信，如父子进程间的通信。</p>
</li>
<li><p>2.管道只允许单向通信。</p>
</li>
<li><p>3.管道内部保证同步机制，从而保证访问数据的一致性。</p>
</li>
<li><p>4.面向字节流</p>
</li>
<li><p>5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。</p>
</li>
</ul>
<h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道 FIFO"></a>命名管道 FIFO</h3><p>Linux 管道包含匿名管道和命名管道。上面说的是匿名管道，只能用在亲缘进程中，管道文件信息保存在内存里。</p>
<p>命名管道（FIFO）可用于没有亲缘的进程间。Pipe 和 FIFO 除了建立、打开、删除的方式不同外，二者几乎一模一样。</p>
<p>通过 <code>mknode()</code> 系统调用或者 <code>mkfifo()</code> 函数建立命名管道。一旦建立，任何有访问权的进程都可以通过文件名将其打开和进行读写，而不局限于父子进程。</p>
<p>建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过<strong>内核缓冲区</strong>来实现数据传输。有访问权限的进程，可以通过磁盘的索引节点来读写这块缓冲区。</p>
<p>当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在。</p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>信号量是一种特殊的变量，对它的操作都是原子的，有两种操作：V（<code>signal()</code>）和 P（<code>wait()</code>）。V 操作会增加信号量 S 的数值，P 操作会减少它。</p>
<ul>
<li>V(S)：如果有其他进程因等待 S 而被挂起，就让它恢复运行，否则 S 加 1</li>
<li>P(S)：如果 S 为 0，则挂起进程，否则 S 减 1</li>
</ul>
<p>P、V 来自于荷兰语：Probeer (try)、Verhoog (increment)。</p>
<p>如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore）。在 Linux 系统中，二进制信号量又称互斥锁（Mutex）。信号量可以用于实现进程或线程的互斥和同步。</p>
<p>信号量在底层的实现是通过硬件提供的原子指令，如 <code>Test And Set</code>、<code>Compare And Swap</code> 等。比如 golang 实现互斥量就是使用了 <code>Compare And Swap</code> 指令（<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/sync/mutex.go#L72">github</a>）。</p>
<h3 id="共享内存-Shared-Memory"><a href="#共享内存-Shared-Memory" class="headerlink" title="共享内存 Shared Memory"></a>共享内存 Shared Memory</h3><p>共享内存顾名思义，允许两个或多个进程共享同一段物理内存。<strong>不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它</strong>。不同进程可以通过向共享内存端读写数据来交换信息。</p>
<p>一个进程可以通过操作系统的系统调用，创建一块共享内存区；其他进程通过系统调用把这段内存映射到自己的用户地址空间中；之后各个进程向读写正常内存一样，读写共享内存。共享内存区只会驻留在创建它的进程地址空间内。</p>
<p><strong>共享内存的优点是简单且高效</strong>，访问共享内存区域和访问进程独有的内存区域一样<strong>快</strong>，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制。</p>
<p>比如管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件（<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1021157">图示</a>）。此外，消息传递的实现经常采用系统调用，也就经常需要用户态和内核态互相转换；而共享内存只在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。</p>
<p><strong>共享内存的缺点是存在并发问题</strong>，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。</p>
<p>Linux 的 2.2.x 内核支持多种共享内存方式，如 mmap() 系统调用，Posix 共享内存，以及系统 V 共享内存。</p>
<p>mmap() 系统调用的主要作用是将<strong>普通文件</strong>映射到进程的地址空间，然后可以像访问普通内存一样对文件进行访问，不必再调用 read()，write() 等操作。mmap() 不是专门用来共享内存的，但是多个进程可以通过 mmap() 映射同一个普通文件，来实现共享内存。</p>
<p>系统 V 则是通过映射<strong>特殊文件</strong>系统 shm 中的文件实现进程间的共享内存。通过 shmget 可以创建或获得共享内存的标识符。取得共享内存标识符后，通过 shmat 将这个内存区映射到本进程的虚拟地址空间。</p>
<p>有关 mmap() 系统调用、系统 V 共享内存的详细介绍，以及两者的对比，可以进一步查看这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html">Linux环境进程间通信（五）- 共享内存（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html">Linux环境进程间通信（五）- 共享内存（下）</a></li>
</ul>
<h3 id="消息队列-Message-Queue"><a href="#消息队列-Message-Queue" class="headerlink" title="消息队列 Message Queue"></a>消息队列 Message Queue</h3><p><strong>消息队列是一个消息的链表</strong>，保存在内核中。消息队列中的每个消息都是一个<strong>数据块</strong>，具有特定的格式。操作系统中可以存在多个消息队列，每个消息队列有唯一的 <strong>key</strong>，称为消息队列标识符。</p>
<p>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了<strong>有格式</strong>的数据，但消息队列仍然有大小限制。</p>
<p>消息队列允许一个或多个进程向它写入与读取消息。消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。也就是说，消息队列是异步的，但这也造成了一个缺点，就是接收者必须<strong>轮询</strong>消息队列，才能收到最近的消息。</p>
<p>操作系统提供创建消息队列、取消息、发消息等系统调用。</p>
<p>操作系统负责读写同步：若消息队列已满，则写消息进程排队等待；若取消息进程没有找到需要的消息，则在等待队列中寻找。</p>
<p>消息队列和管道相比，相同点在于二者都是通过发送-接收的方式进行通信，并且数据都有最大长度限制。不同点在于消息队列的数据是有格式的，并且<strong>取消息进程可以选择接收特定类型的消息</strong>，而不是像管道中那样默认全部接收。</p>
<h3 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h3><ul>
<li>不同的计算机的进程之间通过 socket 通信，<em>也可用于同一台计算机的不同进程</em></li>
<li>需要通信的进程之间首先要各自创建一个 socket，<strong>内容包括主机地址与端口号</strong>，声明自己接收来自某端口地址的数据</li>
<li>进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程</li>
</ul>
<p>操作系统提供创建 socket、发送、接收的系统调用，为每个 socket 设置发送缓冲区、接收缓冲区。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102115022061.png" alt="image-20220102115022061"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102115400652.png" alt="image-20220102115400652"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102115707254.png" alt="image-20220102115707254"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102224351270.png" alt="image-20220102224351270"></p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p>
<p>在<strong>多道程序系统</strong>中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
<p>高级调度(作业调度)。按一定的原则从<strong>外存</strong>上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。</p>
<p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>引入了虚拟存储技术之后，<strong>可将暂时不能运行的进程调至外存等待</strong>。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<br>这么做的目的是为了<strong>提高内存利用率和系统吞吐量。</strong><br>暂时调到外存等待的进程状态为挂起状态。值得注意的是，<strong>PCB并不会一起调到外存</strong>， 而是会<strong>常驻内存</strong>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
<h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p>低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。<br>进程调度的频率很高，一般几十毫秒一次。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102120441152.png" alt="image-20220102120441152"></p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p><strong>什么时候进程切换？</strong></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220323172118940.png" alt="image-20220323172118940"></p>
<p><strong>不能进行进程调度和切换的情况：</strong></p>
<ul>
<li>1.在<strong>处理中断</strong>的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>2.进程在<strong>操作系统内核程序临界区</strong>中。</li>
<li>3.在**原子操作过程中(原语)**。原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
<p>“狭义的进程调度”与“进程切换”的区别:<br>狭义的进程调度指的是<strong>从就绪队列中选中一个要运行的进程</strong>。(这 个进程可以是刚刚被暂停执行的进程，也可能是另一一个进程，后一种情况就需要进程切换)<br>进程切换是指<strong>一个进程让出处理机，由另一个进程占用处理机的过程</strong>。</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了:<br>1.对原来运行进程<strong>各种数据的保存</strong><br>2.对新的进程<strong>各种数据的恢复</strong><br>(如:<strong>程序计数器、程序状态字、各种数据寄存器等处理机现场信息</strong>，这些信息一般保存在进程控制块)</p>
<p>注意:进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67"><img src="/../images/OS%E5%86%85%E5%AD%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67.png" alt="img"></a></p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67"><img src="/../images/OS%E5%86%85%E5%AD%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67.png" alt="img"></a></p>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry section</span></span><br><span class="line"><span class="comment">// critical section;</span></span><br><span class="line"><span class="comment">// exit section</span></span><br></pre></td></tr></table></figure>

<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102164910506.png" alt="image-20220102164910506"></p>
<ul>
<li>生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品。</li>
<li>消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。</li>
<li>往缓冲区放入/取走产品需要互斥。</li>
</ul>
<p>每个PV对应于一个信号量，因此需要三个信号量。而且生产者是看缓冲区满没满，消费者是看缓冲区空不空。生产者和消费者的信号量是不一样的！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;     <span class="comment">//互斥信号量，实现对缓冲区的互斥访问.</span></span><br><span class="line">semaphore empty = n;     <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;      <span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>

<p>PV操作题目的解题思路:</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。 (互斥信号量初值一-般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>
</ol>
<p>生产者消费者问题是一一个互斥、同步的综合问题。<br>对于初学者来说最难的是发现题目中隐含的两对同步关系。<br>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，<strong>这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。.</strong></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102165557940.png" alt="image-20220102165557940"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102165755092.png" alt="image-20220102165755092"></p>
<h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><p>多是指多类别</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102171346301.png" alt="image-20220102171346301"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102171632098.png" alt="image-20220102171632098"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172230628.png" alt="image-20220102172230628"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172247539.png" alt="image-20220102172247539"></p>
<p>总结:在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172330699.png" alt="image-20220102172330699"></p>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172523937.png" alt="image-20220102172523937"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172810308.png" alt="image-20220102172810308"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102172834956.png" alt="image-20220102172834956"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102173047966.png" alt="image-20220102173047966"></p>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102173926992.png" alt="image-20220102173926992"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102173848260.png" alt="image-20220102173848260"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102174326753.png" alt="image-20220102174326753"></p>
<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后 一个读进程，从而做出不同的处理。另外，对count变量的检查和赋值不能一气呵成导致了一-些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102174535334.png" alt="image-20220102174535334"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102174633530.png" alt="image-20220102174633530"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102174949003.png" alt="image-20220102174949003"></p>
<p>如何防止死锁的发生呢?</p>
<ol>
<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子， 另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>
</ol>
<p>更准确的说法应该是:各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量编写程序比较复杂困难，因此就引入了管程</p>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<ul>
<li>1.局部于管程的<strong>共享数据结构</strong>说明;</li>
<li>2.对该数据结构进行操作的<strong>一组过程</strong>（函数）;</li>
<li>3.对局部于管程的共享数据设置初始值的语句;</li>
<li>4.管程有一个名字。</li>
</ul>
<p>Tips:“过程”其实就是“函数”<br>管程的基本特征:</p>
<ul>
<li>1.局部于管程的数据只能被局部于管程的过程所访问;</li>
<li>2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据;</li>
<li>3.<strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></li>
</ul>
<p><strong>由编译器负责</strong>实现各个进程<strong>互斥</strong>地进入管程的过程</p>
<ol>
<li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”– -其实就是一-些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>
<li>只有通过这些特定的“入口”才能访问共享数据</li>
<li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意:这种，互斥特性是由编译器负责实现的，程序，员不用关心)</li>
<li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”) ;可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102194745837.png" alt="image-20220102194745837"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102194939626.png" alt="image-20220102194939626"></p>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102195346012.png" alt="image-20220102195346012"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102195510108.png" alt="image-20220102195510108"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102195652118.png" alt="image-20220102195652118"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102195749906.png" alt="image-20220102195749906"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102200005954.png" alt="image-20220102200005954"></p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102201344457.png" alt="image-20220102201344457"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102201200283.png" alt="image-20220102201200283"></p>
<h3 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h3><p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102201430026.png" alt="image-20220102201430026"></p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102202428864.png" alt="image-20220102202428864"></p>
<p>资源结点:表示进程想申请几个资源(每条边代表一个)<br>进程结点:表示已经为进程分配了几个资源(每条边代表一个)</p>
<p>注意上图中蓝色边表示请求边，绿色边表示申请边。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/image-20220102202352288.png" alt="image-20220102202352288"></p>
<p>进程是一个<strong>拥有资源</strong>和<strong>执行任务</strong>的单元体。进程拥有的资源包括：内存空间中的代码、数据等；I/O 资源；文件；处理机等。</p>
<p>线程是一个<strong>执行任务</strong>的单元体。线程只拥有处理机，线程之间共享进程的资源，如内存、I/O 等。</p>
<p>对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源</td>
<td>进程是一个<strong>拥有资源</strong>和<strong>执行任务</strong>的单元体。</td>
<td>线程是一个<strong>执行任务</strong>的单元体，<strong>不拥有资源</strong>，线程之间<strong>共享地址空间</strong></td>
</tr>
<tr>
<td>切换开销</td>
<td>开销很大</td>
<td>开销很小</td>
</tr>
<tr>
<td>通信</td>
<td><a target="_blank" rel="noopener" href="https://imageslr.com/2020/02/26/ipc.html">IPC</a></td>
<td>共享内存</td>
</tr>
<tr>
<td>健壮性</td>
<td>健壮，多个进程之间不会互相干扰</td>
<td>不健壮，一个线程出错会终止整个进程</td>
</tr>
</tbody></table>
<h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><p>进程切换是一个开销很大的操作。进程切换的开销主要包括：</p>
<ul>
<li>处理机的上下文切换：保存和恢复相关寄存器的内容</li>
<li>与进程相关的数据结构更改：存储管理有关的记录信息（如页表）、文件管理有关数据（如文件描述符）、进程控制块中的各种队列（如阻塞队列、就绪队列、通信队列）等</li>
</ul>
<p>进程的处理机资源和其他资源是一起分配的，进程切换的时候会整体切换，开销很大。如果我们<strong>只切换必需的、与处理机相关的信息</strong>，就可以有效减少开销。这种情况下，处理机分配的单位和其他的资源分配的单位不能再是一个实体。</p>
<p>由此引入线程：把一个进程分为多个执行任务的单元体，只为其分配处理机，这些执行任务的单元体就是线程。</p>
<h2 id="线程的上下文切换过程"><a href="#线程的上下文切换过程" class="headerlink" title="线程的上下文切换过程"></a>线程的上下文切换过程</h2><p>线程有自己的寄存器和栈。当上下文切换的时候，正在运行的线程会将寄存器的状态保存到 TCB（Thread Control Block）里（进程是 PCB，Process Control Block），然后恢复另一个线程的上下文。</p>
<p><img src="/../images/OS%E5%86%85%E5%AD%98/15941873964798.jpg" alt="img"></p>
<blockquote>
<p>图 1：单线程与多线程的示意图</p>
</blockquote>
<p>和进程的区别是，线程只需要切换处理机执行的上下文，不会改变地址空间。这意味着：</p>
<ol>
<li>不需要重新加载页表，切换开销少，提高效率</li>
<li>多个线程共享地址空间，有利有弊</li>
</ol>
<h2 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h2><p>优点：</p>
<ul>
<li>提高效率：切换开销小</li>
<li>通信方便，共享内存；进程必须通过进程间通信 <a target="_blank" rel="noopener" href="https://imageslr.com/2020/02/26/ipc.html">IPC</a></li>
</ul>
<p>缺点：</p>
<ul>
<li>一个线程出错，操作系统会结束整个进程，不够健壮；而多进程就没有这个问题</li>
<li>同一进程中的多个线程共享内存，会有并发问题</li>
</ul>
<h2 id="同一进程中的线程共享与独占的资源"><a href="#同一进程中的线程共享与独占的资源" class="headerlink" title="同一进程中的线程共享与独占的资源"></a>同一进程中的线程共享与独占的资源</h2><p>共享资源：</p>
<ul>
<li>内存空间<ul>
<li>代码</li>
<li>公共数据（全局变量、静态变量）</li>
<li>堆</li>
</ul>
</li>
<li>文件描述符</li>
<li>信号处理器</li>
<li>进程 ID / 进程组 ID</li>
<li>…</li>
</ul>
<p>独占资源，以及为什么需要独占：</p>
<ul>
<li>线程 ID：在本进程中唯一，进程用来标识此线程</li>
<li>一组寄存器的值</li>
<li>栈：每个线程中的函数调用过程是独立的，因此需要有独立的栈</li>
<li>错误返回码：系统调用或库函数发生错误时，会设置全局变量 <code>errno</code>，各个线程的错误返回码应该是独立的</li>
<li>信号屏蔽码：每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理；但每个线程都共享本进程的信号处理器</li>
</ul>
<p>可以参考图 1。</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>线程也像进程一样有多个状态：运行、就绪、阻塞…</p>
<p>从 Linux 内核的角度来看，线程和进程并没有被区别对待。无论线程还是进程，都是用 <code>task_struct</code> 结构表示的，只不过线程的 <code>mm</code>（内存空间）和 <code>files</code>（打开的文件）结构体是共享的，见<a target="_blank" rel="noopener" href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">进程、线程和文件描述符 - labuladong</a>。</p>
<p>线程实现的方式有三种：</p>
<ul>
<li>在内核实现</li>
<li>在用户空间实现</li>
<li>混合方式实现</li>
</ul>
<p>每种实现方式的优缺点：TODO</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">长烟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yunf194.github.io/2021/12/30/OS%E5%86%85%E5%AD%98/">http://yunf194.github.io/2021/12/30/OS%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yunf194.github.io" target="_blank">fengyun's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/os.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/01/OS%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><img class="prev-cover" src="/images/cover/os.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-内存管理</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/30/OS1/"><img class="next-cover" src="/images/cover/os.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/23/2022423-BIOS/" title="BIOS"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-23</div><div class="title">BIOS</div></div></a></div><div><a href="/2022/04/23/2022423-%E4%B8%BB%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F/" title="利用FAT12文件系统加载指定程序"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-23</div><div class="title">利用FAT12文件系统加载指定程序</div></div></a></div><div><a href="/2022/05/01/202251-%E7%AA%81%E7%A0%B4512%E5%AD%97%E8%8A%82%E9%99%90%E5%88%B6/" title="MBR加载LOADER"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">MBR加载LOADER</div></div></a></div><div><a href="/2022/05/14/2022514-%E5%B1%80%E9%83%A8%E6%AE%B5%E6%8F%8F%E8%BF%B0%E8%A1%A8/" title="局部段描述表"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">局部段描述表</div></div></a></div><div><a href="/2022/05/15/2022515-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7/" title="保护模式的特权级"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-15</div><div class="title">保护模式的特权级</div></div></a></div><div><a href="/2022/05/18/2022517-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="页式存储管理"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-18</div><div class="title">页式存储管理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunf194.github.io/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">长烟</div><div class="author-info__description">交际是分享快乐，独处是消化自我</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunf194"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yunf194" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2846327307@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我明白你会来所以我等</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">进程通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">进程间的通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7-Signal"><span class="toc-number">2.1.</span> <span class="toc-text">信号 Signal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-Pipe"><span class="toc-number">2.2.</span> <span class="toc-text">管道 Pipe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">管道如何实现进程间的通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">管道读取数据的四种的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">管道的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93-FIFO"><span class="toc-number">2.3.</span> <span class="toc-text">命名管道 FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="toc-number">2.4.</span> <span class="toc-text">信号量 Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Shared-Memory"><span class="toc-number">2.5.</span> <span class="toc-text">共享内存 Shared Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Message-Queue"><span class="toc-number">2.6.</span> <span class="toc-text">消息队列 Message Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-Socket"><span class="toc-number">2.7.</span> <span class="toc-text">套接字 Socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">高级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.</span> <span class="toc-text">中级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">低级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">4.4.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.5.2.</span> <span class="toc-text">交互式系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.5.3.</span> <span class="toc-text">实时系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">5.</span> <span class="toc-text">进程同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">5.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">5.2.</span> <span class="toc-text">同步与互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">5.4.</span> <span class="toc-text">生产者-消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">5.5.</span> <span class="toc-text">多生产者-多消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.</span> <span class="toc-text">哲学家吃饭问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">5.9.</span> <span class="toc-text">管程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">死锁概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">6.3.</span> <span class="toc-text">避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">死锁处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">为什么需要线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">线程的上下文切换过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">线程的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%8B%AC%E5%8D%A0%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">10.</span> <span class="toc-text">同一进程中的线程共享与独占的资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">线程的实现方式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GO的双向tls通信"/></a><div class="content"><a class="title" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信">基于GO的双向tls通信</a><time datetime="2023-01-06T16:00:00.000Z" title="发表于 2023-01-07 00:00:00">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入"/></a><div class="content"><a class="title" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2022-12-06T16:00:00.000Z" title="发表于 2022-12-07 00:00:00">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传漏洞"/></a><div class="content"><a class="title" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞">文件上传漏洞</a><time datetime="2022-12-05T16:00:00.000Z" title="发表于 2022-12-06 00:00:00">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之包"/></a><div class="content"><a class="title" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包">Go语言基础之包</a><time datetime="2022-10-22T16:00:00.000Z" title="发表于 2022-10-23 00:00:00">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之函数"/></a><div class="content"><a class="title" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数">Go语言基础之函数</a><time datetime="2022-10-21T16:00:00.000Z" title="发表于 2022-10-22 00:00:00">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/os.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 长烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">其实，我回头等了你好久好久，你都没来</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Yb0FJoeuYRJfbYGupEnFsg6E-gzGzoHsz',
      appKey: 'Pjo4dvB3TbjfY8clnS7fxalh',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://yunf194.github.io/css/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://yunf194.github.io/css/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>