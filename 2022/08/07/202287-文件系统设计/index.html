<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>文件系统设计 | fengyun's Blog</title><meta name="keywords" content="OS"><meta name="author" content="长烟"><meta name="copyright" content="长烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟硬盘bximage hd.img -q hd -mode&#x3D;flat -size&#x3D;80创建一个虚拟硬盘(-hd)，-q表示不交互，-mode&#x3D;flat连续硬盘，-size&#x3D;80大小为80M。  重新配置告诉bochs 虚拟硬盘是以hd.img来展现的，CHS柱面柱头的信息  BIOS 运行后会遍历系统中的硬件， 并记录相关信息。其中， 硬盘数量被BIOS主动记录于 0x475 地址处。因此我们可">
<meta property="og:type" content="article">
<meta property="og:title" content="文件系统设计">
<meta property="og:url" content="http://yunf194.github.io/2022/08/07/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="fengyun&#39;s Blog">
<meta property="og:description" content="虚拟硬盘bximage hd.img -q hd -mode&#x3D;flat -size&#x3D;80创建一个虚拟硬盘(-hd)，-q表示不交互，-mode&#x3D;flat连续硬盘，-size&#x3D;80大小为80M。  重新配置告诉bochs 虚拟硬盘是以hd.img来展现的，CHS柱面柱头的信息  BIOS 运行后会遍历系统中的硬件， 并记录相关信息。其中， 硬盘数量被BIOS主动记录于 0x475 地址处。因此我们可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yunf194.github.io/images/cover/p25.jpg">
<meta property="article:published_time" content="2022-08-06T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-20T03:08:25.792Z">
<meta property="article:author" content="长烟">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yunf194.github.io/images/cover/p25.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://yunf194.github.io/2022/08/07/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b5317a4316878223f02ccad7d028fa5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '文件系统设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-20 11:08:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunf194.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/p25.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">fengyun's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">文件系统设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-06T16:00:00.000Z" title="发表于 2022-08-07 00:00:00">2022-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-20T03:08:25.792Z" title="更新于 2022-10-20 11:08:25">2022-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="文件系统设计"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="虚拟硬盘"><a href="#虚拟硬盘" class="headerlink" title="虚拟硬盘"></a>虚拟硬盘</h2><p><code>bximage hd.img -q hd -mode=flat -size=80</code>创建一个虚拟硬盘(-hd)，-q表示不交互，-mode=flat连续硬盘，-size=80大小为80M。</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220807164329019.png" alt="image-20220807164329019"></p>
<p>重新配置告诉bochs 虚拟硬盘是以hd.img来展现的，CHS柱面柱头的信息</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220907214704603.png" alt="image-20220907214704603"></p>
<p>BIOS 运行后会遍历系统中的硬件， 并记录相关信息。其中， 硬盘数量被BIOS主动记录于 0x475 地址处。因此我们可以通过读取0x475地址的数据拿到<strong>硬盘数量信息</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte* pb = (byte*)<span class="number">0x475</span>;</span><br><span class="line">PrintString( <span class="string">&quot;Number of Hard Disk: &quot;</span> );</span><br><span class="line">PrintIntDec(*pb);</span><br><span class="line">PrintChar(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>IDE 是什么？</p>
<p>早期，硬盘控制器和硬盘本身是分开的。软件控制硬盘控制器来读取硬盘的数据。后来，<strong>硬盘控制器和硬盘本身合二为一</strong>(Integrated Drive Electronics)。<br>再后来， 有了别名 ATA, 然后是ATA / IDE。<br>最初的硬盘是用<strong>并口传输数据</strong>， 所以 <strong>IDE 常指代并口硬盘接口</strong>。并口由于太慢了因此后来有了串口硬盘接口， 名为： SerialATA, 缩写： SATA。 。 。  </p>
<h3 id="硬盘控制器"><a href="#硬盘控制器" class="headerlink" title="硬盘控制器"></a>硬盘控制器</h3><p><strong>怎么具体地读写硬盘？</strong><br>也就是<strong>通过固定I/O端口</strong>对硬盘控制器进行操作就可以读写硬盘了<br>而操作的本质是读写硬盘控制器中的寄存器</p>
<p>命令块寄存器 (Command Block Register)</p>
<p>控制块寄存器 (Control Block Register)  </p>
<p>primary和secondary对应主盘和从盘</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220807165303967.png" alt="image-20220807165303967"></p>
<p>注意同一个端口（例如主盘的0x1F7）可以读也可以写，但是可能读写操作意义是不一样的。假设操作硬盘时有错误信息可以通过0x1F1读取错误信息。本OS只有一块硬盘因此只操作Primary</p>
<p>针对端口0x1F7判断硬盘是否忙碌，设备是否就绪，数据是否就绪：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">IsBusy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//500次 读取状态寄存器并且判断最高位是不是1</span></span><br><span class="line">    <span class="keyword">while</span>( (i &lt; <span class="number">500</span>) &amp;&amp; (ret = (ReadPort(REG_STATUS) &amp; STATUS_BSY)) )</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">IsDevReady</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//读取状态寄存器且判断第DRDY位是不是0</span></span><br><span class="line">    <span class="keyword">return</span> !(ReadPort(REG_STATUS) &amp; STATUS_DRDY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">IsDataReady</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//读取状态寄存器且判断第DRQ位是不是1</span></span><br><span class="line">    <span class="keyword">return</span> ReadPort(REG_STATUS) &amp; STATUS_DRQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LBA-Register"><a href="#LBA-Register" class="headerlink" title="LBA Register"></a>LBA Register</h4><p>LBA 即： Logical Block Addressing, 逻辑块地址， 是一种线性寻址的方式 ( 0- n ) 。LBA存储扇区编号</p>
<p>目前绝大多数硬盘支持 LBA 扇区寻址方式<br>通过 3.5 个寄存器（即： 28 位） 读写硬盘扇区  </p>
<ul>
<li>LBA Low: 保存逻辑扇区地址的低8 位</li>
<li>LBAMid: 保存逻辑扇区地址的中8 位 </li>
<li>LBAHigh: 保存逻辑扇区地址的高8 位   </li>
</ul>
<h4 id="Device-Register"><a href="#Device-Register" class="headerlink" title="Device Register"></a>Device Register</h4><p>LBA还有4位存储于Device Register的低4位，如图所示</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220807171337101.png" alt="image-20220807171337101"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建device寄存器的值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">MakeDevRegVal</span><span class="params">(uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//高四位1110   低四位HS3HS2HS1HS0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xE0</span> | ((si &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Command-Register"><a href="#Command-Register" class="headerlink" title="Command Register"></a>Command Register</h4><ul>
<li>获取硬盘信息：0xEC</li>
<li>读取扇区数据：0x20</li>
<li>数据写入扇区：0x30</li>
</ul>
<h4 id="status-Register"><a href="#status-Register" class="headerlink" title="status Register"></a>status Register</h4><p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220807171554587.png" alt="image-20220807171554587"></p>
<h2 id="硬盘读写"><a href="#硬盘读写" class="headerlink" title="硬盘读写"></a>硬盘读写</h2><h3 id="硬盘以扇区为基本读写单位"><a href="#硬盘以扇区为基本读写单位" class="headerlink" title="硬盘以扇区为基本读写单位"></a>硬盘<strong>以扇区为基本读写单位</strong></h3><ul>
<li>读写数据时需要计算目标扇区的逻辑地址 (LBA)</li>
<li>确定逻辑地址后， <strong>读取扇区数据到内存，每次先把512字节读到内存中</strong>，再从512字节中寻找需要的数据<br>读： 从读取的扇区中拷贝目标数据（拷贝到内存中）<br>写： 数据写入读取的扇区中，之后将扇区数据写回硬盘  </li>
</ul>
<h3 id="硬盘数据端口-0x1F0-的读写需要以双字节为单位（WORD"><a href="#硬盘数据端口-0x1F0-的读写需要以双字节为单位（WORD" class="headerlink" title="硬盘数据端口 (0x1F0) 的读写需要以双字节为单位（WORD)"></a>硬盘<strong>数据端口 (0x1F0) 的读写</strong>需要以双字节为单位（WORD)</h3><ul>
<li>cld 清空方向标志位，向高地址方向增加地址值</li>
<li>insw 端口操作，从<strong>DX指出的外设端口</strong>输入**一个字(双字节)**到由ES: DI指定的存储器中</li>
<li>outsw 端口操作，向端口写入一个字</li>
<li>rep  重复指令， 重复次数由 ecx寄存器指定  </li>
</ul>
<p>端口写入</p>
<p>从 edx 指定的端口中读取 2n 个字节并<strong>存入 edi 指向的地址（传入buf）</strong>中:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; void ReadPortW(ushort port, ushort* buf, uint n)</span><br><span class="line">; </span><br><span class="line">ReadPortW:</span><br><span class="line">    push ebp</span><br><span class="line">    mov  ebp, esp</span><br><span class="line">    </span><br><span class="line">    mov edx, [ebp + 8]   ; port</span><br><span class="line">    mov edi, [ebp + 12]  ; buf</span><br><span class="line">    mov ecx, [ebp + 16]  ; n</span><br><span class="line">    </span><br><span class="line">    cld</span><br><span class="line">    rep insw</span><br><span class="line">    </span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line">    leave</span><br><span class="line">    </span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>端口读出：将 esi 指向的 2n 个字节写入 edx 指定的端口中:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; void WritePortW(ushort port, ushort* buf, uint n)</span><br><span class="line">;</span><br><span class="line">WritePortW:</span><br><span class="line">    push ebp</span><br><span class="line">    mov  ebp, esp</span><br><span class="line">    </span><br><span class="line">    mov edx, [ebp + 8]   ; port</span><br><span class="line">    mov esi, [ebp + 12]  ; buf</span><br><span class="line">    mov ecx, [ebp + 16]  ; n</span><br><span class="line">    </span><br><span class="line">    cld</span><br><span class="line">    rep outsw    ; 反复向端口写入一个字</span><br><span class="line">    </span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line">    leave</span><br><span class="line">    </span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h3 id="逻辑块地址结构体"><a href="#逻辑块地址结构体" class="headerlink" title="逻辑块地址结构体"></a>逻辑块地址结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    byte lbaLow;</span><br><span class="line">    byte lbaMid;</span><br><span class="line">    byte lbaHigh;		<span class="comment">//LBA低24位</span></span><br><span class="line">    byte device;		<span class="comment">//LBA高4位</span></span><br><span class="line">    byte command;		<span class="comment">//读/写</span></span><br><span class="line">&#125; HDRegValue;</span><br><span class="line"><span class="function"><span class="keyword">static</span> HDRegValue <span class="title">MakeRegVals</span><span class="params">(uint si, uint action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HDRegValue ret = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//指定LBA地址</span></span><br><span class="line">    ret.lbaLow = si &amp; <span class="number">0xFF</span>;</span><br><span class="line">    ret.lbaMid = (si &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    ret.lbaHigh = (si &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    ret.device = MakeDevRegVal(si);</span><br><span class="line">    ret.command = action;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="硬盘操作基本步骤"><a href="#硬盘操作基本步骤" class="headerlink" title="硬盘操作基本步骤"></a>硬盘操作基本步骤</h3><ol>
<li><p>往命令块寄存器写数据（操作哪块硬盘，读取哪块扇区，如何读取）</p>
</li>
<li><p>往控制块寄存器写数据（）</p>
</li>
<li><p>从数据端口中读取数据readportw来读取数据</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_DEV_CTRL  0x3F6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_DATA      0x1F0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_FEATURES  0x1F1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_ERROR     0x1F1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_NSECTOR   0x1F2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_LBA_LOW   0x1F3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_LBA_MID   0x1F4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_LBA_HIGH  0x1F5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_DEVICE    0x1F6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_STATUS    0x1F7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_COMMAND   0x1F7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置命令块寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WritePorts</span><span class="params">(HDRegValue hdrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//命令块寄存器</span></span><br><span class="line">    WritePort(REG_FEATURES, <span class="number">0</span>);                     <span class="comment">//</span></span><br><span class="line">    WritePort(REG_NSECTOR, <span class="number">1</span>);                      <span class="comment">//每次只操作一个扇区</span></span><br><span class="line">    WritePort(REG_LBA_LOW, hdrv.lbaLow);            <span class="comment">//LBA的地址</span></span><br><span class="line">    WritePort(REG_LBA_MID, hdrv.lbaMid);</span><br><span class="line">    WritePort(REG_LBA_HIGH, hdrv.lbaHigh);          </span><br><span class="line">    WritePort(REG_DEVICE, hdrv.device);             <span class="comment">//操作哪块硬盘</span></span><br><span class="line">    WritePort(REG_COMMAND, hdrv.command);           <span class="comment">//指定命令块寄存器值 读/写</span></span><br><span class="line">    <span class="comment">//控制块寄存器</span></span><br><span class="line">    WritePort(REG_DEV_CTRL, <span class="number">0</span>);                     <span class="comment">//控制块命令字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">HDRawRead</span><span class="params">(uint si, byte* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (si &lt; HDRawSectors()) &amp;&amp; buf &amp;&amp; !IsBusy() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指定 LBA地址 和 读/写操作</span></span><br><span class="line">        HDRegValue hdrv = MakeRegVals(si, ATA_READ);</span><br><span class="line">        <span class="comment">//设置好命令块寄存器和控制块寄存器</span></span><br><span class="line">        WritePorts(hdrv);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( ret = (!IsBusy() &amp;&amp; IsDataReady()) )</span><br><span class="line">        &#123;</span><br><span class="line">            ushort* data = (ushort*)buf;</span><br><span class="line">            <span class="comment">//从insw读取数据</span></span><br><span class="line">            ReadPortW(REG_DATA, data, SECT_SIZE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">HDRawWrite</span><span class="params">(uint si, byte* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (si &lt; HDRawSectors()) &amp;&amp; buf &amp;&amp; !IsBusy() )</span><br><span class="line">    &#123;</span><br><span class="line">        HDRegValue hdrv = MakeRegVals(si, ATA_WRITE);</span><br><span class="line">        </span><br><span class="line">        WritePorts(hdrv);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( ret = (!IsBusy() &amp;&amp; IsDataReady()) )</span><br><span class="line">        &#123;</span><br><span class="line">            ushort* data = (ushort*)buf;</span><br><span class="line">            </span><br><span class="line">            WritePortW(REG_DATA, data, SECT_SIZE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取扇区总数"><a href="#获取扇区总数" class="headerlink" title="获取扇区总数"></a>获取扇区总数</h3><p>0号扇区的60-61字的位置记录了扇区总数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取扇区总数</span></span><br><span class="line"><span class="function">uint <span class="title">HDRawSectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> uint ret = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (ret == <span class="number">-1</span>) &amp;&amp; IsDevReady() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先指定寄存器的值</span></span><br><span class="line">        HDRegValue hdrv = MakeRegVals(<span class="number">0</span>, ATA_IDENTIFY);<span class="comment">//0号扇区，0xEC操作 获取硬盘信息</span></span><br><span class="line">        byte* buf = Malloc(SECT_SIZE);</span><br><span class="line">        <span class="comment">//insw对各个端口发送数据</span></span><br><span class="line">        WritePorts(hdrv);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( !IsBusy() &amp;&amp; IsDataReady() &amp;&amp; buf )</span><br><span class="line">        &#123;</span><br><span class="line">            ushort* data = (ushort*)buf;</span><br><span class="line">            <span class="comment">//insw 读取硬盘数据</span></span><br><span class="line">            ReadPortW(REG_DATA, data, SECT_SIZE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            ret = (data[<span class="number">61</span>] &lt;&lt; <span class="number">16</span>) | (data[<span class="number">60</span>]);<span class="comment">//硬盘固定位置存储的信息,拿到扇区数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Free(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件系统概要设计"><a href="#文件系统概要设计" class="headerlink" title="文件系统概要设计"></a>文件系统概要设计</h2><p>对于硬盘而言不知道所谓的文件系统，硬盘只有一个个的扇区，文件系统时操作系统的概念，文件是有逻辑关联的数据集合，并且数据之间有存储的先后关系</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220810001547973.png" alt="image-20220810001547973"></p>
<p>整个硬盘最大扇区数量为max，第0号扇区可以存储引导程序和文件系统基本信息。1号扇区存储根目录区。<br>扇区分配表记录扇区之间的逻辑关系，记录扇区是否可用。注意扇区分配表和文件数据区一一对应</p>
<h3 id="扇区分配表"><a href="#扇区分配表" class="headerlink" title="扇区分配表"></a>扇区分配表</h3><p>比如设置文件<code>test.txt</code>的<code>secBegin = addr_C</code>。扇区分配表的addr_C存储了下一个扇区是O</p>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220810001629196.png" alt="image-20220810001629196"></p>
<p><strong>扇区分配表组织成不同的链表</strong>，<strong>每个链表代表一个文件</strong>，同时的未使用的扇区也组织成一个空闲链表。<br>当一个文件需要更多扇区时，从空闲链表头部中取出一个链表头即可</p>
<p>文件管理的过程可看作扇区在不同链表中移动的过程</p>
<p>注意扇区分配表的大小，已知的硬盘扇区共有MAX个，那么<code>512/4*n = max-2-n</code> 可以求出扇区分配表占用扇区数目<code>n = (max-2)/129</code>（向上取整）</p>
<h3 id="引导区"><a href="#引导区" class="headerlink" title="引导区"></a>引导区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储于0号引导区</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    byte forJmp[<span class="number">4</span>];         <span class="comment">//预留给jmp指令使用,万一0号扇区需要存储引导程序呢</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">32</span>];         <span class="comment">//存储字符串标识现在是什么文件系统</span></span><br><span class="line">    uint sctNum;            <span class="comment">//多少扇区可以使用</span></span><br><span class="line">    uint mapSize;           <span class="comment">//扇区分配表的大小 </span></span><br><span class="line">    uint freeNum;           <span class="comment">//空闲链表长度</span></span><br><span class="line">    uint freeBegin;         <span class="comment">//空闲链表开始</span></span><br><span class="line">&#125; FSHeader;</span><br></pre></td></tr></table></figure>

<h3 id="根目录区"><a href="#根目录区" class="headerlink" title="根目录区"></a>根目录区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储于1号根目录区</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">32</span>];         <span class="comment">//&quot;ROOT&quot;</span></span><br><span class="line">    uint sctBegin;          <span class="comment">//根目录的开始扇区,本OS初始化时设置为1</span></span><br><span class="line">    uint sctNum;            <span class="comment">//占用多少个扇区,本OS初始化设置为0非法值,表示还没有FileEntry</span></span><br><span class="line">    uint lastBytes;         <span class="comment">//最后一个扇区用了多少字节</span></span><br><span class="line">&#125; FSRoot;</span><br></pre></td></tr></table></figure>

<p>根目录区也是一个文件，后面随着新建的文件越来越多，FSRoot的sctNum也会增加，FSRoot这条链表记录了FileEntry（文件的基本信息），然后通过FileEntry可以获得各个文件自己的链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];          <span class="comment">//文件名</span></span><br><span class="line">    uint sctBegin;          <span class="comment">//文件起始扇区</span></span><br><span class="line">    uint sctNum;            <span class="comment">//多少个扇区</span></span><br><span class="line">    uint lastBytes;         <span class="comment">//</span></span><br><span class="line">    uint type;              <span class="comment">//是文件还是目录 存储的是用户数据还是文件相关的数据</span></span><br><span class="line">    uint inSctIdx;          <span class="comment">//此FileEntry位于硬盘的哪一个扇区</span></span><br><span class="line">    uint inSctOff;          <span class="comment">//此FileEntry位于扇区内的偏移位置</span></span><br><span class="line">    uint reserved[<span class="number">2</span>];       <span class="comment">//预留</span></span><br><span class="line">&#125; FileEntry;</span><br></pre></td></tr></table></figure>

<h3 id="硬盘格式化操作"><a href="#硬盘格式化操作" class="headerlink" title="硬盘格式化操作"></a>硬盘格式化操作</h3><p>即建立引导区，根目录区和扇区分配表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">FSFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSHeader* header = (FSHeader*)Malloc(SECT_SIZE);        <span class="comment">//引导区</span></span><br><span class="line">    FSRoot* root = (FSRoot*)Malloc(SECT_SIZE);              <span class="comment">//根目录区</span></span><br><span class="line">    uint* p = (uint*)Malloc(MAP_ITEM_CNT * <span class="keyword">sizeof</span>(uint));   <span class="comment">//操作扇区分配表的每一个分配单元</span></span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( header &amp;&amp; root &amp;&amp; p )</span><br><span class="line">    &#123;</span><br><span class="line">        uint i = <span class="number">0</span>;</span><br><span class="line">        uint j = <span class="number">0</span>;</span><br><span class="line">        uint current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给引导区的内容赋值</span></span><br><span class="line">        StrCpy(header-&gt;magic, FS_MAGIC, <span class="keyword">sizeof</span>(header-&gt;magic)<span class="number">-1</span>);</span><br><span class="line">        header-&gt;sctNum = HDRawSectors();</span><br><span class="line">        header-&gt;mapSize = (header-&gt;sctNum - FIXED_SCT_SIZE) / <span class="number">129</span> + !!((header-&gt;sctNum - FIXED_SCT_SIZE) % <span class="number">129</span>);<span class="number">9</span></span><br><span class="line">        header-&gt;freeNum = header-&gt;sctNum - header-&gt;mapSize - FIXED_SCT_SIZE;</span><br><span class="line">        header-&gt;freeBegin = FIXED_SCT_SIZE + header-&gt;mapSize;</span><br><span class="line">        <span class="comment">//注意一定要写回硬盘</span></span><br><span class="line">        ret = HDRawWrite(HEADER_SCT_IDX, (byte*)header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给根目录区的相关成员赋值</span></span><br><span class="line">        StrCpy(root-&gt;magic, ROOT_MAGIC, <span class="keyword">sizeof</span>(root-&gt;magic)<span class="number">-1</span>);</span><br><span class="line">        root-&gt;sctNum = <span class="number">0</span>;               <span class="comment">//根目录占用的扇区数目为0</span></span><br><span class="line">        root-&gt;sctBegin = SCT_END_FLAG;  <span class="comment">//标记为非法扇区</span></span><br><span class="line">        root-&gt;lastBytes = SECT_SIZE;	<span class="comment">//ROOT此扇区标记512字节都用完了</span></span><br><span class="line">        <span class="comment">//注意一定要写回硬盘</span></span><br><span class="line">        ret = ret &amp;&amp; HDRawWrite(ROOT_SCT_IDX, (byte*)root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//针对于扇区分配表(2~n 的扇区)的每个分配单元赋值</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; ret &amp;&amp; (i&lt;header-&gt;mapSize) &amp;&amp; (current&lt;header-&gt;freeNum); i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//每个扇区的128个的每个分配单元赋值</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;MAP_ITEM_CNT; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                uint* pInt = AddrOff(p, j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( current &lt; header-&gt;freeNum )</span><br><span class="line">                &#123;	<span class="comment">//分配单元组织成链表</span></span><br><span class="line">                    *pInt = current + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( current == (header-&gt;freeNum - <span class="number">1</span>) )</span><br><span class="line">                    &#123;	<span class="comment">//最后一个设置成SCT_END_FLAG表示是链表尾部</span></span><br><span class="line">                        *pInt = SCT_END_FLAG;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    current++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写回硬盘</span></span><br><span class="line">            ret = ret &amp;&amp; HDRawWrite(i + FIXED_SCT_SIZE, (byte*)p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(header);</span><br><span class="line">    Free(root);</span><br><span class="line">    Free(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220810003851627.png" alt="image-20220810003851627"></p>
<h3 id="如何根据扇区号获取处于扇区分配表中的位置？"><a href="#如何根据扇区号获取处于扇区分配表中的位置？" class="headerlink" title="如何根据扇区号获取处于扇区分配表中的位置？"></a><strong>如何根据扇区号获取处于扇区分配表中的位置？</strong></h3><p>扇区操作是一种外存操作，需要仔细计算出位于哪一个扇区，扇区内偏移地址是多少，扇区管理时使用相对扇区地址，扇区读写使用绝对地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">扇区相对地址：offset 	= si - mapsize - <span class="number">2</span>			<span class="comment">//具体外存的扇区相对位置  mapSize 根目录区大小</span></span><br><span class="line">            si 		= offset + mapsize + <span class="number">2</span>       <span class="comment">//具体外存的扇区位置</span></span><br><span class="line">位于哪个扇区：sctOff = offset/MAP_ITEM_CNT			<span class="comment">//扇区分配表中 offset/128 </span></span><br><span class="line">扇区内的偏移：idxOff = offset%MAP_ITEM_CNT			<span class="comment">//扇区分配表中 offset%128</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220813135403193.png" alt="image-20220813135403193"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint* pSct;             <span class="comment">//指向对应管理单元所在扇区</span></span><br><span class="line">    uint sctIdx;            <span class="comment">//原始绝对扇区号</span></span><br><span class="line">    uint sctOff;            <span class="comment">//对应的分配单元(扇区分配表中)的在哪个扇区</span></span><br><span class="line">    uint idxOff;            <span class="comment">//扇区中偏移位置</span></span><br><span class="line">&#125; MapPos;</span><br><span class="line"><span class="comment">//绝对地址转为相对地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> MapPos <span class="title">FindInMap</span><span class="params">(uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MapPos ret = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FSHeader* header = (si != SCT_END_FLAG) ? ReadSector(HEADER_SCT_IDX) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( header )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//绝对地址转换位相对地址</span></span><br><span class="line">        uint offset = si - header-&gt;mapSize - FIXED_SCT_SIZE;</span><br><span class="line">        uint sctOff = offset / MAP_ITEM_CNT;</span><br><span class="line">        uint idxOff = offset % MAP_ITEM_CNT;</span><br><span class="line">        uint* ps = ReadSector(sctOff + FIXED_SCT_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ps )</span><br><span class="line">        &#123;</span><br><span class="line">            ret.pSct = ps;</span><br><span class="line">            ret.sctIdx = si;</span><br><span class="line">            ret.sctOff = sctOff;</span><br><span class="line">            ret.idxOff = idxOff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(header);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扇区分配函数"><a href="#扇区分配函数" class="headerlink" title="扇区分配函数"></a>扇区分配函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个空闲的扇区号</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">AllocSector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = SCT_END_FLAG;</span><br><span class="line">    FSHeader* header = ReadSector(HEADER_SCT_IDX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( header &amp;&amp; (header-&gt;freeBegin != SCT_END_FLAG) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//去根目录区拿出链表头,找出分配单元的具体位置</span></span><br><span class="line">        MapPos mp = FindInMap(header-&gt;freeBegin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( mp.pSct )</span><br><span class="line">        &#123;</span><br><span class="line">            uint* pInt = AddrOff(mp.pSct, mp.idxOff);   <span class="comment">//取出分配单元</span></span><br><span class="line">            uint next = *pInt;                          <span class="comment">//下一个分配单元的位置</span></span><br><span class="line">            uint flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            ret = header-&gt;freeBegin;</span><br><span class="line">            <span class="comment">//更新header信息 空闲扇区位置 空闲扇区数量</span></span><br><span class="line">            header-&gt;freeBegin = next + FIXED_SCT_SIZE + header-&gt;mapSize;</span><br><span class="line">            header-&gt;freeNum--;</span><br><span class="line">            <span class="comment">//当前分配单元标记为不可用</span></span><br><span class="line">            *pInt = SCT_END_FLAG;</span><br><span class="line">            <span class="comment">//外存数据更新</span></span><br><span class="line">            flag = flag &amp;&amp; HDRawWrite(HEADER_SCT_IDX, (byte*)header);</span><br><span class="line">            flag = flag &amp;&amp; HDRawWrite(mp.sctOff + FIXED_SCT_SIZE, (byte*)mp.pSct);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !flag )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = SCT_END_FLAG;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(mp.pSct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扇区归还函数"><a href="#扇区归还函数" class="headerlink" title="扇区归还函数"></a>扇区归还函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FreeSector</span><span class="params">(uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSHeader* header = (si != SCT_END_FLAG) ? ReadSector(HEADER_SCT_IDX) : <span class="literal">NULL</span>;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( header )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取扇区分配单元的信息</span></span><br><span class="line">        MapPos mp = FindInMap(si);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( mp.pSct )</span><br><span class="line">        &#123;</span><br><span class="line">            uint* pInt = AddrOff(mp.pSct, mp.idxOff);</span><br><span class="line">            <span class="comment">//此扇区分配管理单元插入到空闲扇区的头部,因此赋值为原先的头节点的扇区位置</span></span><br><span class="line">            *pInt = header-&gt;freeBegin - FIXED_SCT_SIZE - header-&gt;mapSize;</span><br><span class="line"></span><br><span class="line">            header-&gt;freeBegin = si;</span><br><span class="line">            header-&gt;freeNum++;</span><br><span class="line"></span><br><span class="line">            ret = HDRawWrite(HEADER_SCT_IDX, (byte*)header) &amp;&amp;</span><br><span class="line">                  HDRawWrite(mp.sctOff + FIXED_SCT_SIZE, (byte*)mp.pSct);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(mp.pSct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取下一个分配单元</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前扇区的后继扇区 通过读取扇区分配表可以知道后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">NextSector</span><span class="params">(uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSHeader* header = (si != SCT_END_FLAG) ? ReadSector(HEADER_SCT_IDX) : <span class="literal">NULL</span>;</span><br><span class="line">    uint ret = SCT_END_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( header )</span><br><span class="line">    &#123;   <span class="comment">//获取分配单元位置</span></span><br><span class="line">        MapPos mp = FindInMap(si);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( mp.pSct )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//后继扇区的相对位置</span></span><br><span class="line">            uint* pInt = AddrOff(mp.pSct, mp.idxOff);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( *pInt != SCT_END_FLAG )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = *pInt + header-&gt;mapSize + FIXED_SCT_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(mp.pSct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助功能函数"><a href="#辅助功能函数" class="headerlink" title="辅助功能函数"></a>辅助功能函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找链表的最后一个扇区, 空闲链表、已经分配的链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FindLast</span><span class="params">(uint sctBegin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = SCT_END_FLAG;</span><br><span class="line">    uint next = sctBegin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( next != SCT_END_FLAG )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = next;</span><br><span class="line">        next = NextSector(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找链表的前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FindPrev</span><span class="params">(uint sctBegin, uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = SCT_END_FLAG;</span><br><span class="line">    uint next = sctBegin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( (next != SCT_END_FLAG) &amp;&amp; (next != si) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = next;</span><br><span class="line">        next = NextSector(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( next == SCT_END_FLAG )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = SCT_END_FLAG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找链表当中的第n号扇区</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FindIndex</span><span class="params">(uint sctBegin, uint idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = sctBegin;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( (i &lt; idx) &amp;&amp; (ret != SCT_END_FLAG) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = NextSector(ret);</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记扇区目标扇区不可用 分配管理单元设置为SCT_END_FLAG(-1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">MarkSector</span><span class="params">(uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = (si == SCT_END_FLAG) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    MapPos mp = FindInMap(si);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( mp.pSct )</span><br><span class="line">    &#123;</span><br><span class="line">        uint *pInt = AddrOff(mp.pSct, mp.idxOff);</span><br><span class="line"></span><br><span class="line">        *pInt = SCT_END_FLAG;</span><br><span class="line"></span><br><span class="line">        ret = HDRawWrite(mp.sctOff + FIXED_SCT_SIZE, (byte*)mp.pSct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(mp.pSct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文件流程-构建FileEntry"><a href="#创建文件流程-构建FileEntry" class="headerlink" title="创建文件流程-构建FileEntry"></a>创建文件流程-构建FileEntry</h3><p>根目录存储的时FileEntry类型的值，每个FileEntry值表示一个硬盘的文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">32</span>];         <span class="comment">//&quot;ROOT&quot;</span></span><br><span class="line">    uint sctBegin;          <span class="comment">//根目录的开始扇区,本OS初始化时设置为1</span></span><br><span class="line">    uint sctNum;            <span class="comment">//占用多少个扇区,本OS初始化设置为0非法值,表示还没有FileEntry</span></span><br><span class="line">    uint lastBytes;			<span class="comment">//最后一个扇区用了多少字节</span></span><br><span class="line">&#125; FSRoot;</span><br><span class="line"><span class="comment">//与FSRoot构成继承关系</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];          <span class="comment">//文件名</span></span><br><span class="line">    uint sctBegin;          <span class="comment">//文件起始扇区</span></span><br><span class="line">    uint sctNum;            <span class="comment">//多少个扇区</span></span><br><span class="line">    uint lastBytes;         <span class="comment">//</span></span><br><span class="line">    uint type;              <span class="comment">//是文件还是目录 存储的是用户数据还是文件相关的数据</span></span><br><span class="line">    uint inSctIdx;          <span class="comment">//此FileEntry位于硬盘的哪一个扇区</span></span><br><span class="line">    uint inSctOff;			<span class="comment">//此FileEntry位于的扇区内偏移位置</span></span><br><span class="line">    uint reserved[<span class="number">2</span>];		<span class="comment">//预留</span></span><br><span class="line">&#125; FileEntry;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220813154620749.png" alt="image-20220813154620749"></p>
<p>如图所示每个fileEntry对应一个文件。一个扇区可以存储8个FileEntry（示意图上3个有点问题）。根目录的数据链表存储了所有的fileEntry值（随着文件数目越来越多，根目录区的FSRoot数据结构成员sctNum会增加）</p>
<ol>
<li>是否有足够空间写入数据，如果空间不足，（比如初始化时把root的lastbytes赋值为512，属于空间不足的情况）因此会找另外一个新的空扇区存放下一个，并且设置sctNum++和lastbyte为0</li>
<li>在ROOT链表尾部的扇区存放FileEntry并且赋值，最后写入硬盘</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddToLast</span><span class="params">(uint sctBegin, uint si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到此文件的last扇区</span></span><br><span class="line">    uint last = FindLast(sctBegin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( last != SCT_END_FLAG )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//管理单元</span></span><br><span class="line">        MapPos lmp = FindInMap(last);</span><br><span class="line">        MapPos smp = FindInMap(si);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( lmp.pSct &amp;&amp; smp.pSct )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两个管理单元位于同一个扇区，只需要写一次硬盘即可</span></span><br><span class="line">            <span class="keyword">if</span>( lmp.sctOff == smp.sctOff )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//拿到last管理单元</span></span><br><span class="line">                uint* pInt = AddrOff(lmp.pSct, lmp.idxOff);</span><br><span class="line">                <span class="comment">//si的相对地址赋给 last管理单元</span></span><br><span class="line">                *pInt = lmp.sctOff * MAP_ITEM_CNT + smp.idxOff;</span><br><span class="line">                <span class="comment">//拿到尾部si对应的管理单元</span></span><br><span class="line">                pInt = AddrOff(lmp.pSct, smp.idxOff);</span><br><span class="line">                <span class="comment">//赋值</span></span><br><span class="line">                *pInt = SCT_END_FLAG;</span><br><span class="line">                <span class="comment">//仅仅写一次即可</span></span><br><span class="line">                HDRawWrite(lmp.sctOff + FIXED_SCT_SIZE, (byte*)lmp.pSct);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//拿到last管理单元</span></span><br><span class="line">                uint* pInt = AddrOff(lmp.pSct, lmp.idxOff);</span><br><span class="line">                <span class="comment">//si的相对地址赋值给 last管理单元</span></span><br><span class="line">                *pInt = smp.sctOff * MAP_ITEM_CNT + smp.idxOff;</span><br><span class="line"></span><br><span class="line">                pInt = AddrOff(smp.pSct, smp.idxOff);</span><br><span class="line"></span><br><span class="line">                *pInt = SCT_END_FLAG;</span><br><span class="line">                <span class="comment">//操作了两个扇区需要写两次硬盘</span></span><br><span class="line">                HDRawWrite(lmp.sctOff + FIXED_SCT_SIZE, (byte*)lmp.pSct);</span><br><span class="line">                HDRawWrite(smp.sctOff + FIXED_SCT_SIZE, (byte*)smp.pSct);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(lmp.pSct);</span><br><span class="line">        Free(smp.pSct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">CheckStorage</span><span class="params">(FSRoot* fe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最后一个扇区是512字节需要扩展容量</span></span><br><span class="line">    <span class="keyword">if</span>( fe-&gt;lastBytes == SECT_SIZE )</span><br><span class="line">    &#123;</span><br><span class="line">        uint si = AllocSector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( si != SCT_END_FLAG )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前数据链表是空链表，则新申请的扇区是链表第一个节点</span></span><br><span class="line">            <span class="keyword">if</span>( fe-&gt;sctBegin == SCT_END_FLAG )</span><br><span class="line">            &#123;</span><br><span class="line">                fe-&gt;sctBegin = si;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则加入到尾部</span></span><br><span class="line">            &#123;</span><br><span class="line">                AddToLast(fe-&gt;sctBegin, si);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fe-&gt;sctNum++;</span><br><span class="line">            fe-&gt;lastBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">CreateFileEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, uint sctBegin, uint lastBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    uint last = FindLast(sctBegin);         <span class="comment">//链表最后一个扇区</span></span><br><span class="line">    FileEntry* feBase = <span class="literal">NULL</span>;               <span class="comment">//并且将扇区从硬盘读入内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (last != SCT_END_FLAG) &amp;&amp; (feBase = (FileEntry*)ReadSector(last)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要在目标扇区写入新的FileEntry值</span></span><br><span class="line">        <span class="comment">//偏移位置做除法即可得到，跳过前面已经写好的fileEntry</span></span><br><span class="line">        uint offset = lastBytes / FE_BYTES;</span><br><span class="line">        FileEntry* fe = AddrOff(feBase, offset);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        StrCpy(fe-&gt;name, name, <span class="keyword">sizeof</span>(fe-&gt;name) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        fe-&gt;type = <span class="number">0</span>;</span><br><span class="line">        fe-&gt;sctBegin = SCT_END_FLAG;</span><br><span class="line">        fe-&gt;sctNum = <span class="number">0</span>;</span><br><span class="line">        fe-&gt;inSctIdx = last;</span><br><span class="line">        fe-&gt;inSctOff = offset;</span><br><span class="line">        fe-&gt;lastBytes = SECT_SIZE;</span><br><span class="line">        <span class="comment">//新的FileEntry已经写入硬盘</span></span><br><span class="line">        ret = HDRawWrite(last, (byte*)feBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(feBase);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">CreateInRoot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSRoot* root = (FSRoot*)ReadSector(ROOT_SCT_IDX);</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( root )</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//确保root空间足够</span></span><br><span class="line">        CheckStorage(root);</span><br><span class="line">        <span class="comment">//创建一个新文件</span></span><br><span class="line">        <span class="keyword">if</span>( CreateFileEntry(name, root-&gt;sctBegin, root-&gt;lastBytes) )</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;lastBytes += FE_BYTES;</span><br><span class="line"></span><br><span class="line">            ret = HDRawWrite(ROOT_SCT_IDX, (byte*)root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FileEntry* <span class="title">FindFileEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, uint sctBegin, uint sctNum, uint lastBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileEntry* ret = <span class="literal">NULL</span>;</span><br><span class="line">    uint next = sctBegin;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历数据链表,前n-1个扇区是完全利用了</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;(sctNum<span class="number">-1</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FileEntry* feBase = (FileEntry*)ReadSector(next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( feBase )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查找的名字,位置,次数</span></span><br><span class="line">            ret = FindInSector(name, feBase, FE_ITEM_CNT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(feBase);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !ret )</span><br><span class="line">        &#123;</span><br><span class="line">            next = NextSector(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个扇区找,最后一个扇区不一定充分利用,计算一下找了多少次</span></span><br><span class="line">    <span class="keyword">if</span>( !ret )</span><br><span class="line">    &#123;</span><br><span class="line">        uint cnt = lastBytes / FE_BYTES;</span><br><span class="line">        FileEntry* feBase = (FileEntry*)ReadSector(next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( feBase )</span><br><span class="line">        &#123;</span><br><span class="line">            ret = FindInSector(name, feBase, cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(feBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileEntry* <span class="title">FindInRoot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileEntry* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//root读取到内存中</span></span><br><span class="line">    FSRoot* root = (FSRoot*)ReadSector(ROOT_SCT_IDX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( root &amp;&amp; root-&gt;sctNum )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = FindFileEntry(name, root-&gt;sctBegin, root-&gt;sctNum, root-&gt;lastBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">FExisted</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = FS_FAILED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( fn )</span><br><span class="line">    &#123;</span><br><span class="line">        FileEntry* fe = FindInRoot(fn);</span><br><span class="line"></span><br><span class="line">        ret = fe ? FS_EXISTED : FS_NONEXISTED;</span><br><span class="line"></span><br><span class="line">        Free(fe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文件流程"><a href="#删除文件流程" class="headerlink" title="删除文件流程"></a>删除文件流程</h3><ul>
<li>根据文件名在根目录的数据链表中查找FileEntry值。从数据链表中删除FileEntry值</li>
<li>注意需要判断目标文件是否已经打开，只有在关闭状态才能被删除</li>
<li>将数据链表的最后一个<code>FileEntry</code>移动到被删除的<code>FileEntry</code>位置（注意如图所示<code>FileEntry5</code>的<code>inSctIdx,inSctOff</code>）处并且更新<code>lastbyte</code>值的大小（lastbytes大小减小64，注意如果<code>lastbytes</code>大小为64，减去后变为0，那么还需要把整个扇区给归还<code>AdjustStorage</code>到空闲链表）</li>
</ul>
<p><img src="/../images/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20220813170040854.png" alt="image-20220813170040854"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FreeFile</span><span class="params">(uint sctBegin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint slider = sctBegin;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将此FileEntry开始到结束的扇区全都释放掉</span></span><br><span class="line">    <span class="keyword">while</span>( slider != SCT_END_FLAG )</span><br><span class="line">    &#123;   </span><br><span class="line">        uint next = NextSector(slider);</span><br><span class="line"></span><br><span class="line">        ret += FreeSector(slider);</span><br><span class="line"></span><br><span class="line">        slider = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回成功释放的总数</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MoveFileEntry</span><span class="params">(FileEntry* dst, FileEntry* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint inSctIdx = dst-&gt;inSctIdx;</span><br><span class="line">    uint inSctOff = dst-&gt;inSctOff;</span><br><span class="line"></span><br><span class="line">    *dst = *src;</span><br><span class="line"></span><br><span class="line">    dst-&gt;inSctIdx = inSctIdx;       <span class="comment">//此FileEntry位于硬盘的哪一个扇区</span></span><br><span class="line">    dst-&gt;inSctOff = inSctOff;       <span class="comment">//此FileEntry位于扇区的偏移位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">AdjustStorage</span><span class="params">(FSRoot* fe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !fe-&gt;lastBytes )            <span class="comment">//最后一个扇区是否完全空闲</span></span><br><span class="line">    &#123;   <span class="comment">//查找最后一个扇区和倒数第二个扇区</span></span><br><span class="line">        uint last = FindLast(fe-&gt;sctBegin);</span><br><span class="line">        uint prev = FindPrev(fe-&gt;sctBegin, last);</span><br><span class="line">        <span class="comment">//释放最后一个扇区并且标记倒数第二个扇区为最后一个扇区</span></span><br><span class="line">        <span class="keyword">if</span>( FreeSector(last) &amp;&amp; MarkSector(prev) )</span><br><span class="line">        &#123;</span><br><span class="line">            fe-&gt;sctNum--;</span><br><span class="line">            fe-&gt;lastBytes = SECT_SIZE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !fe-&gt;sctNum )</span><br><span class="line">            &#123;</span><br><span class="line">                fe-&gt;sctBegin = SCT_END_FLAG;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据链表中要抹除的最后n个字节，对FileEntry的lastbyte操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">EraseLast</span><span class="params">(FSRoot* fe, uint bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( fe-&gt;sctNum &amp;&amp; bytes )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//小于最后扇区数据，直接抹除</span></span><br><span class="line">        <span class="keyword">if</span>( bytes &lt; fe-&gt;lastBytes )</span><br><span class="line">        &#123;</span><br><span class="line">            fe-&gt;lastBytes -= bytes;</span><br><span class="line"></span><br><span class="line">            ret += bytes;</span><br><span class="line"></span><br><span class="line">            bytes = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//最后一个扇区的数据要全部抹除</span></span><br><span class="line">            bytes -= fe-&gt;lastBytes;</span><br><span class="line"></span><br><span class="line">            ret += fe-&gt;lastBytes;</span><br><span class="line"></span><br><span class="line">            fe-&gt;lastBytes = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将最后一个扇区归还到空闲扇区区</span></span><br><span class="line">            AdjustStorage(fe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">DeleteInRoot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSRoot* root = (FSRoot*)ReadSector(ROOT_SCT_IDX);</span><br><span class="line">    <span class="comment">//查找到对应的FileEntry</span></span><br><span class="line">    FileEntry* fe = FindInRoot(name);</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( root &amp;&amp; fe )</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//查找最后一个扇区并且将最后一个扇区读取到内存中</span></span><br><span class="line">        uint last = FindLast(root-&gt;sctBegin);</span><br><span class="line">        <span class="comment">//目标FileEntry所在的扇区也要读取到内存中</span></span><br><span class="line">        FileEntry* feTarget = ReadSector(fe-&gt;inSctIdx);</span><br><span class="line">        <span class="comment">//将最后一个扇区读到内存中</span></span><br><span class="line">        FileEntry* feLast = (last != SCT_END_FLAG) ? ReadSector(last) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( feTarget &amp;&amp; feLast )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定位最后一个FileEntry</span></span><br><span class="line">            uint lastOff = root-&gt;lastBytes / FE_BYTES - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//读取最后一个扇区的最后一个FileEntry和目标FileEntry</span></span><br><span class="line">            FileEntry* lastItem = AddrOff(feLast, lastOff);</span><br><span class="line">            FileEntry* targetItem = AddrOff(feTarget, fe-&gt;inSctOff);</span><br><span class="line">            <span class="comment">//将数据链表的每一个扇区释放扇区，本质是链表遍历</span></span><br><span class="line">            FreeFile(targetItem-&gt;sctBegin);</span><br><span class="line">            <span class="comment">//移动FileEntry的值</span></span><br><span class="line">            MoveFileEntry(targetItem, lastItem);</span><br><span class="line">            <span class="comment">//FileEntry对应的数据链表中要抹除的最后n个字节，是对FileEntry的lastbyte操作</span></span><br><span class="line">            EraseLast(root, FE_BYTES);</span><br><span class="line">            <span class="comment">//一定要写回硬盘</span></span><br><span class="line">            ret = HDRawWrite(ROOT_SCT_IDX, (byte*)root) &amp;&amp;</span><br><span class="line">                    HDRawWrite(fe-&gt;inSctIdx, (byte*)feTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(feTarget);</span><br><span class="line">        Free(feLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free(root);</span><br><span class="line">    Free(fe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重命名根目录中的文件"><a href="#重命名根目录中的文件" class="headerlink" title="重命名根目录中的文件"></a>重命名根目录中的文件</h3><ul>
<li>判断目标文件是否打开，只有关闭状态才能重命名</li>
<li>根据名字查找目标FileEntry的位置</li>
<li>查找新名字是否已经被占用，未被占用才可修改</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FlushFileEntry</span><span class="params">(FileEntry* fe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将FileEntry读取到内存中</span></span><br><span class="line">    FileEntry* feBase = ReadSector(fe-&gt;inSctIdx);</span><br><span class="line">    FileEntry* feInSct = AddrOff(feBase, fe-&gt;inSctOff);</span><br><span class="line"></span><br><span class="line">    *feInSct = *fe;</span><br><span class="line">    <span class="comment">//修改并且写回硬盘</span></span><br><span class="line">    ret = HDRawWrite(fe-&gt;inSctIdx, (byte*)feBase);</span><br><span class="line"></span><br><span class="line">    Free(feBase);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">FRename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ofn, <span class="keyword">const</span> <span class="keyword">char</span>* nfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = FS_FAILED;</span><br><span class="line">    <span class="comment">//未被打开且新名字不为空</span></span><br><span class="line">    <span class="keyword">if</span>( ofn &amp;&amp; !IsOpened(ofn) &amp;&amp; nfn )</span><br><span class="line">    &#123;   </span><br><span class="line">        FileEntry* ofe = FindInRoot(ofn);</span><br><span class="line">        FileEntry* nfe = FindInRoot(nfn);</span><br><span class="line">        <span class="comment">//目标文件存在且新名字文件名也没被占用</span></span><br><span class="line">        <span class="keyword">if</span>( ofe &amp;&amp; !nfe )</span><br><span class="line">        &#123;   <span class="comment">//拷贝名字</span></span><br><span class="line">            StrCpy(ofe-&gt;name, nfn, <span class="keyword">sizeof</span>(ofe-&gt;name) - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//写回硬盘</span></span><br><span class="line">            <span class="keyword">if</span>( FlushFileEntry(ofe) )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = FS_SUCCEED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(ofe);</span><br><span class="line">        Free(nfe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>用于描述已经打开的文件，文件的信息FileEntry，文件读写位置等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List gFDList = &#123;<span class="number">0</span>&#125;;  <span class="comment">//全局已经打开的文件描述符链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ListNode head;          <span class="comment">//链表--文件描述符最后也要构成一个链表</span></span><br><span class="line">    FileEntry fe;           <span class="comment">//FileEntry必备</span></span><br><span class="line">    uint objIdx;            <span class="comment">//文件读写位置-哪一个扇区</span></span><br><span class="line">    uint offset;            <span class="comment">//文件读写位置-扇区内偏移位置</span></span><br><span class="line">    uint changed;           <span class="comment">//标志文件已经改变，关闭文件时changed若为1则将cache写入到硬盘</span></span><br><span class="line">    byte cache[SECT_SIZE];  <span class="comment">//文件缓冲区-512字节大小</span></span><br><span class="line">&#125; FileDesc;</span><br></pre></td></tr></table></figure>

<h3 id="文件打开关闭函数"><a href="#文件打开关闭函数" class="headerlink" title="文件打开关闭函数"></a>文件打开关闭函数</h3><p>会将文件描述符加入/删除全局文件描述符链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">IsFDValid</span><span class="params">(FileDesc* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    ListNode* pos = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    List_ForEach(&amp;gFDList, pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( IsEqual(pos, fd) )</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">FlushCache</span><span class="params">(FileDesc* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( fd-&gt;changed )</span><br><span class="line">    &#123;</span><br><span class="line">        uint sctIdx = FindIndex(fd-&gt;fe.sctBegin, fd-&gt;objIdx);</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (sctIdx != SCT_END_FLAG) &amp;&amp; (ret = HDRawWrite(sctIdx, fd-&gt;cache)) )</span><br><span class="line">        &#123;</span><br><span class="line">            fd-&gt;changed = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">ToFlush</span><span class="params">(FileDesc* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FlushCache(fd) &amp;&amp; FlushFileEntry(&amp;fd-&gt;fe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">FOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileDesc* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//文件名不为空且文件未被打开</span></span><br><span class="line">    <span class="keyword">if</span>( fn &amp;&amp; !IsOpened(fn) )</span><br><span class="line">    &#123;</span><br><span class="line">        FileEntry* fe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//分配文件描述符并且获取FileEntry</span></span><br><span class="line">        ret = (FileDesc*)Malloc(FD_BYTES);</span><br><span class="line">        fe = ret ? FindInRoot(fn) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ret &amp;&amp; fe )</span><br><span class="line">        &#123;</span><br><span class="line">            ret-&gt;fe = *fe;</span><br><span class="line">            ret-&gt;objIdx = SCT_END_FLAG;</span><br><span class="line">            ret-&gt;offset = SECT_SIZE;</span><br><span class="line">            ret-&gt;changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            List_Add(&amp;gFDList, (ListNode*)ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Free(fe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (uint)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FClose</span><span class="params">(uint fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line">    <span class="comment">//文件描述符是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;   <span class="comment">//写到硬盘上</span></span><br><span class="line">        ToFlush(pf);</span><br><span class="line">        <span class="comment">//链表删除</span></span><br><span class="line">        List_DelNode((ListNode*)pf);</span><br><span class="line"></span><br><span class="line">        Free(pf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件数据写入函数"><a href="#文件数据写入函数" class="headerlink" title="文件数据写入函数"></a>文件数据写入函数</h3><p>写入数据的时候，文件数据链表可能变长。写入数据先写入缓冲区中，当缓冲区写满了之后，要将缓冲区写入扇区并且将下一个扇区的内容读取到缓冲区中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的第idx个扇区数据读入缓冲区中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">ReadToCache</span><span class="params">(FileDesc* fd, uint idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( idx &lt; fd-&gt;fe.sctNum )</span><br><span class="line">    &#123;</span><br><span class="line">        uint sctIdx = FindIndex(fd-&gt;fe.sctBegin, idx);</span><br><span class="line"></span><br><span class="line">        ToFlush(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (sctIdx != SCT_END_FLAG) &amp;&amp; (ret = HDRawRead(sctIdx, fd-&gt;cache)) )</span><br><span class="line">        &#123;</span><br><span class="line">            fd-&gt;objIdx = idx;</span><br><span class="line">            fd-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            fd-&gt;changed = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">PrepareCache</span><span class="params">(FileDesc* fd, uint objIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//文件是否需要扩容</span></span><br><span class="line">    CheckStorage(&amp;fd-&gt;fe);</span><br><span class="line">    <span class="comment">//指定扇区数据读入缓冲区中</span></span><br><span class="line">    <span class="keyword">return</span> ReadToCache(fd, objIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">CopyToCache</span><span class="params">(FileDesc* fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( fd-&gt;objIdx != SCT_END_FLAG )</span><br><span class="line">    &#123;   <span class="comment">//计算能向缓冲区写入的最大数据量</span></span><br><span class="line">        uint n = SECT_SIZE - fd-&gt;offset;</span><br><span class="line">        byte* p = AddrOff(fd-&gt;cache, fd-&gt;offset);</span><br><span class="line"></span><br><span class="line">        n = (n &lt; len) ? n : len;</span><br><span class="line"></span><br><span class="line">        MemCpy(p, buf, n);</span><br><span class="line"></span><br><span class="line">        fd-&gt;offset += n;</span><br><span class="line">        fd-&gt;changed = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新数据链表的最后一个扇区的数据总量，如果offset超过lastbyte更新lastbyte</span></span><br><span class="line">        <span class="keyword">if</span>( ((fd-&gt;fe.sctNum - <span class="number">1</span>) == fd-&gt;objIdx) &amp;&amp; (fd-&gt;fe.lastBytes &lt; fd-&gt;offset) )</span><br><span class="line">        &#123;</span><br><span class="line">            fd-&gt;fe.lastBytes = fd-&gt;offset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">ToWrite</span><span class="params">(FileDesc* fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">1</span>;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line">    uint n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( (i &lt; len) &amp;&amp; ret )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p初始时指向buf开始位置</span></span><br><span class="line">        byte* p = AddrOff(buf, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( fd-&gt;offset == SECT_SIZE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//文件要写入的扇区内offset=512时，需要扩容一个新扇区，读取文件数据链表的下一个扇区</span></span><br><span class="line">            ret = PrepareCache(fd, fd-&gt;objIdx + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ret )</span><br><span class="line">        &#123;   <span class="comment">//数据写入缓冲区</span></span><br><span class="line">            n = CopyToCache(fd, p, len - i);</span><br><span class="line"></span><br><span class="line">            i += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">FWrite</span><span class="params">(uint fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid((FileDesc*)fd) &amp;&amp; buf )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ToWrite((FileDesc*)fd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件中读数据"><a href="#文件中读数据" class="headerlink" title="文件中读数据"></a>文件中读数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件读写指针的位置 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">GetFilePos</span><span class="params">(FileDesc* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( fd-&gt;objIdx != SCT_END_FLAG )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = fd-&gt;objIdx * SECT_SIZE + fd-&gt;offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">CopyFromCache</span><span class="params">(FileDesc* fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = (fd-&gt;objIdx != SCT_END_FLAG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ret )</span><br><span class="line">    &#123;   <span class="comment">//计算当前缓冲区可提供的最大数据量以及数据起始位置</span></span><br><span class="line">        uint n = SECT_SIZE - fd-&gt;offset;</span><br><span class="line">        byte* p = AddrOff(fd-&gt;cache, fd-&gt;offset);</span><br><span class="line"></span><br><span class="line">        n = (n &lt; len) ? n : len;</span><br><span class="line"></span><br><span class="line">        MemCpy(buf, p, n);</span><br><span class="line"></span><br><span class="line">        fd-&gt;offset += n;</span><br><span class="line"></span><br><span class="line">        ret = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">ToRead</span><span class="params">(FileDesc* fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算最大可读取数据量</span></span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    uint n = GetFileLen(fd) - GetFilePos(fd);</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len = (len &lt; n) ? len : n;</span><br><span class="line">    <span class="comment">//循环读取</span></span><br><span class="line">    <span class="keyword">while</span>( (i &lt; len) &amp;&amp; ret )</span><br><span class="line">    &#123;</span><br><span class="line">        byte* p = AddrOff(buf, i);</span><br><span class="line">        <span class="comment">//缓冲区数据读完了，就需要从硬盘读入文件数据链表的下一个扇区到缓冲区中</span></span><br><span class="line">        <span class="keyword">if</span>( fd-&gt;offset == SECT_SIZE )</span><br><span class="line">        &#123;</span><br><span class="line">            ret = PrepareCache(fd, fd-&gt;objIdx + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ret )</span><br><span class="line">        &#123;   <span class="comment">//从缓冲区读取数据</span></span><br><span class="line">            n = CopyFromCache(fd, p, len - i); <span class="comment">//len-i 还需要读取多少数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">FRead</span><span class="params">(uint fd, byte* buf, uint len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid((FileDesc*)fd) &amp;&amp; buf )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ToRead((FileDesc*)fd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">ToLocate</span><span class="params">(FileDesc* fd, uint pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    uint len = GetFileLen(fd);</span><br><span class="line">    <span class="comment">//计算移动后读写指针的位置，不可超出文件长度</span></span><br><span class="line">    pos = (pos &lt; len) ? pos : len;</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">//计算新位置在哪里</span></span><br><span class="line">        uint objIdx = pos / SECT_SIZE;</span><br><span class="line">        uint offset = pos % SECT_SIZE;</span><br><span class="line">        uint sctIdx = FindIndex(fd-&gt;fe.sctBegin, objIdx);<span class="comment">//文件系统中的位置</span></span><br><span class="line"></span><br><span class="line">        ToFlush(fd);</span><br><span class="line">        <span class="comment">//flush后在读取数据</span></span><br><span class="line">        <span class="keyword">if</span>( (sctIdx != SCT_END_FLAG) &amp;&amp; HDRawRead(sctIdx, fd-&gt;cache) )</span><br><span class="line">        &#123;</span><br><span class="line">            fd-&gt;objIdx = objIdx;</span><br><span class="line">            fd-&gt;offset = offset;</span><br><span class="line"></span><br><span class="line">            ret = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除文件尾部n个字节</span></span><br><span class="line"><span class="function">uint <span class="title">FErase</span><span class="params">(uint fd, uint bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">0</span>;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;</span><br><span class="line">        uint pos = GetFilePos(pf);</span><br><span class="line">        uint len = GetFileLen(pf);</span><br><span class="line"></span><br><span class="line">        ret = EraseLast(&amp;pf-&gt;fe, bytes);</span><br><span class="line"></span><br><span class="line">        len -= ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ret &amp;&amp; (pos &gt; len) )</span><br><span class="line">        &#123;</span><br><span class="line">            ToLocate(pf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动文件指针</span></span><br><span class="line"><span class="function">uint <span class="title">FSeek</span><span class="params">(uint fd, uint pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ToLocate(pf, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件长度</span></span><br><span class="line"><span class="function">uint <span class="title">FLength</span><span class="params">(uint fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = GetFileLen(pf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读写指针位置</span></span><br><span class="line"><span class="function">uint <span class="title">FTell</span><span class="params">(uint fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = GetFilePos(pf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲区数据写入硬盘</span></span><br><span class="line"><span class="function">uint <span class="title">FFlush</span><span class="params">(uint fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint ret = <span class="number">-1</span>;</span><br><span class="line">    FileDesc* pf = (FileDesc*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsFDValid(pf) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ToFlush(pf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">长烟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yunf194.github.io/2022/08/07/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">http://yunf194.github.io/2022/08/07/202287-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yunf194.github.io" target="_blank">fengyun's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/p25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/13/2022813-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="/images/cover/p24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">事件与等待机制</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/23/2022723-%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"><img class="next-cover" src="/images/cover/p17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">键盘驱动设计与shell任务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/23/2022423-BIOS/" title="BIOS"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-23</div><div class="title">BIOS</div></div></a></div><div><a href="/2022/04/23/2022423-%E4%B8%BB%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F/" title="利用FAT12文件系统加载指定程序"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-23</div><div class="title">利用FAT12文件系统加载指定程序</div></div></a></div><div><a href="/2022/05/01/202251-%E7%AA%81%E7%A0%B4512%E5%AD%97%E8%8A%82%E9%99%90%E5%88%B6/" title="MBR加载LOADER"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">MBR加载LOADER</div></div></a></div><div><a href="/2022/05/14/2022514-%E5%B1%80%E9%83%A8%E6%AE%B5%E6%8F%8F%E8%BF%B0%E8%A1%A8/" title="局部段描述表"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">局部段描述表</div></div></a></div><div><a href="/2022/05/15/2022515-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7/" title="保护模式的特权级"><img class="cover" src="/images/cover/os.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-15</div><div class="title">保护模式的特权级</div></div></a></div><div><a href="/2022/05/23/2022523-x86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/" title="x86系统的内存分页"><img class="cover" src="/images/cover/p21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-23</div><div class="title">x86系统的内存分页</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunf194.github.io/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">长烟</div><div class="author-info__description">交际是分享快乐，独处是消化自我</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunf194"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yunf194" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2846327307@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我明白你会来所以我等</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98"><span class="toc-number">1.</span> <span class="toc-text">虚拟硬盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDE"><span class="toc-number">2.</span> <span class="toc-text">IDE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">硬盘控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LBA-Register"><span class="toc-number">2.1.1.</span> <span class="toc-text">LBA Register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Device-Register"><span class="toc-number">2.1.2.</span> <span class="toc-text">Device Register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Command-Register"><span class="toc-number">2.1.3.</span> <span class="toc-text">Command Register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#status-Register"><span class="toc-number">2.1.4.</span> <span class="toc-text">status Register</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99"><span class="toc-number">3.</span> <span class="toc-text">硬盘读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E4%BB%A5%E6%89%87%E5%8C%BA%E4%B8%BA%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%86%99%E5%8D%95%E4%BD%8D"><span class="toc-number">3.1.</span> <span class="toc-text">硬盘以扇区为基本读写单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%AB%AF%E5%8F%A3-0x1F0-%E7%9A%84%E8%AF%BB%E5%86%99%E9%9C%80%E8%A6%81%E4%BB%A5%E5%8F%8C%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%EF%BC%88WORD"><span class="toc-number">3.2.</span> <span class="toc-text">硬盘数据端口 (0x1F0) 的读写需要以双字节为单位（WORD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9D%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.3.</span> <span class="toc-text">逻辑块地址结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">硬盘操作基本步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%87%E5%8C%BA%E6%80%BB%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">获取扇区总数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">文件系统概要设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%87%E5%8C%BA%E5%88%86%E9%85%8D%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">扇区分配表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%8C%BA"><span class="toc-number">4.2.</span> <span class="toc-text">引导区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8C%BA"><span class="toc-number">4.3.</span> <span class="toc-text">根目录区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.</span> <span class="toc-text">硬盘格式化操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">创建文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E6%89%87%E5%8C%BA%E5%8F%B7%E8%8E%B7%E5%8F%96%E5%A4%84%E4%BA%8E%E6%89%87%E5%8C%BA%E5%88%86%E9%85%8D%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">如何根据扇区号获取处于扇区分配表中的位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%87%E5%8C%BA%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">扇区分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%87%E5%8C%BA%E5%BD%92%E8%BF%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">扇区归还函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">辅助功能函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B-%E6%9E%84%E5%BB%BAFileEntry"><span class="toc-number">5.5.</span> <span class="toc-text">创建文件流程-构建FileEntry</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">删除文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">6.1.</span> <span class="toc-text">判断文件是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">删除文件流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text">重命名根目录中的文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">文件打开关闭函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">文件数据写入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">7.4.</span> <span class="toc-text">文件中读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">辅助函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GO的双向tls通信"/></a><div class="content"><a class="title" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信">基于GO的双向tls通信</a><time datetime="2023-01-06T16:00:00.000Z" title="发表于 2023-01-07 00:00:00">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入"/></a><div class="content"><a class="title" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2022-12-06T16:00:00.000Z" title="发表于 2022-12-07 00:00:00">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传漏洞"/></a><div class="content"><a class="title" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞">文件上传漏洞</a><time datetime="2022-12-05T16:00:00.000Z" title="发表于 2022-12-06 00:00:00">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之包"/></a><div class="content"><a class="title" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包">Go语言基础之包</a><time datetime="2022-10-22T16:00:00.000Z" title="发表于 2022-10-23 00:00:00">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之函数"/></a><div class="content"><a class="title" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数">Go语言基础之函数</a><time datetime="2022-10-21T16:00:00.000Z" title="发表于 2022-10-22 00:00:00">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/p25.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 长烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">其实，我回头等了你好久好久，你都没来</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Yb0FJoeuYRJfbYGupEnFsg6E-gzGzoHsz',
      appKey: 'Pjo4dvB3TbjfY8clnS7fxalh',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://yunf194.github.io/css/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://yunf194.github.io/css/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>