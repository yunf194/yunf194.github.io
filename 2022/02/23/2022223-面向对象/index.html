<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面向对象和类 | fengyun's Blog</title><meta name="keywords" content="C++"><meta name="author" content="长烟"><meta name="copyright" content="长烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向对象的基本概念面向对象的意义 将日常生活中习惯的思维方式引入程序设计中 将需求中的概念直观的映射到解决方案中 以模块为中心构建可复用的软件系统 提高软件产品的可维护性和可扩展性  类和对象是面向对象中的两个基本概念 类：指的是一类事物，是一个抽象的概念 对象：指的是属于某个类的具体实体 类是一种模型，这种模型可以创建出不同的对象实体 对象实体是类模型的一个具体实例  一个类可以有多个对象，而一">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象和类">
<meta property="og:url" content="http://yunf194.github.io/2022/02/23/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="fengyun&#39;s Blog">
<meta property="og:description" content="面向对象的基本概念面向对象的意义 将日常生活中习惯的思维方式引入程序设计中 将需求中的概念直观的映射到解决方案中 以模块为中心构建可复用的软件系统 提高软件产品的可维护性和可扩展性  类和对象是面向对象中的两个基本概念 类：指的是一类事物，是一个抽象的概念 对象：指的是属于某个类的具体实体 类是一种模型，这种模型可以创建出不同的对象实体 对象实体是类模型的一个具体实例  一个类可以有多个对象，而一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yunf194.github.io/images/cover/p2.jpg">
<meta property="article:published_time" content="2022-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-17T08:18:57.455Z">
<meta property="article:author" content="长烟">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yunf194.github.io/images/cover/p2.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://yunf194.github.io/2022/02/23/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b5317a4316878223f02ccad7d028fa5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象和类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-17 16:18:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunf194.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/p2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">fengyun's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象和类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-22T16:00:00.000Z" title="发表于 2022-02-23 00:00:00">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-17T08:18:57.455Z" title="更新于 2022-03-17 16:18:57">2022-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象和类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><h3 id="面向对象的意义"><a href="#面向对象的意义" class="headerlink" title="面向对象的意义"></a>面向对象的意义</h3><ul>
<li>将日常生活中习惯的思维方式引入程序设计中</li>
<li>将需求中的概念直观的映射到解决方案中</li>
<li>以模块为中心构建可复用的软件系统</li>
<li>提高软件产品的可维护性和可扩展性</li>
</ul>
<h3 id="类和对象是面向对象中的两个基本概念"><a href="#类和对象是面向对象中的两个基本概念" class="headerlink" title="类和对象是面向对象中的两个基本概念"></a>类和对象是面向对象中的两个基本概念</h3><ul>
<li>类：指的是一类事物，是一个抽象的概念</li>
<li>对象：指的是属于某个类的具体实体</li>
<li>类是一种模型，这种模型可以创建出不同的对象实体</li>
<li>对象实体是类模型的一个具体实例</li>
</ul>
<p>一个类可以有多个对象，而一个对象必然属于某个类</p>
<h3 id="类和对象的意义"><a href="#类和对象的意义" class="headerlink" title="类和对象的意义"></a>类和对象的意义</h3><ul>
<li>类用于抽象的描述一类事务所特有的属性和行为<br>如：电脑拥有CPU，内存和硬盘，并且可以开机和运行程序</li>
<li>对象是具体的事物，拥有所属类中描述的一切属性和行为<br>如：每一只老虎都有不同体重，不同食量等</li>
</ul>
<h3 id="一些有趣问题"><a href="#一些有趣问题" class="headerlink" title="一些有趣问题"></a>一些有趣问题</h3><p>类一定存在实际的对象吗？<br>不一定，比如：恐龙，理论上来看，考古学家通过化石构建出一个恐龙，但是现在并不存在一个真真切切的恐龙</p>
<p>类的对象数目是确定的吗？<br>不一定确定，比如有多少只老虎？</p>
<p>类一定来源于现实生活？<br>不一定，虽然将现实中类的思想移到编程思想中，但一些辅助类需要我们自己抽象构建</p>
<p>类都是独立的吗？类之间存在关系吗？<br>类不是独立的，类之间显然存在关系</p>
<p>对象实例一定只属于一个类？<br>不一定。</p>
<p>对象实例可能完全相同吗？<br>现实中没有两片相同的叶子，程序设计中有吗？</p>
<h3 id="类之间的基本关系"><a href="#类之间的基本关系" class="headerlink" title="类之间的基本关系"></a>类之间的基本关系</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>从已存在类细分出来的类和原类之间具有继承关系(is-a)</li>
<li>继承的类（子类）拥有原类（父类）的所有属性和行为</li>
</ul>
<p>比如华南虎和老虎是继承关系（单向）。<code>华南虎 is a 老虎</code>而不能反过来说<code>老虎 is a 华南虎</code></p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223101553830.png" alt="image-20220223101553830"></p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul>
<li>一些类的存在必须依赖于其它的类，这种关系叫组合</li>
<li>组合的类在某一局部上有其他类组成</li>
</ul>
<p>电脑由CPU，主板，内存，硬盘等，而电脑这个类依赖于CPU类，主板类，内存类，硬盘类等组成</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223101622484.png" alt="image-20220223101622484"></p>
<h5 id="组合关系的特点"><a href="#组合关系的特点" class="headerlink" title="组合关系的特点"></a>组合关系的特点</h5><ul>
<li>- 挎其它类的对象作为当前类的成员使用</li>
<li>- 当前类的对象与成员对象的<strong>生命期相同</strong></li>
<li>- 成员对象在用法上与普通对象完全一致  </li>
</ul>
<h3 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h3><p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223101825929.png" alt="image-20220223101825929"></p>
<p>但是编译器懂这个图吗？我们可以简化成编译器比较能理解的表示法</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223102106606.png" alt="image-20220223102106606"></p>
<p>上面图属性重复定义，我们继续改进</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223102250646.png" alt="image-20220223102250646"></p>
<p>继续改进，使用了大括号</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223102347949.png" alt="image-20220223102347949"></p>
<p>继续改进，我们用<code>struct</code>来代替中文的<code>类</code>。用<code>:</code>来代替中文的<code>继承</code>。</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223102444475.png" alt="image-20220223102444475"></p>
<p>我们继续改进，用<strong>变量描述属性，函数描述行为</strong></p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223102625754.png" alt="image-20220223102625754"></p>
<p>经过多次改进，这样表示不遗漏信息且成功让C++编译器能够读懂。</p>
<h2 id="类与封装"><a href="#类与封装" class="headerlink" title="类与封装"></a>类与封装</h2><p>类通常分为以下两个部分</p>
<ul>
<li>类的使用细节</li>
<li>类的使用方式</li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223103523272.png" alt="image-20220223103523272"></p>
<ul>
<li>当使用类的时候，不需要关心其内部实现细节</li>
<li>当创建类时，才需要考虑其内部实现细节</li>
</ul>
<p>例如<br>普通用户使用手机，只需要学习如何发短信，打电话，拍照，等等等<br>手机开发工程师，需要考虑手机内部的实现细节</p>
<h3 id="封装的基本概念"><a href="#封装的基本概念" class="headerlink" title="封装的基本概念"></a>封装的基本概念</h3><ul>
<li><p>根据经验：并不是类的每个属性都是对外公开的<br>比如：女孩子不希望外人知道自己的体重和年龄<br>比如：男孩子不希望别人知道自己的身高和收入</p>
</li>
<li><p>而一些类的属性时对外公开的<br>比如：人的姓名，学历，国籍等</p>
</li>
<li><p>必须在类的表示法中定义属性和行为的公开级别<br>类似文件系统中文件的权限</p>
</li>
</ul>
<h3 id="C-中类的封装"><a href="#C-中类的封装" class="headerlink" title="C++中类的封装"></a>C++中类的封装</h3><ul>
<li>成员变量：C++中用于表示类属性的变量</li>
<li>成员函数：C++中用于表示类行为的函数</li>
<li>C++中可以给成员变量和成员函数定义访问级别<br>public 成员变量和成员函数可以在类的内部和外界访问和调用<br>private 成员变量和成员函数只能在类的内部被访问和调用</li>
</ul>
<h3 id="类成员的作用域"><a href="#类成员的作用域" class="headerlink" title="类成员的作用域"></a>类成员的作用域</h3><ul>
<li>类成员的作用域都只在类的内部，外部无法直接访问</li>
<li>成员函数可以直接访问成员变量和调用成员函数</li>
<li>类的外部可以通过类变量访问public成员</li>
<li><strong>类成员的作用域与访问级别没有关系</strong></li>
</ul>
<p>C++中用struct定义的类中所有成员默认为public</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>;        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    Test test;</span><br><span class="line">    </span><br><span class="line">    test.j = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);              <span class="comment">// i = 2;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;::i = %d\n&quot;</span>, ::i);          <span class="comment">// ::i = 1;注意::访问默认命名空间（全局作用域）</span></span><br><span class="line">    <span class="comment">// printf(&quot;test.i = %d\n&quot;, test.i);    // Error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.j = %d\n&quot;</span>, test.j);    <span class="comment">// test.j = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.getI() = %d\n&quot;</span>, test.<span class="built_in">getI</span>());  <span class="comment">// test.getI() = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的真正形态"><a href="#类的真正形态" class="headerlink" title="类的真正形态"></a>类的真正形态</h2><p>一个问题：<br>经过不停的改进，结构体struct变得越来越不像它原来在C语言的样子了</p>
<h3 id="类的关键字"><a href="#类的关键字" class="headerlink" title="类的关键字"></a>类的关键字</h3><ul>
<li>struct在C语言中已经有了自己的含义，必须继续兼容</li>
<li>在C++中提供了<strong>新的关键字class</strong>用于类定义</li>
<li>class和struct的<strong>用法是完全相同</strong>的</li>
</ul>
<h3 id="class和struct区别"><a href="#class和struct区别" class="headerlink" title="class和struct区别"></a>class和struct区别</h3><p>在用<strong>struct</strong>定义类是，所有的成员的<strong>默认访问级别为public</strong></p>
<p>在用<strong>class</strong>定义类时，所有成员的<strong>默认访问级别为private</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    </span><br><span class="line">    a.i = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a.getI() = %d\n&quot;</span>, a.<span class="built_in">getI</span>());</span><br><span class="line">    </span><br><span class="line">    b.i = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b.getI() = %d\n&quot;</span>, b.<span class="built_in">getI</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++中的类支持声明和实现的分离</li>
<li>将类的实现和定义分开<br>.h头文件中只有类的声明（成员变量和成员函数的声明）<br>.cpp源文件中完成类的其他实现（成员函数的具体实现）</li>
</ul>
<h2 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a>对象的构造</h2><p>一个问题：对象中成员变量的初始值是多少？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>, gt.<span class="built_in">getI</span>()); <span class="comment">//全局变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>, gt.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    Test t1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>, t1.<span class="built_in">getI</span>()); <span class="comment">//栈上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>, t1.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    Test* pt = <span class="keyword">new</span> Test;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>, pt-&gt;<span class="built_in">getI</span>()); <span class="comment">//堆空间上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>, pt-&gt;<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">gt.i = 0</span><br><span class="line">gt.j = 0</span><br><span class="line">t1.i = 1139214448</span><br><span class="line">t1.j = 32765</span><br><span class="line">pt-&gt;i = 0</span><br><span class="line">pt-&gt;j = 0</span><br></pre></td></tr></table></figure>

<p>类其实是一种数据类型，这种数据类型定义的变量即可在静态变量区，也可以在栈空间，也可以在堆空间。</p>
<p>因此gt.i,gt.j在静态变量区，初始值为0。t1.i,t1.j在栈上初始化为随机值，而pt-&gt;i,pt-&gt;j在堆上随机初始化，这里结果是0只是一个巧合。</p>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>生活中的对象都是在初始化后上市的<br>初始状态是对象普遍存在的一个状态</p>
<p>解决方案：</p>
<ul>
<li>在类中提供一个public的initialize函数</li>
<li>对象创建后立即调用initialize函数进行初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gt.<span class="built_in">initialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>, gt.<span class="built_in">getI</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>, gt.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    Test t1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//t1.initialize();</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>, t1.<span class="built_in">getI</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>, t1.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">initialize</span>();</span><br><span class="line">    </span><br><span class="line">    Test* pt = <span class="keyword">new</span> Test;</span><br><span class="line">    </span><br><span class="line">    pt-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>, pt-&gt;<span class="built_in">getI</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>, pt-&gt;<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>观察我们的代码，initialize()函数是一个普通函数，要求我们自己手工调用，而如果忘记调用或者调用顺序不对，运行结果可能是不对的</p>
<p>因此我有一个大胆的想法：能不能让initialize在对象定义时自动被调用？</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>C++可以定义<strong>与类名相同</strong>的特殊成员函数，这种特殊的成员函数叫做构造函数</p>
<ul>
<li>构造<strong>没有任何返回类型</strong>的声明</li>
<li>构造函数在对象定义时自动被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test() Begin\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test() End\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="带有参数的构造函数"><a href="#带有参数的构造函数" class="headerlink" title="带有参数的构造函数"></a>带有参数的构造函数</h3><ul>
<li>构造函数可以<strong>根据需要定义参数</strong></li>
<li>一个类中可以存在<strong>多个重载的构造函数</strong></li>
<li><strong>构造函数的重载遵循C++重载的规则</strong></li>
</ul>
<p><strong>注意： 对象的定义和对象声明不同</strong></p>
<ul>
<li>对象定义  ： 申请对象的空间并调用构造函数</li>
<li>对象声明  ： 告诉编译器存在这样一个对象</li>
</ul>
<h4 id="构造函数的自动调用"><a href="#构造函数的自动调用" class="headerlink" title="构造函数的自动调用"></a>构造函数的自动调用</h4><p>与重载规则联系起来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test(int v), v = %d\n&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;      <span class="comment">// 调用 Test()</span></span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">// 调用 Test(int v)</span></span><br><span class="line">    Test t2 = <span class="number">2</span>; <span class="comment">// 调用 Test(int v)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意初始化的写法，回想C语言<code>int i = 100;</code>这是初始化，而<code>int i(100);</code>这也是初始化。<br>同样地，<code>Test t2 = 2;</code>也是初始化，<code>Test t2(2)；</code>也是初始化。</p>
<p>但是注意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   Test t;      <span class="comment">// 调用 Test()</span></span><br><span class="line">   Test t2 = <span class="number">2</span>; <span class="comment">// 调用 Test(int v)</span></span><br><span class="line"></span><br><span class="line">t = t2;      <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>

<p>这里<code>t = t2</code>是赋值而不是初始化，初始化是初始化，赋值是赋值，二者不可混为一谈！</p>
<p><strong>初始化与赋值不同</strong></p>
<p>初始化：对正在创建的对象进行初值设置</p>
<p>赋值：对已经存在的对象进行值设置</p>
<h4 id="构造函数的手动调用【特殊情况】"><a href="#构造函数的手动调用【特殊情况】" class="headerlink" title="构造函数的手动调用【特殊情况】"></a>构造函数的手动调用【特殊情况】</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">        m_value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test(int v), v = %d\n&quot;</span>, v);</span><br><span class="line">        m_value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test ta[<span class="number">3</span>] = &#123;<span class="built_in">Test</span>(), <span class="built_in">Test</span>(<span class="number">1</span>), <span class="built_in">Test</span>(<span class="number">2</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ta[%d].getValue() = %d\n&quot;</span>,i,ta[i].<span class="built_in">getValue</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test t = <span class="built_in">Test</span>(<span class="number">100</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.getValue() = %d\n&quot;</span>, t.<span class="built_in">getValue</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">Test()</span><br><span class="line">Test(int v), v = 1</span><br><span class="line">Test(int v), v = 2</span><br><span class="line">ta[0].getValue() = 0</span><br><span class="line">ta[1].getValue() = 1</span><br><span class="line">ta[2].getValue() = 2</span><br><span class="line">Test(int v), v = 100</span><br><span class="line">t.getValue() = 100</span><br></pre></td></tr></table></figure>

<h3 id="特殊的构造函数"><a href="#特殊的构造函数" class="headerlink" title="特殊的构造函数"></a>特殊的构造函数</h3><ul>
<li>无参构造函数 ：没有参数的构造函数<br><strong>当类中没有定义任意的构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空</strong><br>反过来说，假设我们的类中已经定义了构造函数，编译器将不再提供无参构造函数</li>
<li>拷贝构造函数 ：参数为<code>const class_name&amp;</code>的构造函数<br>当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数，简单的进行成员变量的值复制。</li>
</ul>
<p>一道经典面试题：以下这个类有什么东西？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++空类的大小不为0，存在一个无参构造函数等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(const Test&amp; t)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        i = t.i;</span></span><br><span class="line"><span class="comment">        j = t.j;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Test()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2 = t1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d\n&quot;</span>, t1.<span class="built_in">getI</span>(), t1.<span class="built_in">getJ</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d\n&quot;</span>, t2.<span class="built_in">getI</span>(), t2.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序，观察结果如下，可以知道调用了默认的构造函数<code>Test t1</code>和默认的拷贝构造函数<code>Test t2 = t1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o test</span><br><span class="line">fengyun@ubuntu:~/share$ ./test</span><br><span class="line">t1.i = <span class="number">-1661124032</span>, t1.j = <span class="number">21985</span></span><br><span class="line">t2.i = <span class="number">-1661124032</span>, t2.j = <span class="number">21985</span></span><br></pre></td></tr></table></figure>

<p>注意，如果我给上述代码仅仅只提供一个拷贝构造函数，</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223154108556.png" alt="image-20220223154108556"></p>
<p>编译报错，这是因为编译器觉得我们已经给类提供了一个构造函数（拷贝构造函数也是构造函数），编译器就不给我们提供无参构造函数了，因此在代码32行的<code>Test t;</code>这行编译器报错<code>error: no matching function for call to ‘Test::Test()’</code></p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数的意义</p>
<ul>
<li>浅拷贝 ：拷贝后的对象的物理状态相同</li>
<li>深拷贝 ：拷贝后的对象的逻辑状态相同</li>
</ul>
<p>编译器提供的默认拷贝函数仅仅是浅拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Test(const Test&amp; t)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     i = t.i;</span></span><br><span class="line">    <span class="comment">//     j = t.j;</span></span><br><span class="line">    <span class="comment">//     p = new int;</span></span><br><span class="line">    <span class="comment">//     *p = *t.p;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> v)</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        *p = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    Test t2 = t1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d, t1.p = %p\n&quot;</span>, t1.<span class="built_in">getI</span>(), t1.<span class="built_in">getJ</span>(), t1.<span class="built_in">getP</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d, t2.p = %p\n&quot;</span>, t2.<span class="built_in">getI</span>(), t2.<span class="built_in">getJ</span>(), t2.<span class="built_in">getP</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续修改代码，给类对象增加一个int型指针p并且删除拷贝构造函数，创建一个我们写的构造函数</p>
<p>然后打印，可以看到两个对象t1和t2的p指针都指向堆的同一块内存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">t1.i = 1, t1.j = 2, t1.p = 0x5641c9546eb0</span><br><span class="line">t2.i = 1, t2.j = 2, t2.p = 0x5641c9546eb0</span><br></pre></td></tr></table></figure>

<p>但是如果我们在main函数分别用t1,t2两个对象调用成员函数free()释放对应的内存则会造成重复释放同一块内存的严重错误！</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223155328392.png" alt="image-20220223155328392"></p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220223160303269.png" alt="image-20220223160303269"></p>
<p>既然t1初始化的时候指向了堆空间的一块内存，我们t2拷贝构造的时候应该指向堆空间的一块新的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    i = t.i;</span><br><span class="line">    j = t.j;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p = *t.p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在虽然p指针变量存储的地址变量不一样的，但是指向的内存空间存储的值是一样的。</p>
<p>这也就是深拷贝。</p>
<h4 id="什么时候需要进行深拷贝？"><a href="#什么时候需要进行深拷贝？" class="headerlink" title="什么时候需要进行深拷贝？"></a>什么时候需要进行深拷贝？</h4><p>对象中有成员指代了<strong>系统中的资源</strong></p>
<ul>
<li>成员指向了动态内存空间</li>
<li>成员打开来外存中的文件</li>
<li>成员使用了系统中的网络端口</li>
</ul>
<p><strong>一般性原则</strong>  ：<strong>自定义拷贝构造函数，必然要实现深拷贝！！！</strong></p>
<h3 id="初始化列表的使用"><a href="#初始化列表的使用" class="headerlink" title="初始化列表的使用"></a>初始化列表的使用</h3><p>类中是否可以定义const成员？</p>
<p>答案：可以，是一个只读变量。</p>
<p>下面的类定义是否合法？如果合法，ci的值是什么，存储在哪里？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ci;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，类定义合法，但是未对const int ci进行初始化，我们要定义一个构造函数来初始化ci变量，但是ci是一个只读变量不能作为左值，因此我们引出了初始化列表，用初始化列表对ci进行初始化。</p>
<p>C++中提供了初始化列表对成员变量进行初始化</p>
<p>语法规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassName::<span class="built_in">ClassName</span>():<span class="built_in">m1</span>(v1), <span class="built_in">m2</span>(v2), <span class="built_in">m3</span>(v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// some other initialize operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h4><ul>
<li>成员的初始化顺序与成员的声明顺序相同</li>
<li>成员的初始化顺序与初始化列表中的位置无关</li>
<li>初始化列表先于构造函数的函数体执行</li>
</ul>
<p>测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Value</span>(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        mi = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Value m2;</span><br><span class="line">    Value m3;</span><br><span class="line">    Value m1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m1</span>(<span class="number">1</span>), <span class="built_in">m2</span>(<span class="number">2</span>), <span class="built_in">m3</span>(<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test::Test()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test类的三个成员Value类m1,m2,m3应该如何初始化呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Value <span class="title">m2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Value <span class="title">m3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Value <span class="title">m1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先这种方式是不允许的，语法错误。要初始化成员变量只能使用初始化列表。（c++11新特性允许为数据成员提供类内初始值）</p>
<p>改为<code>Test() : m1(1), m2(2), m3(3)</code>接着运行，成功运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">i = 1</span><br><span class="line">Test::Test()</span><br></pre></td></tr></table></figure>

<p>如图所示，可以看到一个特别奇怪的现象：</p>
<ul>
<li>成员的初始化顺序<strong>与初始化列表中的位置无关</strong></li>
<li>成员的初始化顺序<strong>与成员的声明顺序相同</strong></li>
<li><strong>初始化列表先于构造函数的函数体执行</strong></li>
</ul>
<p>这个十分的重要！！！</p>
<h4 id="类中const成员"><a href="#类中const成员" class="headerlink" title="类中const成员"></a>类中const成员</h4><ul>
<li>类中的const成员会被分配空间的</li>
<li>类中的const成员的<strong>本质是只读变量</strong></li>
<li>类中的const成员<strong>只能在初始化列表中指定初始值</strong></li>
</ul>
<h3 id="对象的构造顺序"><a href="#对象的构造顺序" class="headerlink" title="对象的构造顺序"></a>对象的构造顺序</h3><h4 id="局部对象的构造顺序"><a href="#局部对象的构造顺序" class="headerlink" title="局部对象的构造顺序"></a>局部对象的构造顺序</h4><p>C++的类可以定义多个对象，那么对象的构造顺序怎样的</p>
<p>对于局部对象</p>
<p>当程序执行流到达<strong>对象的定义语句</strong>时进行构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Test a1 = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">3</span>)</span><br><span class="line">    Test a2 = ++i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">4</span>)</span><br><span class="line">    Test a = a1;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    Test <span class="built_in">a</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224093834998.png" alt="image-20220224093834998"></p>
<p>可以看到执行顺序非常正常</p>
<p>但是如果增加goto语句可能忽略某些类的构造而未进行初始化，引起灾难性的错误。</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224094541436.png" alt="image-20220224094541436"></p>
<p>幸运的是g++编译器发现了这个错误并且提醒了我们。</p>
<p>但是并不是所有编译器都能发现这个错误，比如vs2010。</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224094709856.png" alt="image-20220224094709856"></p>
<h4 id="堆对象的构造顺序"><a href="#堆对象的构造顺序" class="headerlink" title="堆对象的构造顺序"></a>堆对象的构造顺序</h4><ul>
<li>当程序执行流<strong>到达new语句</strong>时创建对象</li>
<li>使用new创建对象将自动触发构造函数的调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Test* a1 = <span class="keyword">new</span> <span class="built_in">Test</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( ++i &lt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Test</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( i &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Test</span>(*a1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">100</span>);        </span><br></pre></td></tr></table></figure>

<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224095236180.png" alt="image-20220224095236180"></p>
<h4 id="全局对象的构造顺序"><a href="#全局对象的构造顺序" class="headerlink" title="全局对象的构造顺序"></a>全局对象的构造顺序</h4><ul>
<li>全局对象的构造顺序是<strong>不确定的！！！</strong></li>
<li>不同编译器使用不同的规则确定构造顺序</li>
</ul>
<p>在进入main函数之前不存在程序执行流的概念。</p>
<p>这里我创建了四个全局对象分别位于t1.cpp,t2.cpp,t3.cpp,test.cpp内然后运行观察到构造函数执行顺序是t4-&gt;t1-&gt;t2-&gt;t3。</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224095823173.png" alt="image-20220224095823173"></p>
<p>再到windows下的vs2010下执行相同的代码。发现顺序又不一样。</p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224100057049.png" alt="image-20220224100057049"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>局部对象的构造顺序依赖于程序的执行流</li>
<li>堆对象的构造顺序依赖于new的使用顺序</li>
<li>全局对象的构造顺序是不确定的</li>
</ul>
<h3 id="如果构造函数抛出异常？"><a href="#如果构造函数抛出异常？" class="headerlink" title="如果构造函数抛出异常？"></a>如果构造函数抛出异常？</h3><p>构造函数中拋出异常</p>
<ul>
<li>构造过程立即停止</li>
<li>当前对象无法生成</li>
<li>析构函数不会被调用</li>
<li>对象<strong>所占用的空间立即收回（不会内存泄漏）</strong>  </li>
</ul>
<p>工程项目中的建议</p>
<ul>
<li>不要在构造函数中拋出异常</li>
<li>当构造函数可能产生异常时 ， 使用二阶构造模式  </li>
</ul>
<p>避免在析构函数中拋出异常 ！ ！<br>析构函数的异常将导致 ：对象所使用的资源<strong>无法完全释放</strong>。  </p>
<h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>一般而言，需要的销毁的对象都应该做清理</p>
<p>解决方案：</p>
<ul>
<li>为每一个类都提供一个public的free函数</li>
<li>对象不再需要时立即调用free函数进行清理</li>
</ul>
<p>回想如果我们的电脑手机等软件出现问题<br>为什么重启可以解决90%的问题？<br>这是因为软件不稳定造成的，长时间运行出现的不稳定多半是内存泄漏引起的。</p>
<p>存在的问题：</p>
<ul>
<li>free只是一个普通的函数，必须显示的调用</li>
<li>对象销毁前没有做清理，很可能造成资源泄漏</li>
</ul>
<p>那么我们的C++编译器是否能够自动调用某个特殊的函数进行对象的清理？<br>答案是可以的，析构函数。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li><p>C++类中可以定义一个特殊的清理函数<br>这个特殊的清理函数叫做析构函数<br>析构函数的功能与构造函数相反</p>
</li>
<li><p>定义：~ClassName()<br>析构函数<strong>没有参数也没有返回值类型声明</strong>（没有参数自然就无法实现重载）<br>析构函数在对象销毁时<strong>自动被调用</strong></p>
</li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224103905244.png" alt="image-20220224103905244"></p>
<p>注意上述代码中如果忘记释放堆上的内存<code>delete pt;</code>那么将不会执行析构函数</p>
<p><strong>析构函数的定义准则</strong>：<br>当类中自定义了构造函数，并且构造函数中使用了系统资源（如：内存申请，文件打开等），需要自定义析构函数。</p>
<h3 id="析构函数的顺序"><a href="#析构函数的顺序" class="headerlink" title="析构函数的顺序"></a>析构函数的顺序</h3><h4 id="单个对象"><a href="#单个对象" class="headerlink" title="单个对象"></a>单个对象</h4><p>单个对象创建时构造函数的调用顺序</p>
<ol>
<li>调用父类的构造过程</li>
<li>调用<strong>成员变量</strong>的构造函数（如果成员也是类）（成员变量的调用顺序与声明顺序相同）</li>
<li>调用<strong>类自身</strong>的构造函数</li>
</ol>
<p>析构函数与对应构造函数的调用顺序相反</p>
<ol>
<li>调用类自身的析构函数</li>
<li>调用成员变量的析构函数</li>
<li>调用父类的析构过程</li>
</ol>
<h4 id="多个对象"><a href="#多个对象" class="headerlink" title="多个对象"></a>多个对象</h4><p>多个对象析构顺序与构造顺序相反</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ms;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Member(const char* s): %s\n&quot;</span>, s);</span><br><span class="line">        </span><br><span class="line">        ms = s;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Member</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Member(): %s\n&quot;</span>, ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Member mA;</span><br><span class="line">    Member mB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">mB</span>(<span class="string">&quot;mB&quot;</span>), <span class="built_in">mA</span>(<span class="string">&quot;mA&quot;</span>)<span class="comment">//顺序与声明顺序一致，与初始化列表顺序无关，这样写误导人，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Member <span class="title">gA</span><span class="params">(<span class="string">&quot;gA&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">Member(const char* s): gA</span><br><span class="line">Member(const char* s): mA</span><br><span class="line">Member(const char* s): mB</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">~Member(): mB</span><br><span class="line">~Member(): mA</span><br><span class="line">~Member(): gA</span><br></pre></td></tr></table></figure>

<p>关于栈对象和全局对象，类似于入栈和出栈的顺序，最后构造的对象最先析构！！</p>
<p>堆对象的析构发生在使用delete的时候，与delete的使用顺序相关！！</p>
<h2 id="神秘的临时对象"><a href="#神秘的临时对象" class="headerlink" title="神秘的临时对象"></a>神秘的临时对象</h2><p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224104420639.png" alt="image-20220224104420639"></p>
<p>观察这一段程序，作者的程序意图是在main函数中执行<code>Test t;</code>希望t中mi的值被设置为0。</p>
<ul>
<li>在Test()中以0作为参数调用Test(int i)</li>
<li>将成员变量mi的初始值设置为0</li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224104644249.png" alt="image-20220224104644249"></p>
<p>但是执行观察运行结果：成员变量mi的值为随机值。</p>
<p>构造函数是一个特殊的函数</p>
<ul>
<li>是否可以直接调用？</li>
<li>是否可以在构造函数中调用构造函数？</li>
<li>直接调用构造函数的行为是什么？</li>
</ul>
<p>答案：</p>
<ul>
<li><strong>直接调用构造函数将产生一个临时对象</strong></li>
<li>临时对象的<strong>生命周期只有一条语句的时间</strong></li>
<li>临时对象的<strong>作用域只在一条语句中</strong></li>
<li>临时对象是C++中值的警惕的灰色地带</li>
</ul>
<p>因此上面的程序问题在于第10行创建了一个临时对象，因此上述程序的构造函数等价于一个空的构造函数。</p>
<p>那我们如果对代码进行复用操作？</p>
<p>我们可以自己定义一个init函数。在不同的构造函数中调用init函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mi = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">init</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">mi = 0</span><br></pre></td></tr></table></figure>

<p><strong>我们应该在编程里尽力地减少代码中临时对象的产生。</strong><br>C++编译器在不影响最终执行结果地前提下，也会尽力减少临时对象的产生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test(int i) : %d\n&quot;</span>, i);</span><br><span class="line">        mi = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test(const Test&amp; t) : %d\n&quot;</span>, t.mi);</span><br><span class="line">        mi = t.mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">        mi = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">Test</span>(<span class="number">10</span>); <span class="comment">// ==&gt; Test t = 10;</span></span><br><span class="line">    Test tt = <span class="built_in">func</span>();  <span class="comment">// ==&gt; Test tt = Test(20); ==&gt; Test tt = 20;</span></span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">    tt.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>39行<code>Test t = Test(10);</code>理论分析：1.生成临时对象。（调用构造函数）2.用临时对象初始化t对象（调用拷贝构造函数）<br>事实上上述代码等价于直接调用一次构造函数<code>Test t = 10</code>，编译器会进行优化仅调用一次构造函数使得程序的性能得到提升</p>
<p>40行<code>Test tt = func()</code>理论分析：1.生成临时对象并且返回 2.函数结束后销毁临时对象 3.用函数返回的临时对象初始化tt对象（调用拷贝构造函数）。<br>事实上，C++编译器会进行优化，尽量减少临时对象的产生。<code>Test tt = func(); ==&gt; Test tt = Test(20); ==&gt; Test tt = 20;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">Test(int i) : 10</span><br><span class="line">Test(int i) : 20</span><br><span class="line">mi = 10</span><br><span class="line">mi = 20</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br></pre></td></tr></table></figure>

<h2 id="关于类成员的疑问"><a href="#关于类成员的疑问" class="headerlink" title="关于类成员的疑问"></a>关于类成员的疑问</h2><p>问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test::<span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    mi = t.mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么可以访问另一个对象的private成员。</p>
<p>成员函数和成员变量都是隶属于具体对象的吗？</p>
<ul>
<li>从面向对象的角度，对象由属性（成员变量）和方法（成员函数）构成</li>
<li>从程序运行的角度，对象由数据和函数构成<br>数据可以位于栈，堆，和全局数据区<br>函数只能位于代码段（所有对象共享一套成员函数）</li>
</ul>
<p>测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mj;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i);</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    mi = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    mi = t.mi;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test::getMi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this = %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.getMi() = %d\n&quot;</span>, t1.<span class="built_in">getMi</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t1 = %p\n&quot;</span>, &amp;t1);</span><br><span class="line">    t1.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t2.getMi() = %d\n&quot;</span>, t2.<span class="built_in">getMi</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t2 = %p\n&quot;</span>, &amp;t2);</span><br><span class="line">    t2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t3.getMi() = %d\n&quot;</span>, t3.<span class="built_in">getMi</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t3 = %p\n&quot;</span>, &amp;t3);</span><br><span class="line">    t3.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ g++ test.cpp -o <span class="built_in">test</span></span><br><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">t1.getMi() = 1</span><br><span class="line">&amp;t1 = 0x7ffc483ea880</span><br><span class="line">this = 0x7ffc483ea880</span><br><span class="line">t2.getMi() = 2</span><br><span class="line">&amp;t2 = 0x7ffc483ea888</span><br><span class="line">this = 0x7ffc483ea888</span><br><span class="line">t3.getMi() = 3</span><br><span class="line">&amp;t3 = 0x7ffc483ea890</span><br><span class="line">this = 0x7ffc483ea890</span><br></pre></td></tr></table></figure>

<p>结论</p>
<ul>
<li>每一个对象拥有自己独立的属性（成员变量）</li>
<li>所有的对象共享类的方法（成员函数）</li>
<li>方法（成员函数）能够直接访问任何所属类对象的属性（成员变量）</li>
<li>方法中隐藏参数this用于指代当前对象</li>
</ul>
<p>成员函数只有一套，可以访问任何所属类对象的属性。</p>
<h2 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h2><p>回顾类的成员变量属性</p>
<ul>
<li>通过对象名能够访问public 成员变量</li>
<li>每个对象的成员变量都是专属的</li>
<li>成员变量不能在对象之间共享  </li>
</ul>
<p>那么如果有以下的需求：</p>
<ul>
<li>统计在程序运行期间某个类的对象数目</li>
<li>保证程序的安全性（ 不能使用全局变量 ）</li>
<li>随时可以获取当前对象的数目  </li>
</ul>
<p>在 C+ + 中可以定义静态成员变量</p>
<ul>
<li>静态成员变量属于整个类所有</li>
<li>静态成员变量的生命期不依赖于任何对象</li>
<li>可以通过类名直接访问公有静态成员变量</li>
<li>所有对象共享类的静态成员变量</li>
<li>可以通过对象名访问公有静态成员变量  </li>
</ul>
<p>静态成员变量的特性</p>
<ul>
<li>在定义时直接通过 <strong>static</strong> 关键字修饰</li>
<li>静态成员变量需要<strong>在类外单独分配空间</strong></li>
<li>静态成员变量在程序内部位于<strong>全局数据区</strong></li>
</ul>
<p> 语 法 规 则 ：<br><code>Type ClassName::VarName = value;  </code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        --cCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h2><p>继续回顾之前的需求</p>
<ul>
<li>统计在程序运行期间某个类的对象数目【满足】</li>
<li>保证程序的安全性（ 不能使用全局变量 ）【满足】</li>
<li>随时可以获取当前对象的数目（ Failure )  【未满足】</li>
</ul>
<p>我们可以将<code>static int cCount;</code>设为public，但是这样就不安全了</p>
<p>我们需要什么？</p>
<ul>
<li>不依赖对象就可以访问静态成员变量</li>
<li>必须保证静态成员变量的安全性</li>
<li>方便快捷的获取静态成员变量的值  </li>
</ul>
<p>在 C++中可以<strong>定义静态成员函数</strong></p>
<ul>
<li>静态成员函数是类中<strong>特殊的成员函数</strong></li>
<li>静态成员函数<strong>属于整个类所有</strong></li>
<li>可以<strong>通过类名直接访问</strong>公有静态成员函数</li>
<li>可以<strong>通过对象名访问</strong>公有静态成员函数  </li>
</ul>
<p><strong>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</strong></p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224141104629.png" alt="image-20220224141104629"></p>
<p>最终解决方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        --cCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test::cCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>：</p>
<ul>
<li>静态成员函数是类中特殊的成员函数</li>
<li>静态成员函数没有隐藏的 this 参数</li>
<li>静态成员函数可以通过类名直接访问</li>
<li>静态成员函数只能直接访问静态成员变量（ 函数 ）  </li>
</ul>
<h2 id="二阶构造模式"><a href="#二阶构造模式" class="headerlink" title="二阶构造模式"></a>二阶构造模式</h2><p>关于构造函数</p>
<ul>
<li>类的构造函数用于对象的初始化</li>
<li>构造函数与类同名并且没有返回值</li>
<li>构造函数在对象定义时自动被调用  </li>
</ul>
<p>那么引出了如下问题：</p>
<ol>
<li>如何判断构造函数的执行结果？</li>
<li>在构造函数中执行 return 语句会发生什么？</li>
<li>构造函数执行结束是否意味着对象构造成功 ？  </li>
</ol>
<p>答案：</p>
<ol>
<li>无法判断构造函数执行结果</li>
<li>return会直接返回</li>
<li>并不意味对象构造成功</li>
</ol>
<p><strong>构造函数能决定的只是对象的初始状态 ， 而不是对象的诞生 ！ ！</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line">    <span class="keyword">int</span> mj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        mi = i;        </span><br><span class="line">        <span class="keyword">return</span>;        </span><br><span class="line">        mj = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.mi = %d\n&quot;</span>, t1.<span class="built_in">getI</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t1.mj = %d\n&quot;</span>, t1.<span class="built_in">getJ</span>());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，构造函数中有return语句并且提前返回，我们运行结果如下：对象的初始化并不成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share$ ./<span class="built_in">test</span></span><br><span class="line">t1.mi = 1</span><br><span class="line">t1.mj = -1096823344</span><br></pre></td></tr></table></figure>

<p>我们可以自己手动保存一个status变量，若构造函数执行成功，status置为true</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line">    <span class="keyword">int</span> mj;</span><br><span class="line">    <span class="keyword">bool</span> mStatus;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : <span class="built_in">mStatus</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mi = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        mj = j;</span><br><span class="line">        </span><br><span class="line">        mStatus = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">status</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( t1.<span class="built_in">status</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t1.mi = %d\n&quot;</span>, t1.<span class="built_in">getI</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t1.mj = %d\n&quot;</span>, t1.<span class="built_in">getJ</span>());</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种解决方法仍然不够优美。</p>
<h3 id="半成品对象的概念"><a href="#半成品对象的概念" class="headerlink" title="半成品对象的概念"></a>半成品对象的概念</h3><ul>
<li>初始化操作不能按照预期完成而得到的对象</li>
<li>半成品对象是合法的 C+ + 对象 ， 也是 Bug 的主要来源  </li>
</ul>
<h3 id="二阶构造"><a href="#二阶构造" class="headerlink" title="二阶构造"></a>二阶构造</h3><p>工程开发中的构造过程可分为</p>
<ul>
<li>资源无关的初始化操作<br>不可能出现异常情况的操作</li>
<li>需要使用系统资源的操作<br>可能出现异常情况 ， 如 ： 内存申请 ， 访问文件  </li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224143921170.png" alt="image-20220224143921170"></p>
<p>二阶构造实例一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseCons</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TwoPhaseCons</span>()&#123;  <span class="comment">// 第一阶段构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span> </span>&#123; <span class="comment">// 第二阶段构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> TwoPhaseCons* <span class="title">NewInstance</span><span class="params">()</span></span>; <span class="comment">// 对象创建函数</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function">TwoPhaseCons* <span class="title">TwoPhaseCons::NewInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TwoPhaseCons* ret = <span class="keyword">new</span> <span class="built_in">TwoPhaseCon</span>();<span class="comment">//创建一个对象，执行第一阶段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若第二阶段构造失败,返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!(ret &amp;&amp; ret-&gt;<span class="built_in">construct</span>()))&#123;</span><br><span class="line">        <span class="keyword">delete</span> ret;</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意13行<code>TwoPhaseCons* ret = new TwoPhaseCon();</code>，注意有个错误的说法：静态成员函数只可以访问静态成员变量/静态成员函数不能访问非静态成员。</p>
<p>静态函数没有默认的this对象指针。但是可以通过其他方式传入对象的地址，便可以在静态成员函数中访问到非静态成员函数。这种说法不够严密。仅仅是<strong>不能在静态成员函数中，使用this隐式或者显式调用非静态成员。</strong>因为静态函数不与对象绑定在一起，因此也不能声明成const的。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li> 构造函数只能决定对象的初始化状态</li>
<li> 构造函数中初始化操作的失败不影响对象的诞生</li>
<li> 初始化不完全的半成品对象是 Bug 的重要来源</li>
<li> 二阶构造人为的将初始化过程分为两部分</li>
<li> 二阶构造能够确保创建的对象都是完整初始化的  </li>
</ul>
<h2 id="友元的尴尬能力"><a href="#友元的尴尬能力" class="headerlink" title="友元的尴尬能力"></a>友元的尴尬能力</h2><h3 id="友元的概念"><a href="#友元的概念" class="headerlink" title="友元的概念"></a>友元的概念</h3><ul>
<li>友元是 C++ 中的一种关系</li>
<li>友元关系发生在<strong>函数与类之间</strong>或者<strong>类与类之间</strong></li>
<li>友元关系是单向的 ，不能传递  </li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224155912209.png" alt="image-20220224155912209"></p>
<h3 id="友元的用法"><a href="#友元的用法" class="headerlink" title="友元的用法"></a>友元的用法</h3><ul>
<li>在类中以 friend 关键字声明友元</li>
<li>类的友元可以是其它类或者具体函数</li>
<li>友元<strong>不是类的一部分</strong></li>
<li>友元<strong>不受类中访问级别的限制</strong></li>
<li>友元可以直接访问具体<strong>类的所有成员</strong>  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//friend double func(Point&amp; p1, Point&amp; p2);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(Point&amp; p1, Point&amp; p2)</span><span class="comment">//拥有友元的超能力</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret = (p2.y - p1.y) * (p2.y - p1.y) +</span><br><span class="line">          (p2.x - p1.x) * (p2.x - p1.x);</span><br><span class="line">          </span><br><span class="line">    ret = <span class="built_in">sqrt</span>(ret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意29行<code>ret = (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);</code>我们C语言原先就是这样写的，<br>但是C++对对象的封装导致若要访问x，y必须调用getX(),getY()。<br>这么一个简单的语句要调用8次函数为人们所吐槽，因此C++设计者门为了兼容C语言而设计出了友元。</p>
<h3 id="友元的尴尬"><a href="#友元的尴尬" class="headerlink" title="友元的尴尬"></a>友元的尴尬</h3><ul>
<li>友元是为了<strong>兼顾 C 语言的高效</strong>而诞生的</li>
<li>友元<strong>直接破坏</strong>了面向对象的封装性（C++开发变为了C语言开发）</li>
<li>友元在实际产品中的高效是得不偿失的</li>
<li>友元在现代软件工程中已经逐渐被遗弃</li>
</ul>
<p>Java，csharp诞生于C++，但是都没有友元这个能力，因此C++开发尽量减少友元的使用。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>友元关系<strong>不具备传递性</strong></li>
<li>类的友元可以是其它类的成员函数</li>
<li>类的友元可以是某个完整的类 —所有的成员函数都是友元  </li>
</ul>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224161843649.png" alt="image-20220224161843649"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>友元是为了兼顾 c 语言的高效而诞生的</li>
<li>友元直接破坏了面向对象的封装性</li>
<li>友元关系不具备传递性</li>
<li>类的友元可以是其它类的成员函数</li>
<li>类的友元可以是某个完整的类  </li>
</ul>
<h2 id="类中的函数重载"><a href="#类中的函数重载" class="headerlink" title="类中的函数重载"></a>类中的函数重载</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul>
<li>函数重载的本质为相互独立的不同函数</li>
<li>C+ + 中通过函数名和函数参数确定函数调用</li>
<li>无法直接通过函数名得到重载函数的入口地址</li>
<li>函数重载必然发生在同一作用域中  </li>
</ul>
<h3 id="类中的成员函数可以进行重载"><a href="#类中的成员函数可以进行重载" class="headerlink" title="类中的成员函数可以进行重载"></a>类中的成员函数可以进行重载</h3><ul>
<li>构造函数的重载</li>
<li>普通成员函数的重载</li>
<li>静态成员函数的重载  </li>
</ul>
<h3 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h3><ul>
<li>重载函数的<strong>本质为多个不同的函数</strong></li>
<li><strong>函数名和参数列表</strong>是<strong>唯一的标识</strong>（和有没有static关键字无关）</li>
<li>函数重载<strong>必须发生在同一作用域中</strong></li>
</ul>
<h3 id="重载的意义"><a href="#重载的意义" class="headerlink" title="重载的意义"></a>重载的意义</h3><ul>
<li>通过函数名对函数功能进行提示</li>
<li>通过参数列表对函数用法进行提示</li>
<li>扩展系统中已经存在的函数功能  </li>
</ul>
<p>扩展系统函数strcpy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncpy</span>(buf, str, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;D.T.Software&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//strcpy(buf, s);</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, s, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载能够扩展系统中已经存在的函数功能 ！</p>
<p>那么重载是否也能够扩展其它更多的功能 ？  </p>
<p><img src="/../images/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220224164943231.png" alt="image-20220224164943231"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Complex <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex ret;</span><br><span class="line">    </span><br><span class="line">    ret.a = p1.a + p2.a;</span><br><span class="line">    ret.b = p1.b + p2.b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c3 = <span class="built_in">Add</span>(c1, c2); <span class="comment">// c1 + c2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c3.a = %d, c3.b = %d\n&quot;</span>, c3.<span class="built_in">getA</span>(), c3.<span class="built_in">getB</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><ul>
<li>C++ 中的重载能够扩展操作符的功能</li>
<li>操作符的重载以函数的方式进行</li>
<li>本 质 ： 用特殊形式的函数扩展操作符的功能  </li>
<li>通过 operator 关键字可以定义特殊的函数</li>
<li>operator 的本质是通过函数重载操作符  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Type <span class="keyword">operator</span> <span class="title">Sign</span><span class="params">(<span class="keyword">const</span> Type pi, <span class="keyword">const</span> Type p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Type ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Sign为系统中预定义的操作符,如 + - * / 等</span></span><br></pre></td></tr></table></figure>

<p>因此只需简单的修改上述的代码，就可以实现重载操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//修改为</span></span></span><br><span class="line"><span class="function">Complex <span class="keyword">operator</span> + <span class="params">(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex c3 = <span class="built_in">Add</span>(c1, c2);</span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line">Complex c3 = <span class="keyword">operator</span> + (c1, c2);</span><br><span class="line"><span class="comment">//继续修改为</span></span><br><span class="line">Complex c3 = c1 + c2;</span><br></pre></td></tr></table></figure>

<p>我们上述修改依然是基于友元的方法，那么如何不依赖友元重载操作符？</p>
<p><strong>可以将操作符重载函数定义为类的成员函数</strong>，差别如下：</p>
<ul>
<li><strong>比全局操作符重载函数少一个参数</strong>（左操作数）</li>
<li><strong>不需要依赖友元</strong>就可以完成操作符重载</li>
<li>编译器<strong>优先在成员函数中寻找</strong>操作符重载函数  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Type <span class="keyword">operator</span> <span class="title">Sign</span><span class="params">(<span class="keyword">const</span> Type&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Type ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex ret;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Complex operator + (const Complex&amp; p)\n&quot;</span>);</span><br><span class="line">        ret.a = <span class="keyword">this</span>-&gt;a + p.a;</span><br><span class="line">        ret.b = <span class="keyword">this</span>-&gt;b + p.b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">    Complex ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Complex operator + (const Complex&amp; p1, const Complex&amp; p2)\n&quot;</span>);</span><br><span class="line">    ret.a = p1.a + p2.a;</span><br><span class="line">    ret.b = p1.b + p2.b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2; <span class="comment">// c1.operator + (c2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c3.a = %d, c3.b = %d\n&quot;</span>, c3.<span class="built_in">getA</span>(), c3.<span class="built_in">getB</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>操作符重载是 C+ + 的强大特性之一</li>
<li>操作符重载的<strong>本质是通过函数扩展操作符的功能</strong></li>
<li>operator 关键字是实现操作符重载的关键</li>
<li>操作符重载遵循<strong>相同的</strong>函数重载规则</li>
<li>全局函数和成员函数都可以实现对操作符的重载  </li>
</ul>
<p>注意事项：</p>
<ul>
<li>C+ + 规定赋值操作符（ = )只能重载为成员函数</li>
<li>操作符重载不能改变原操作符的<strong>优先级</strong></li>
<li>操作符重载不能改变操作数的个数</li>
<li>操作符重载不应改变操作符的原有语义  </li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">长烟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yunf194.github.io/2022/02/23/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">http://yunf194.github.io/2022/02/23/2022223-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yunf194.github.io" target="_blank">fengyun's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/p2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/25/2022225-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><img class="prev-cover" src="/images/cover/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智能指针</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/22/2022222-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><img class="next-cover" src="/images/cover/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">动态内存分配</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/20/2022220-const%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="const深度解析"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">const深度解析</div></div></a></div><div><a href="/2022/02/20/2022220-bool%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/" title="bool类型和引用"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">bool类型和引用</div></div></a></div><div><a href="/2022/02/20/2022220-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/" title="编译链接"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">编译链接</div></div></a></div><div><a href="/2022/02/21/2022221-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/" title="程序内存详解"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">程序内存详解</div></div></a></div><div><a href="/2022/02/22/2022222-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" title="动态内存分配"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">动态内存分配</div></div></a></div><div><a href="/2022/02/21/2022221-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" title="函数深度分析"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">函数深度分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunf194.github.io/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">长烟</div><div class="author-info__description">交际是分享快乐，独处是消化自我</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunf194"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yunf194" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2846327307@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我明白你会来所以我等</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">面向对象的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">类和对象是面向对象中的两个基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.3.</span> <span class="toc-text">类和对象的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">一些有趣问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">类之间的基本关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">组合关系的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">类的表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">类与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">封装的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">C++中类的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">类成员的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%BD%A2%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">类的真正形态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">类的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E5%92%8Cstruct%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">class和struct区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">4.</span> <span class="toc-text">对象的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">对象的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">带有参数的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">构造函数的自动调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8%E3%80%90%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E3%80%91"><span class="toc-number">4.3.2.</span> <span class="toc-text">构造函数的手动调用【特殊情况】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">特殊的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">什么时候需要进行深拷贝？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">初始化列表的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.6.1.</span> <span class="toc-text">成员初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%ADconst%E6%88%90%E5%91%98"><span class="toc-number">4.6.2.</span> <span class="toc-text">类中const成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.7.</span> <span class="toc-text">对象的构造顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.7.1.</span> <span class="toc-text">局部对象的构造顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.7.2.</span> <span class="toc-text">堆对象的构造顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.7.3.</span> <span class="toc-text">全局对象的构造顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.7.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">如果构造函数抛出异常？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.</span> <span class="toc-text">对象的销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">析构函数的顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.1.</span> <span class="toc-text">单个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.2.</span> <span class="toc-text">多个对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A5%9E%E7%A7%98%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">神秘的临时对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%96%91%E9%97%AE"><span class="toc-number">7.</span> <span class="toc-text">关于类成员的疑问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">类的静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">类的静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">二阶构造模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E6%88%90%E5%93%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">半成品对象的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%9E%84%E9%80%A0"><span class="toc-number">10.2.</span> <span class="toc-text">二阶构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">10.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E5%B0%B4%E5%B0%AC%E8%83%BD%E5%8A%9B"><span class="toc-number">11.</span> <span class="toc-text">友元的尴尬能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">友元的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">友元的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E5%B0%B4%E5%B0%AC"><span class="toc-number">11.3.</span> <span class="toc-text">友元的尴尬</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">11.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">12.</span> <span class="toc-text">类中的函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">12.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">12.2.</span> <span class="toc-text">类中的成员函数可以进行重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E5%8F%98%E4%B8%8D%E7%A6%BB%E5%85%B6%E5%AE%97"><span class="toc-number">12.3.</span> <span class="toc-text">万变不离其宗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">12.4.</span> <span class="toc-text">重载的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">13.</span> <span class="toc-text">操作符重载</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GO的双向tls通信"/></a><div class="content"><a class="title" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信">基于GO的双向tls通信</a><time datetime="2023-01-06T16:00:00.000Z" title="发表于 2023-01-07 00:00:00">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入"/></a><div class="content"><a class="title" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2022-12-06T16:00:00.000Z" title="发表于 2022-12-07 00:00:00">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传漏洞"/></a><div class="content"><a class="title" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞">文件上传漏洞</a><time datetime="2022-12-05T16:00:00.000Z" title="发表于 2022-12-06 00:00:00">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之包"/></a><div class="content"><a class="title" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包">Go语言基础之包</a><time datetime="2022-10-22T16:00:00.000Z" title="发表于 2022-10-23 00:00:00">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之函数"/></a><div class="content"><a class="title" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数">Go语言基础之函数</a><time datetime="2022-10-21T16:00:00.000Z" title="发表于 2022-10-22 00:00:00">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/p2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 长烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">其实，我回头等了你好久好久，你都没来</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Yb0FJoeuYRJfbYGupEnFsg6E-gzGzoHsz',
      appKey: 'Pjo4dvB3TbjfY8clnS7fxalh',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://yunf194.github.io/css/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://yunf194.github.io/css/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>