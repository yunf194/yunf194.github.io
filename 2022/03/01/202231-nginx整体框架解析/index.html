<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>nginx整体框架解析 | fengyun's Blog</title><meta name="keywords" content="nginx"><meta name="author" content="长烟"><meta name="copyright" content="长烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础架构设计 master 负责管理 worker 进程，worker 进程负责处理网络事件。整个框架被设计为一种依赖事件驱动、异步、非阻塞的模式。 如此设计的优点：  1.可以充分利用多核机器，增强并发处理能力。 2.多 worker 间可以实现负载均衡。 3.Master 监控并统一管理 worker 行为。在 worker 异常后，可以主动拉起 worker 进程，从而提升了系统的可靠性。并">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx整体框架解析">
<meta property="og:url" content="http://yunf194.github.io/2022/03/01/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="fengyun&#39;s Blog">
<meta property="og:description" content="基础架构设计 master 负责管理 worker 进程，worker 进程负责处理网络事件。整个框架被设计为一种依赖事件驱动、异步、非阻塞的模式。 如此设计的优点：  1.可以充分利用多核机器，增强并发处理能力。 2.多 worker 间可以实现负载均衡。 3.Master 监控并统一管理 worker 行为。在 worker 异常后，可以主动拉起 worker 进程，从而提升了系统的可靠性。并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yunf194.github.io/images/cover/nginx.jpg">
<meta property="article:published_time" content="2022-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-26T03:46:34.704Z">
<meta property="article:author" content="长烟">
<meta property="article:tag" content="nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yunf194.github.io/images/cover/nginx.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://yunf194.github.io/2022/03/01/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b5317a4316878223f02ccad7d028fa5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nginx整体框架解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-26 11:46:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunf194.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/nginx.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">fengyun's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nginx整体框架解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-28T16:00:00.000Z" title="发表于 2022-03-01 00:00:00">2022-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-26T03:46:34.704Z" title="更新于 2022-04-26 11:46:34">2022-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/webserver/">webserver</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>136分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nginx整体框架解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>基础架构设计</p>
<p>master 负责管理 worker 进程，worker 进程负责处理网络事件。整个框架被设计为一种依赖事件驱动、异步、非阻塞的模式。</p>
<p>如此设计的优点：</p>
<ul>
<li>1.可以充分利用多核机器，增强并发处理能力。</li>
<li>2.多 worker 间可以实现负载均衡。</li>
<li>3.Master 监控并统一管理 worker 行为。在 worker 异常后，可以主动拉起 worker 进程，从而提升了系统的可靠性。并且由 Master 进程控制服务运行中的程序升级、配置项修改等操作，从而增强了整体的动态可扩展与热更的能力。</li>
</ul>
<p><strong>目录树</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/nginx$ tree</span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   ├── nginx.cxx</span><br><span class="line">│   ├── ngx_c_conf.cxx</span><br><span class="line">│   ├── ngx_log.cxx</span><br><span class="line">│   ├── ngx_printf.cxx</span><br><span class="line">│   ├── ngx_setproctitle.cxx</span><br><span class="line">│   └── ngx_string.cxx</span><br><span class="line">├── common.mk</span><br><span class="line">├── config.mk</span><br><span class="line">├── error.log</span><br><span class="line">├── _include</span><br><span class="line">│   ├── ngx_c_conf.h</span><br><span class="line">│   ├── ngx_c_crc32.h</span><br><span class="line">│   ├── ngx_c_lockmutex.h</span><br><span class="line">│   ├── ngx_c_memory.h</span><br><span class="line">│   ├── ngx_comm.h</span><br><span class="line">│   ├── ngx_c_slogic.h</span><br><span class="line">│   ├── ngx_c_socket.h</span><br><span class="line">│   ├── ngx_c_threadpool.h</span><br><span class="line">│   ├── ngx_func.h</span><br><span class="line">│   ├── ngx_global.h</span><br><span class="line">│   ├── ngx_logiccomm.h</span><br><span class="line">│   └── ngx_macro.h</span><br><span class="line">├── logic</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   └── ngx_c_slogic.cxx</span><br><span class="line">├── logs</span><br><span class="line">├── makefile</span><br><span class="line">├── misc</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   ├── ngx_c_crc32.cxx</span><br><span class="line">│   ├── ngx_c_memory.cxx</span><br><span class="line">│   └── ngx_c_threadpool.cxx</span><br><span class="line">├── net</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   ├── ngx_c_socket_accept.cxx</span><br><span class="line">│   ├── ngx_c_socket_conn.cxx</span><br><span class="line">│   ├── ngx_c_socket.cxx</span><br><span class="line">│   ├── ngx_c_socket_inet.cxx</span><br><span class="line">│   ├── ngx_c_socket_request.cxx</span><br><span class="line">│   └── ngx_c_socket_time.cxx</span><br><span class="line">├── nginx.conf</span><br><span class="line">├── proc</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   ├── ngx_daemon.cxx</span><br><span class="line">│   ├── ngx_event.cxx</span><br><span class="line">│   └── ngx_process_cycle.cxx</span><br><span class="line">└── signal</span><br><span class="line">    ├── makefile</span><br><span class="line">    └── ngx_signal.cxx</span><br><span class="line"></span><br><span class="line">8 directories, 43 files</span><br></pre></td></tr></table></figure>

<h2 id="main函数程序入口函数"><a href="#main函数程序入口函数" class="headerlink" title="main函数程序入口函数"></a>main函数程序入口函数</h2><ol>
<li>一些全局变量的初始化包括读取配置文件（详见本文6.1读取配置文件）</li>
<li>单例类的初始化，包括CRC32校验类，专门分配内存和释放内存的类</li>
<li>日志初始化（详见<a href="https://yunf194.github.io/2022/01/29/2022129-%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/">日志功能</a>）</li>
<li>信号初始化（详见<a href="https://yunf194.github.io/2022/02/07/202226-%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD/">信号功能详解</a>）</li>
<li>环境变量搬家（详见本文6.2.1ngx_init_setproctitle）</li>
<li>创建守护进程ngx_daemon（详见<a href="https://yunf194.github.io/2022/01/25/2022125-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">守护进程</a>），最终以守护进程的形式运行着</li>
<li>进入正式的工作流程死循环ngx_master_process_cycle();</li>
<li>释放资源，虽然一般走不到这里，但是万一以后有需求呢？比较优雅的释放的方式</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序主入口函数----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">//printf(&quot;%u,%u,%u&quot;,EPOLLERR ,EPOLLHUP,EPOLLRDHUP);  </span></span><br><span class="line">    <span class="comment">//exit(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> exitcode = <span class="number">0</span>;           <span class="comment">//退出代码，先给0表示正常退出</span></span><br><span class="line">    <span class="keyword">int</span> i;                      <span class="comment">//临时用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(0)先初始化的变量</span></span><br><span class="line">    g_stopEvent = <span class="number">0</span>;            <span class="comment">//标记程序是否退出，0不退出          </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)无伤大雅也不需要释放的放最上边    </span></span><br><span class="line">    ngx_pid    = <span class="built_in">getpid</span>();      <span class="comment">//取得进程pid</span></span><br><span class="line">    ngx_parent = <span class="built_in">getppid</span>();     <span class="comment">//取得父进程的id </span></span><br><span class="line">    <span class="comment">//统计argv所占的内存</span></span><br><span class="line">    g_argvneedmem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++)  <span class="comment">//argv =  ./nginx -a -b -c asdfas</span></span><br><span class="line">    &#123;</span><br><span class="line">        g_argvneedmem += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>; <span class="comment">//+1是给\0留空间。</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//统计环境变量所占的内存。注意判断方法是environ[i]是否为空作为环境变量结束标记</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; environ[i]; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        g_envneedmem += <span class="built_in">strlen</span>(environ[i]) + <span class="number">1</span>; <span class="comment">//+1是因为末尾有\0,是占实际内存位置的，要算进来</span></span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line"></span><br><span class="line">    g_os_argc = argc;           <span class="comment">//保存参数个数</span></span><br><span class="line">    g_os_argv = (<span class="keyword">char</span> **) argv; <span class="comment">//保存参数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局量有必要初始化的</span></span><br><span class="line">    ngx_log.fd = <span class="number">-1</span>;                  <span class="comment">//-1：表示日志文件尚未打开；因为后边ngx_log_stderr要用所以这里先给-1</span></span><br><span class="line">    ngx_process = NGX_PROCESS_MASTER; <span class="comment">//先标记本进程是master进程</span></span><br><span class="line">    ngx_reap = <span class="number">0</span>;                     <span class="comment">//标记子进程没有发生变化</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//(2)初始化失败，就要直接退出的</span></span><br><span class="line">    <span class="comment">//配置文件必须最先要，后边初始化啥的都用，所以先把配置读出来，供后续使用 </span></span><br><span class="line">    CConfig *p_config = CConfig::<span class="built_in">GetInstance</span>(); <span class="comment">//单例类</span></span><br><span class="line">    <span class="keyword">if</span>(p_config-&gt;<span class="built_in">Load</span>(<span class="string">&quot;nginx.conf&quot;</span>) == <span class="literal">false</span>) <span class="comment">//把配置文件内容载入到内存            </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">ngx_log_init</span>();    <span class="comment">//初始化日志</span></span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;配置文件[%s]载入失败，退出!&quot;</span>,<span class="string">&quot;nginx.conf&quot;</span>);</span><br><span class="line">        <span class="comment">//exit(1);终止进程，在main中出现和return效果一样 ,exit(0)表示程序正常, exit(1)/exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件</span></span><br><span class="line">        exitcode = <span class="number">2</span>; <span class="comment">//标记找不到文件</span></span><br><span class="line">        <span class="keyword">goto</span> lblexit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2.1)内存单例类可以在这里初始化，返回值不用保存</span></span><br><span class="line">    CMemory::<span class="built_in">GetInstance</span>();	</span><br><span class="line">    <span class="comment">//(2.2)crc32校验算法单例类可以在这里初始化，返回值不用保存</span></span><br><span class="line">    CCRC32::<span class="built_in">GetInstance</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//(3)一些必须事先准备好的资源，先初始化</span></span><br><span class="line">    <span class="built_in">ngx_log_init</span>();             <span class="comment">//日志初始化(创建/打开日志文件)，这个需要配置项，所以必须放配置文件载入的后边；     </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//(4)一些初始化函数，准备放这里        </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ngx_init_signals</span>() != <span class="number">0</span>) <span class="comment">//信号初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        exitcode = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> lblexit;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(g_socket.<span class="built_in">Initialize</span>() == <span class="literal">false</span>)<span class="comment">//初始化socket,bind(),listen()</span></span><br><span class="line">    &#123;</span><br><span class="line">        exitcode = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> lblexit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5)一些不好归类的其他类别的代码，准备放这里</span></span><br><span class="line">    <span class="built_in">ngx_init_setproctitle</span>();    <span class="comment">//把环境变量搬家</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line">    <span class="comment">//(6)创建守护进程</span></span><br><span class="line">    <span class="keyword">if</span>(p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;Daemon&quot;</span>,<span class="number">0</span>) == <span class="number">1</span>) <span class="comment">//读配置文件，拿到配置文件中是否按守护进程方式启动的选项</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1：按守护进程方式运行</span></span><br><span class="line">        <span class="keyword">int</span> cdaemonresult = <span class="built_in">ngx_daemon</span>();</span><br><span class="line">        <span class="keyword">if</span>(cdaemonresult == <span class="number">-1</span>) <span class="comment">//fork()失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            exitcode = <span class="number">1</span>;    <span class="comment">//标记失败</span></span><br><span class="line">            <span class="keyword">goto</span> lblexit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cdaemonresult == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这是原始的父进程</span></span><br><span class="line">            <span class="built_in">freeresource</span>();   <span class="comment">//只有进程退出了才goto到 lblexit，用于提醒用户进程退出了</span></span><br><span class="line">                              <span class="comment">//而我现在这个情况属于正常fork()守护进程后的正常退出，不应该跑到lblexit()去执行，因为那里有一条打印语句标记整个进程的退出，这里不该限制该条打印语句；</span></span><br><span class="line">            exitcode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> exitcode;  <span class="comment">//整个进程直接在这里退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里，成功创建了守护进程并且这里已经是fork()出来的进程，现在这个进程做了master进程</span></span><br><span class="line">        g_daemonized = <span class="number">1</span>;    <span class="comment">//守护进程标记，标记是否启用了守护进程模式，0：未启用，1：启用了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(7)开始正式的主工作流程，主流程一致在下边这个函数里循环，暂时不会走下来，资源释放啥的日后再慢慢完善和考虑    </span></span><br><span class="line">    <span class="built_in">ngx_master_process_cycle</span>(); <span class="comment">//不管父进程还是子进程，正常工作期间都在这个函数里循环；</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//--------------------------------------------------------------    </span></span><br><span class="line">    <span class="comment">//for(;;)    </span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    sleep(1); //休息1秒        </span></span><br><span class="line">    <span class="comment">//    printf(&quot;休息1秒\n&quot;);        </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//--------------------------------------</span></span><br><span class="line">lblexit:</span><br><span class="line">    <span class="comment">//(5)该释放的资源要释放掉</span></span><br><span class="line">    <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;程序退出，再见了!&quot;</span>);</span><br><span class="line">    <span class="built_in">freeresource</span>();  <span class="comment">//一系列的main返回前的释放动作函数</span></span><br><span class="line">    <span class="comment">//printf(&quot;程序退出，再见!\n&quot;);    </span></span><br><span class="line">    <span class="keyword">return</span> exitcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="master进程工作"><a href="#master进程工作" class="headerlink" title="master进程工作"></a>master进程工作</h2><h3 id="ngx-master-process-cycle（master进程）"><a href="#ngx-master-process-cycle（master进程）" class="headerlink" title="ngx_master_process_cycle（master进程）"></a>ngx_master_process_cycle（master进程）</h3><ol>
<li>信号集初始化并且调用sigaddset防止10个信号的干扰</li>
<li>当master把该做的事情（设置主进程标题ngx_setproctitle和创建子进程ngx_start_worker_processes）做完了就会进入一个<strong>死循环for</strong></li>
<li>for里面调用<code>sigsuspend(&amp;set);</code>进程是挂起的，<strong>不占用cpu时间</strong>，<strong>只有收到信号才会被唤醒</strong>，主进程只依靠信号来驱动</li>
</ol>
<p>sigsuspend是一个<strong>原子操作</strong>，包含4个步骤：</p>
<ol>
<li>根据给定的参数设置新的mask 并 <strong>阻塞当前进程</strong>【因为是个空集，所以不阻塞任何信号】</li>
<li>此时，<strong>一旦收到信号，便恢复原先的信号屏蔽</strong>【我们原来调用sigprocmask()的mask在上边设置的，阻塞了多达10个信号，从而保证我下边的执行流程不会再次被其他信号截断】</li>
<li>调用该信号对应的<strong>信号处理函数</strong></li>
<li>信号处理函数返回后，sigsuspend返回，<strong>使程序流程继续往下走</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//描述：创建worker子进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_master_process_cycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">sigset_t</span> set;        <span class="comment">//信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);   <span class="comment">//清空信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下列这些信号在执行本函数期间不希望收到【考虑到官方nginx中有这些信号，就都搬过来了】（保护不希望由信号中断的代码临界区）</span></span><br><span class="line">    <span class="comment">//建议fork()子进程时学习这种写法，防止信号的干扰；</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGCHLD);     <span class="comment">//子进程状态改变</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGALRM);     <span class="comment">//定时器超时</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGIO);       <span class="comment">//异步I/O</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGINT);      <span class="comment">//终端中断符</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGHUP);      <span class="comment">//连接断开</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR1);     <span class="comment">//用户定义信号</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR2);     <span class="comment">//用户定义信号</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGWINCH);    <span class="comment">//终端窗口大小改变</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGTERM);     <span class="comment">//终止</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGQUIT);     <span class="comment">//终端退出符</span></span><br><span class="line">    <span class="comment">//.........可以根据开发的实际需要往其中添加其他要屏蔽的信号......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置，此时无法接受的信号；阻塞期间，你发过来的上述信号，多个会被合并为一个，暂存着，等你放开信号屏蔽后才能收到这些信号。。。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">//第一个参数用了SIG_BLOCK表明设置 进程 新的信号屏蔽字 为 “当前信号屏蔽字 和 第二个参数指向的信号集的并集</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,errno,<span class="string">&quot;ngx_master_process_cycle()中sigprocmask()失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//即便sigprocmask失败，程序流程 也继续往下走</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先我设置主进程标题---------begin</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">int</span>    i;</span><br><span class="line">    size = <span class="built_in"><span class="keyword">sizeof</span></span>(master_process);  <span class="comment">//注意我这里用的是sizeof，所以字符串末尾的\0是被计算进来了的</span></span><br><span class="line">    size += g_argvneedmem;          <span class="comment">//argv参数长度加进来    </span></span><br><span class="line">    <span class="keyword">if</span>(size &lt; <span class="number">1000</span>) <span class="comment">//长度小于这个，我才设置标题</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> title[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(title,(<span class="keyword">const</span> <span class="keyword">char</span> *)master_process); <span class="comment">//&quot;master process&quot;</span></span><br><span class="line">        <span class="built_in">strcat</span>(title,<span class="string">&quot; &quot;</span>);  <span class="comment">//跟一个空格分开一些，清晰    //&quot;master process &quot;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_os_argc; i++)         <span class="comment">//&quot;master process ./nginx&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(title,g_os_argv[i]);</span><br><span class="line">        &#125;<span class="comment">//end for</span></span><br><span class="line">        <span class="built_in">ngx_setproctitle</span>(title); <span class="comment">//设置标题</span></span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_NOTICE,<span class="number">0</span>,<span class="string">&quot;%s %P 【master进程】启动并开始运行......!&quot;</span>,title,ngx_pid); <span class="comment">//设置标题时顺便记录下来进程名，进程id等信息到日志</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//首先我设置主进程标题---------end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从配置文件中读取要创建的worker进程数量</span></span><br><span class="line">    CConfig *p_config = CConfig::<span class="built_in">GetInstance</span>(); <span class="comment">//单例类</span></span><br><span class="line">    <span class="keyword">int</span> workprocess = p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;WorkerProcesses&quot;</span>,<span class="number">1</span>); <span class="comment">//从配置文件中得到要创建的worker进程数量</span></span><br><span class="line">    <span class="built_in">ngx_start_worker_processes</span>(workprocess);  <span class="comment">//这里要创建worker子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程后，父进程的执行流程会返回到这里，子进程不会走进来    </span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set); <span class="comment">//信号屏蔽字为空，表示不屏蔽任何信号，但以往阻塞的信号仍然被阻塞，需要sigprocmask来解除阻塞</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ;; ) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    usleep(100000);</span></span><br><span class="line">        <span class="comment">//ngx_log_error_core(0,0,&quot;haha--这是父进程，pid为%P&quot;,ngx_pid);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sigsuspend(const sigset_t *mask))用于在接收到某个信号之前, 临时用mask替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。</span></span><br><span class="line">        <span class="comment">// sigsuspend 返回后将恢复调用之前的信号掩码。信号处理函数完成后，进程将继续执行。该系统调用始终返回-1，并将errno设置为EINTR。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//sigsuspend是一个原子操作，包含4个步骤：</span></span><br><span class="line">        <span class="comment">//a)根据给定的参数设置新的mask 并 阻塞当前进程【因为是个空集，所以不阻塞任何信号】</span></span><br><span class="line">        <span class="comment">//b)此时，一旦收到信号，便恢复原先的信号屏蔽【我们原来调用sigprocmask()的mask在上边设置的，阻塞了多达10个信号，从而保证我下边的执行流程不会再次被其他信号截断】</span></span><br><span class="line">        <span class="comment">//c)调用该信号对应的信号处理函数</span></span><br><span class="line">        <span class="comment">//d)信号处理函数返回后，sigsuspend返回，使程序流程继续往下走</span></span><br><span class="line">        <span class="comment">//printf(&quot;for进来了！\n&quot;); //发现，如果print不加\n，无法及时显示到屏幕上，是行缓存问题，以往没注意；可参考https://blog.csdn.net/qq_26093511/article/details/53255970</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;set); <span class="comment">//阻塞在这里，等待一个信号，此时进程是挂起的，不占用cpu时间，只有收到信号才会被唤醒（返回）；</span></span><br><span class="line">                         <span class="comment">//此时master进程完全靠信号驱动干活    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        printf(&quot;执行到sigsuspend()下边来了\n&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;master进程休息1秒\n&quot;);      </span></span><br><span class="line">        <span class="comment">//ngx_log_stderr(0,&quot;haha--这是父进程，pid为%P&quot;,ngx_pid); </span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">//休息1秒        </span></span><br><span class="line">        <span class="comment">//以后扩充.......</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">// end for(;;)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ngx-spawn-process（master进程创建子进程）"><a href="#ngx-spawn-process（master进程创建子进程）" class="headerlink" title="ngx_spawn_process（master进程创建子进程）"></a>ngx_spawn_process（master进程创建子进程）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pprocname：子进程名字&quot;worker process&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ngx_spawn_process</span><span class="params">(<span class="keyword">int</span> inum,<span class="keyword">const</span> <span class="keyword">char</span> *pprocname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line"></span><br><span class="line">    pid = fork(); <span class="comment">//fork()系统调用产生子进程</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (pid)  <span class="comment">//pid判断父子进程，分支处理</span></span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">//产生子进程失败</span></span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,errno,<span class="string">&quot;ngx_spawn_process()fork()产生子进程num=%d,procname=\&quot;%s\&quot;失败!&quot;</span>,inum,pprocname);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//子进程分支</span></span><br><span class="line">        ngx_parent = ngx_pid;              <span class="comment">//因为是子进程了，所有原来的pid变成了父pid</span></span><br><span class="line">        ngx_pid = <span class="built_in">getpid</span>();                <span class="comment">//重新获取pid,即本子进程的pid</span></span><br><span class="line">        <span class="built_in">ngx_worker_process_cycle</span>(inum,pprocname);    <span class="comment">//我希望所有worker子进程，在这个函数里不断循环着不出来，也就是说，子进程流程不往下边走;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//这个应该是父进程分支，直接break;，流程往switch之后走            </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//end switch</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程分支会走到这里，子进程流程不往下边走-------------------------</span></span><br><span class="line">    <span class="comment">//若有需要，以后再扩展增加其他代码......</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ngx-open-listening-sockets监听端口并且初始化（worker）"><a href="#ngx-open-listening-sockets监听端口并且初始化（worker）" class="headerlink" title="ngx_open_listening_sockets监听端口并且初始化（worker）"></a>ngx_open_listening_sockets监听端口并且初始化（worker）</h3><blockquote>
<p>NGINX官方socket()和bind()，listen()创建一个监听套接字是在master进程，子进程中调用accept()，<strong>这也是我先前的作法，但是这样会造成惊群现象</strong>，官方解决方法是加一把锁，但是这个方法并不是那么妥当，我选择了在worker中创建不同的监听套接字以避免惊群现象，详情原因见本文末的惊群</p>
</blockquote>
<p>1.对于创建的每个要监听的端口都要创建1个socket，ipv4，任意地址，所有网卡设定。</p>
<p>2.<code>setsockopt(isock,SOL_SOCKET, SO_REUSEADDR,(const void *) &amp;reuseaddr, sizeof(reuseaddr))</code>允许重用本地地址,主要是解决TIME_WAIT这个状态导致bind()失败的问题</p>
<p>3.<code>setnonblocking(isock)</code>设置isock为非阻塞，这样在后续accept的时候就不再会去阻塞住了，</p>
<p>4.对isock进行bind(),listen()</p>
<p>5.将各个监听的isock（目前为2个）放入监听套接字队列CSocekt::vector<lpngx_listening_t> m_ListenSocketList; </p>
<p>注意：<del>这是在主进程中创建监听端口(主进程执行这个函数)</del>，一旦后续fork()出来四个子进程，五个进程都在监听80和443两个端口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听端口【支持多个端口】，这里遵从nginx的函数命名</span></span><br><span class="line"><span class="comment">//在创建worker进程之前就要执行这个函数；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSocekt::ngx_open_listening_sockets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span>                isock;                <span class="comment">//socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>            <span class="comment">//服务器的地址结构体</span></span><br><span class="line">    <span class="keyword">int</span>                iport;                <span class="comment">//端口</span></span><br><span class="line">    <span class="keyword">char</span>               strinfo[<span class="number">100</span>];         <span class="comment">//临时字符串 </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//初始化相关</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));  <span class="comment">//先初始化一下</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">//选择协议族为IPV4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//监听本地所有的IP地址；INADDR_ANY表示的是一个服务器上所有的网卡（服务器可能不止一个网卡）多个本地ip地址都进行绑定端口号，进行侦听。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中途用到一些配置信息</span></span><br><span class="line">    CConfig *p_config = CConfig::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_ListenPortCount; i++) <span class="comment">//要监听这么多个端口，暂时为2，循环2次</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">//参数1：AF_INET：使用ipv4协议，一般就这么写</span></span><br><span class="line">        <span class="comment">//参数2：SOCK_STREAM：使用TCP，表示可靠连接【相对还有一个UDP套接字，表示不可靠连接】</span></span><br><span class="line">        <span class="comment">//参数3：给0，固定用法，就这么记</span></span><br><span class="line">        isock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">//系统函数，成功返回非负描述符，出错返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(isock == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中socket()失败,i=%d.&quot;</span>,i);</span><br><span class="line">            <span class="comment">//其实这里直接退出，那如果以往有成功创建的socket呢？就没得到释放吧，当然走到这里表示程序不正常，应该整个退出，也没必要释放了 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setsockopt（）:设置一些套接字参数选项；</span></span><br><span class="line">        <span class="comment">//参数2：是表示级别，和参数3配套使用，也就是说，参数3如果确定了，参数2就确定了;</span></span><br><span class="line">        <span class="comment">//参数3：允许重用本地地址</span></span><br><span class="line">        <span class="comment">//设置 SO_REUSEADDR，主要是解决TIME_WAIT这个状态导致bind()失败的问题</span></span><br><span class="line">        <span class="keyword">int</span> reuseaddr = <span class="number">1</span>;  <span class="comment">//1:打开对应的设置项</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">setsockopt</span>(isock,SOL_SOCKET, SO_REUSEADDR,(<span class="keyword">const</span> <span class="keyword">void</span> *) &amp;reuseaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(reuseaddr)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中setsockopt(SO_REUSEADDR)失败,i=%d.&quot;</span>,i);</span><br><span class="line">            <span class="built_in">close</span>(isock); <span class="comment">//设置不了重用本地地址，那么我还是关闭这个连接并且return false吧                                                  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为处理惊群问题使用reuseport</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> reuseport = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(isock, SOL_SOCKET, SO_REUSEPORT,(<span class="keyword">const</span> <span class="keyword">void</span> *) &amp;reuseport, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))== <span class="number">-1</span>) <span class="comment">//端口复用需要内核支持</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//失败就失败吧，失败顶多是惊群，但程序依旧可以正常运行，所以仅仅提示一下即可</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中setsockopt(SO_REUSEPORT)失败&quot;</span>,i);</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了让监听套接字accept()快一点将ESTABLISHED状态队列的socket快点取走，设置该socket为非阻塞，</span></span><br><span class="line">        <span class="comment">//非阻塞不卡住就算没有客户端连入accept也会立即返回，但是返回一个错误码。充分利用时间片。</span></span><br><span class="line">        <span class="comment">//如果是阻塞的，accept会一直阻塞直到有连接到来，这样卡住（休眠），等待一个事情（三次握手成功）发生了，才会继续往下走</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">setnonblocking</span>(isock) == <span class="literal">false</span>)</span><br><span class="line">        &#123;                </span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中setnonblocking()失败,i=%d.&quot;</span>,i);</span><br><span class="line">            <span class="built_in">close</span>(isock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置本服务器要监听的地址和端口，这样客户端才能连接到该地址和端口并发送数据        </span></span><br><span class="line">        strinfo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(strinfo,<span class="string">&quot;ListenPort%d&quot;</span>,i);<span class="comment">//取ListenPort0,ListenPort1....</span></span><br><span class="line">        iport = p_config-&gt;<span class="built_in">GetIntDefault</span>(strinfo,<span class="number">10000</span>);</span><br><span class="line">        serv_addr.sin_port = <span class="built_in">htons</span>((<span class="keyword">in_port_t</span>)iport);   <span class="comment">//in_port_t其实就是uint16_t</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定服务器地址结构体</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bind</span>(isock, (struct sockaddr*)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中bind()失败,i=%d.&quot;</span>,i);</span><br><span class="line">            <span class="built_in">close</span>(isock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始监听</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">listen</span>(isock,NGX_LISTEN_BACKLOG) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::Initialize()中listen()失败,i=%d.&quot;</span>,i);</span><br><span class="line">            <span class="built_in">close</span>(isock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以，放到列表里来</span></span><br><span class="line">        <span class="comment">/*struct ngx_listening_s  //和监听端口有关的结构</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int                       port;        //监听的端口号</span></span><br><span class="line"><span class="comment">            int                       fd;          //套接字句柄socket</span></span><br><span class="line"><span class="comment">            lpngx_connection_t        connection;  //连接池中的一个连接，注意这是个指针 </span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        <span class="keyword">lpngx_listening_t</span> p_listensocketitem = <span class="keyword">new</span> <span class="keyword">ngx_listening_t</span>; <span class="comment">//千万不要写错，注意前边类型是指针，后边类型是一个结构体</span></span><br><span class="line">        <span class="built_in">memset</span>(p_listensocketitem,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_listening_t</span>));      <span class="comment">//注意后边用的是 ngx_listening_t而不是lpngx_listening_t</span></span><br><span class="line">        p_listensocketitem-&gt;port = iport;                          <span class="comment">//记录下所监听的端口号</span></span><br><span class="line">        p_listensocketitem-&gt;fd   = isock;                          <span class="comment">//套接字木柄保存下来   </span></span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_INFO,<span class="number">0</span>,<span class="string">&quot;监听%d端口成功!&quot;</span>,iport); <span class="comment">//显示一些信息到日志中</span></span><br><span class="line">        m_ListenSocketList.<span class="built_in">push_back</span>(p_listensocketitem);          <span class="comment">//加入到队列中</span></span><br><span class="line">        <span class="comment">//具体绑定到连接池的连接后续绑定</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//end for(int i = 0; i &lt; m_ListenPortCount; i++)    </span></span><br><span class="line">    <span class="keyword">if</span>(m_ListenSocketList.<span class="built_in">size</span>() &lt;= <span class="number">0</span>)  <span class="comment">//不可能一个端口都不监听吧</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="worker进程初始化工作"><a href="#worker进程初始化工作" class="headerlink" title="worker进程初始化工作"></a>worker进程初始化工作</h2><h3 id="ngx-worker-process-init"><a href="#ngx-worker-process-init" class="headerlink" title="ngx_worker_process_init"></a>ngx_worker_process_init</h3><p>1.放开信号集屏蔽</p>
<p>2.创建线程池中的线程g_threadpool.create详见本文后续内容，这些线程是用于处理消息队列里的消息的，等到消息队列有消息的时候，主线程会唤醒他们。</p>
<p>3.Initialize_subproc初始化发消息互斥量，连接互斥量，连接回收队列相关互斥量、时间处理队列互斥量，初始化发消息的信号量等以及创建1个发送数据的线程，1个回收连接的线程，1个处理到期不发心跳包的线程。（以及在这里创建监听端口）</p>
<p>4.ngx_epoll_init();初始化epoll相关内容，同时 往监听socket上增加监听事件，从而开始让监听端口履行其职责</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//描述：子进程创建时调用本函数进行一些初始化工作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_worker_process_init</span><span class="params">(<span class="keyword">int</span> inum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span>  set;      <span class="comment">//信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);  <span class="comment">//清空信号集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;set, <span class="literal">NULL</span>) == <span class="number">-1</span>)  <span class="comment">//原来是屏蔽那10个信号【防止fork()期间收到信号导致混乱】，现在不再屏蔽任何信号【接收任何信号】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,errno,<span class="string">&quot;ngx_worker_process_init()中sigprocmask()失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池代码，率先创建，至少要比和socket相关的内容优先</span></span><br><span class="line">    CConfig *p_config = CConfig::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">int</span> tmpthreadnums = p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;ProcMsgRecvWorkThreadCount&quot;</span>,<span class="number">5</span>); <span class="comment">//处理接收到的消息的线程池中线程数量</span></span><br><span class="line">    <span class="keyword">if</span>(g_threadpool.<span class="built_in">Create</span>(tmpthreadnums) == <span class="literal">false</span>)  <span class="comment">//创建线程池中线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内存没释放，但是简单粗暴退出;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">//再休息1秒;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(g_socket.<span class="built_in">Initialize_subproc</span>() == <span class="literal">false</span>) <span class="comment">//初始化子进程需要具备的一些多线程能力相关的信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内存没释放，但是简单粗暴退出；</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如下这些代码参照官方nginx里的ngx_event_process_init()函数中的代码</span></span><br><span class="line">    g_socket.<span class="built_in">ngx_epoll_init</span>();           <span class="comment">//初始化epoll相关内容，同时 往监听socket上增加监听事件，从而开始让监听端口履行其职责</span></span><br><span class="line">    <span class="comment">//g_socket.ngx_epoll_listenportstart();//往监听socket上增加监听事件，从而开始让监听端口履行其职责【如果不加这行，虽然端口能连上，但不会触发ngx_epoll_process_events()里边的epoll_wait()往下走】</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....将来再扩充代码</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Initialize-subproc子进程中才需要执行的初始化函数"><a href="#Initialize-subproc子进程中才需要执行的初始化函数" class="headerlink" title="Initialize_subproc子进程中才需要执行的初始化函数"></a>Initialize_subproc子进程中才需要执行的初始化函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子进程中才需要执行的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSocekt::Initialize_subproc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ngx_open_listening_sockets</span>() == <span class="literal">false</span>)  <span class="comment">//打开监听端口    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">//发消息互斥量初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_sendMessageQueueMutex, <span class="literal">NULL</span>)  != <span class="number">0</span>)</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_mutex_init(&amp;m_sendMessageQueueMutex)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接相关互斥量初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_connectionMutex, <span class="literal">NULL</span>)  != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_mutex_init(&amp;m_connectionMutex)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//连接回收队列相关互斥量初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_recyconnqueueMutex, <span class="literal">NULL</span>)  != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_mutex_init(&amp;m_recyconnqueueMutex)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//和时间处理队列有关的互斥量初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_timequeueMutex, <span class="literal">NULL</span>)  != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_mutex_init(&amp;m_timequeueMutex)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//初始化发消息相关信号量，信号量用于进程/线程 之间的同步，虽然 互斥量[pthread_mutex_lock]和 条件变量[pthread_cond_wait]都是线程之间的同步手段，但</span></span><br><span class="line">    <span class="comment">//这里用信号量实现 则 更容易理解，更容易简化问题，使用书写的代码短小且清晰；</span></span><br><span class="line">    <span class="comment">//第二个参数=0，表示信号量在线程之间共享，确实如此 ，如果非0，表示在进程之间共享</span></span><br><span class="line">    <span class="comment">//第三个参数=0，表示信号量的初始值，为0时，调用sem_wait()就会卡在那里卡着</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;m_semEventSendQueue,<span class="number">0</span>,<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中sem_init(&amp;m_semEventSendQueue,0,0)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    ThreadItem *pSendQueue;    <span class="comment">//专门用来发送数据的线程</span></span><br><span class="line">    m_threadVector.<span class="built_in">push_back</span>(pSendQueue = <span class="keyword">new</span> <span class="built_in">ThreadItem</span>(<span class="keyword">this</span>));                         <span class="comment">//创建 一个新线程对象 并入到容器中 </span></span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;pSendQueue-&gt;_Handle, <span class="literal">NULL</span>, ServerSendQueueThread,pSendQueue); <span class="comment">//创建线程，错误不返回到errno，一般返回错误码</span></span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_create(ServerSendQueueThread)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---</span></span><br><span class="line">    ThreadItem *pRecyconn;    <span class="comment">//专门用来回收连接的线程</span></span><br><span class="line">    m_threadVector.<span class="built_in">push_back</span>(pRecyconn = <span class="keyword">new</span> <span class="built_in">ThreadItem</span>(<span class="keyword">this</span>)); </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;pRecyconn-&gt;_Handle, <span class="literal">NULL</span>, ServerRecyConnectionThread,pRecyconn);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_create(ServerRecyConnectionThread)失败.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_ifkickTimeCount == <span class="number">1</span>)  <span class="comment">//是否开启踢人时钟，1：开启   0：不开启</span></span><br><span class="line">    &#123;</span><br><span class="line">        ThreadItem *pTimemonitor;    <span class="comment">//专门用来处理到期不发心跳包的用户踢出的线程</span></span><br><span class="line">        m_threadVector.<span class="built_in">push_back</span>(pTimemonitor = <span class="keyword">new</span> <span class="built_in">ThreadItem</span>(<span class="keyword">this</span>)); </span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;pTimemonitor-&gt;_Handle, <span class="literal">NULL</span>, ServerTimerQueueMonitorThread,pTimemonitor);</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::Initialize_subproc()中pthread_create(ServerTimerQueueMonitorThread)失败.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ngx-epoll-init"><a href="#ngx-epoll-init" class="headerlink" title="ngx_epoll_init"></a>ngx_epoll_init</h3><p>创建监听端口是在<del>父进程</del>（子进程）中（ngx_open_listening_sockets）进行的，那么完整的初始化监听socket（包括创建连接池并且将每个监听socket放入到连接池的连接和放入epoll红黑树开始监听事件）是在子进程</p>
<p>1.在这里创建一个epoll对象，一定要判断返回值，这是一个好习惯</p>
<p>2.创建连接池，详见本文后续内容连接池</p>
<p>3.每个监听socket增加一个 连接池中的连接，同时连接池内的连接（只有是监听socket的连接才可以）也可以通过<code>lpngx_connection_t::p_Conn-&gt;listening = (*pos);</code>找到监听socket对象。</p>
<p>4.设置连接池内的监听socket的写事件处理函数为<code>p_Conn-&gt;rhandler = &amp;CSocekt::ngx_event_accept;</code>，此函数用于处理三次握手事件，对于三次握手的新连接又会重新指定写事件处理函数和读事件处理函数</p>
<p>5.为<strong>每一个监听socket</strong>上增加(EPOLL_CTL_ADD)监听的事件，读事件和TCP连接半关闭分别对应<code>EPOLLIN|EPOLLRDHUP</code>事件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)epoll功能初始化，子进程中进行 ，本函数被ngx_worker_process_init()所调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSocekt::ngx_epoll_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//(1)很多内核版本不处理epoll_create的参数，只要该参数&gt;0即可</span></span><br><span class="line">    <span class="comment">//创建一个epoll对象，创建了一个红黑树，还创建了一个双向链表</span></span><br><span class="line">    m_epollhandle = <span class="built_in">epoll_create</span>(m_worker_connections);   <span class="comment">//直接以epoll连接的最大项数为参数，肯定是&gt;0的； </span></span><br><span class="line">    <span class="keyword">if</span> (m_epollhandle == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ngx_epoll_init()中epoll_create()失败.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>); <span class="comment">//这是致命问题了，直接退，资源由系统释放吧，这里不刻意释放了，比较麻烦</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)创建连接池【数组】、创建出来，这个东西后续用于处理所有客户端的连接</span></span><br><span class="line">    <span class="comment">//子进程创建以后，会继承父进程的全局变量，但是继承的是父进程刚开始全局变量的值。</span></span><br><span class="line">    <span class="comment">//但是子进程创建以后，子进程修改了变量，或者父进程修改了全局变量的值，父子进程就互相都不影响了。</span></span><br><span class="line">    <span class="built_in">initconnection</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(3)遍历所有监听socket【监听端口】，我们为每个监听socket增加一个 连接池中的连接【说白了就是让一个socket和一个内存绑定，以方便记录该sokcet相关的数据、状态等等】</span></span><br><span class="line">    std::vector&lt;<span class="keyword">lpngx_listening_t</span>&gt;::iterator pos;	</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ListenSocketList.<span class="built_in">begin</span>(); pos != m_ListenSocketList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lpngx_connection_t</span> p_Conn = <span class="built_in">ngx_get_connection</span>((*pos)-&gt;fd); <span class="comment">//从连接池中获取一个空闲连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (p_Conn == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这是致命问题，刚开始怎么可能连接池就为空呢？</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ngx_epoll_init()中ngx_get_connection()失败.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>); <span class="comment">//这是致命问题了，直接退，资源由系统释放吧，这里不刻意释放了，比较麻烦</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p_Conn-&gt;listening = (*pos);   <span class="comment">//连接对象 和监听对象关联，方便通过连接对象找监听对象</span></span><br><span class="line">        (*pos)-&gt;connection = p_Conn;  <span class="comment">//监听对象 和连接对象关联，方便通过监听对象找连接对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//rev-&gt;accept = 1; //监听端口必须设置accept标志为1  ，这个是否有必要，再研究</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对监听端口的读事件设置处理方法，因为监听端口是用来等对方连接的发送三路握手的，所以监听端口关心的就是读事件</span></span><br><span class="line">        p_Conn-&gt;rhandler = &amp;CSocekt::ngx_event_accept;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往监听socket上增加监听事件，从而开始让监听端口履行其职责【如果不加这行，虽然端口能连上，但不会触发ngx_epoll_process_events()里边的epoll_wait()往下走】</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ngx_epoll_oper_event</span>(</span><br><span class="line">                                (*pos)-&gt;fd,         <span class="comment">//socekt句柄</span></span><br><span class="line">                                EPOLL_CTL_ADD,      <span class="comment">//事件类型，这里是增加</span></span><br><span class="line">                                EPOLLIN|EPOLLRDHUP, <span class="comment">//标志，这里代表要增加的标志,EPOLLIN：可读，EPOLLRDHUP：TCP连接的远端关闭或者半关闭</span></span><br><span class="line">                                <span class="number">0</span>,                  <span class="comment">//对于事件类型为增加的，不需要这个参数</span></span><br><span class="line">                                p_Conn              <span class="comment">//连接池中的连接 </span></span><br><span class="line">                                ) == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>); <span class="comment">//有问题，直接退出，日志 已经写过了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//end for </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ngx-close-connection直接关闭连接"><a href="#ngx-close-connection直接关闭连接" class="headerlink" title="ngx_close_connection直接关闭连接"></a>ngx_close_connection直接关闭连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户连入，我们accept4()时，得到的socket在处理中产生失败，则资源用这个函数释放【因为这里涉及到好几个要释放的资源，所以写成函数】</span></span><br><span class="line"><span class="comment">//我们把ngx_close_accepted_connection()函数改名为让名字更通用，并从文件ngx_socket_accept.cxx迁移到本文件中，并改造其中代码，注意顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_close_connection</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">//pConn-&gt;fd = -1; //官方nginx这么写，这么写有意义；    不要这个东西，回收时不要轻易东连接里边的内容</span></span><br><span class="line">    <span class="built_in">ngx_free_connection</span>(pConn); </span><br><span class="line">    <span class="keyword">if</span>(pConn-&gt;fd != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(pConn-&gt;fd);</span><br><span class="line">        pConn-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ngx-epoll-oper-event对epoll事件的具体操作（增删改）"><a href="#ngx-epoll-oper-event对epoll事件的具体操作（增删改）" class="headerlink" title="ngx_epoll_oper_event对epoll事件的具体操作（增删改）"></a>ngx_epoll_oper_event对epoll事件的具体操作（增删改）</h3><ul>
<li>三次握手进来增加读事件ADD</li>
<li>监听端口有ADD</li>
</ul>
<p>注意：原来的理解中，绑定ev.data.ptr这个事，只在EPOLL_CTL_ADD的时候做一次即可，但是发现EPOLL_CTL_MOD<strong>似乎会破坏掉ev.data.ptr</strong>，因此不管是EPOLL_CTL_ADD，还是EPOLL_CTL_MOD，ev.data.ptr都要去重新绑定！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对epoll事件的具体操作</span></span><br><span class="line"><span class="comment">//返回值：成功返回1，失败返回-1；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSocekt::ngx_epoll_oper_event</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span>                fd,               <span class="comment">//句柄，一个socket</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">uint32_t</span>           eventtype,        <span class="comment">//事件类型，一般是EPOLL_CTL_ADD，EPOLL_CTL_MOD，EPOLL_CTL_DEL ，说白了就是操作epoll红黑树的节点(增加，修改，删除)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">uint32_t</span>           flag,             <span class="comment">//标志，具体含义取决于eventtype</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span>                bcaction,         <span class="comment">//补充动作，用于补充flag标记的不足  :  0：增加   1：去掉 2：完全覆盖 ,eventtype是EPOLL_CTL_MOD时这个参数就有用</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">lpngx_connection_t</span> pConn             <span class="comment">//pConn：一个指针【其实是一个连接】，EPOLL_CTL_ADD时增加到红黑树中去，将来epoll_wait时能取出来用</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;ev, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ev));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eventtype == EPOLL_CTL_ADD) <span class="comment">//往红黑树中增加节点；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//红黑树从无到有增加节点</span></span><br><span class="line">        <span class="comment">//ev.data.ptr = (void *)pConn;</span></span><br><span class="line">        ev.events = flag;      <span class="comment">//既然是增加节点，则不管原来是啥标记</span></span><br><span class="line">        pConn-&gt;events = flag;  <span class="comment">//这个连接本身也记录这个标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(eventtype == EPOLL_CTL_MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//节点已经在红黑树中，修改节点的事件信息</span></span><br><span class="line">        ev.events = pConn-&gt;events;  <span class="comment">//先把标记恢复回来</span></span><br><span class="line">        <span class="keyword">if</span>(bcaction == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//增加某个标记            </span></span><br><span class="line">            ev.events |= flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bcaction == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去掉某个标记</span></span><br><span class="line">            ev.events &amp;= ~flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//完全覆盖某个标记            </span></span><br><span class="line">            ev.events = flag;      <span class="comment">//完全覆盖            </span></span><br><span class="line">        &#125;</span><br><span class="line">        pConn-&gt;events = ev.events; <span class="comment">//记录该标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除红黑树中节点，目前没这个需求【socket关闭这项会自动从红黑树移除】，所以将来再扩展</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;  <span class="comment">//先直接返回1表示成功</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来的理解中，绑定ptr这个事，只在EPOLL_CTL_ADD的时候做一次即可，但是发现EPOLL_CTL_MOD似乎会破坏掉.data.ptr，因此不管是EPOLL_CTL_ADD，还是EPOLL_CTL_MOD，都给进去</span></span><br><span class="line">    <span class="comment">//找了下内核源码SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,		struct epoll_event __user *, event)，感觉真的会覆盖掉：</span></span><br><span class="line">       <span class="comment">//copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))，感觉这个内核处理这个事情太粗暴了</span></span><br><span class="line">    ev.data.ptr = (<span class="keyword">void</span> *)pConn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(m_epollhandle,eventtype,fd,&amp;ev) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ngx_epoll_oper_event()中epoll_ctl(%d,%ud,%ud,%d)失败。&quot;</span>,fd,eventtype,flag,bcaction);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="worker子进程处理网络事件（读、写）和定时器事件"><a href="#worker子进程处理网络事件（读、写）和定时器事件" class="headerlink" title="worker子进程处理网络事件（读、写）和定时器事件"></a>worker子进程处理网络事件（读、写）和定时器事件</h2><h3 id="事件驱动模型ngx-epoll-process-events"><a href="#事件驱动模型ngx-epoll-process-events" class="headerlink" title="事件驱动模型ngx_epoll_process_events"></a>事件驱动模型ngx_epoll_process_events</h3><p>子进程初始化完监听端口和设置好子进程标题之后，执行for死循环，死循环内不断调用ngx_epoll_process_events。</p>
<p>“事件驱动”，无非就是通过获取事件，通过获取到的事件并根据这个事件来调用适当的函数从而让整个程序干活，无非就是这点事;</p>
<p>1.事件驱动我们第一步一定是获取事件，如何获取事件，调用epoll_wait()。</p>
<p>2.一定要严密的判断，epoll_wait返回事件的数目，而事件会返回到参数m_events里，先判断events数目执行对应的判断。</p>
<p>3.然后for循环里不断地通过m_events[i].data.ptr把发生了事件的<strong>连接池中的连接</strong>取出来并且<code>revents = m_events[i].events;</code>取出<strong>这个连接的事件类型</strong></p>
<p>4.对于<strong>每一个发生事件的连接</strong>判断发生事件的类型，<br>    对于读事件，<code>(this-&gt;* (p_Conn-&gt;rhandler) )(p_Conn);</code>函数指针<br>    对于监听套接字的连接会调用<code>CSocekt::ngx_event_accept(c)</code>，这在子进程创建时进行初始化ngx_epoll_init函数中就已经将连接池内的监听套接字连接的函数指针指定到ngx_event_accept上<br>    如果是已经连入，发送数据到这里，则这里执行的应该是 <code>CSocekt::ngx_read_request_handler()</code></p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220411172930098.png" alt="image-20220411172930098"></p>
<p>注意我这个ngx_epoll_process_events中epoll_wait相当于事件收集器，各个事件对应的处理函数都属于事件处理器，用来消费事件。<strong>因此每个处理函数不能够被阻塞，而且应该尽快执行完成</strong>，否则整个for死循环中的ngx_epoll_process_events卡住了，下一次epoll_wait函数积累的事件越来越多整个程序就会崩盘了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始获取发生的事件消息</span></span><br><span class="line"><span class="comment">//参数unsigned int timer：epoll_wait()阻塞的时长，单位是毫秒；</span></span><br><span class="line"><span class="comment">//返回值，1：正常返回  ,0：有问题返回，一般不管是正常还是问题返回，都应该保持进程继续运行</span></span><br><span class="line"><span class="comment">//本函数被ngx_process_events_and_timers()调用，而ngx_process_events_and_timers()是在子进程的死循环中被反复调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSocekt::ngx_epoll_process_events</span><span class="params">(<span class="keyword">int</span> timer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//等待事件，事件会返回到m_events里，最多返回NGX_MAX_EVENTS个事件【因为我只提供了这些内存】；</span></span><br><span class="line">    <span class="comment">//如果两次调用epoll_wait()的事件间隔比较长，则可能在epoll的双向链表中，积累了多个事件，所以调用epoll_wait，可能取到多个事件</span></span><br><span class="line">    <span class="comment">//阻塞timer这么长时间除非：a)阻塞时间到达 b)阻塞期间收到事件【比如新用户连入】会立刻返回c)调用时有事件也会立刻返回d)如果来个信号，比如你用kill -1 pid测试</span></span><br><span class="line">    <span class="comment">//如果timer为-1则一直阻塞，如果timer为0则立即返回，即便没有任何事件</span></span><br><span class="line">    <span class="comment">//返回值：有错误发生返回-1，错误在errno中，比如你发个信号过来，就返回-1，错误信息是(4: Interrupted system call)</span></span><br><span class="line">    <span class="comment">//       如果你等待的是一段时间，并且超时了，则返回0；</span></span><br><span class="line">    <span class="comment">//       如果返回&gt;0则表示成功捕获到这么多个事件【返回值里】</span></span><br><span class="line">    <span class="keyword">int</span> events = <span class="built_in">epoll_wait</span>(m_epollhandle,m_events,NGX_MAX_EVENTS,timer);<span class="comment">//一直阻塞在这里</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(events == <span class="number">-1</span>)<span class="comment">//一定要严密地判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有错误发生，发送某个信号给本进程就可以导致这个条件成立，而且错误码根据观察是4；</span></span><br><span class="line">        <span class="comment">//#define EINTR  4，EINTR错误的产生：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。</span></span><br><span class="line">               <span class="comment">//例如：在socket服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使accept返回一个EINTR错误(被中断的系统调用)。</span></span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//信号所致，直接返回，一般认为这不是毛病，但还是打印下日志记录一下，因为一般也不会人为给worker进程发送消息</span></span><br><span class="line">            <span class="built_in">ngx_log_error_core</span>(NGX_LOG_INFO,errno,<span class="string">&quot;CSocekt::ngx_epoll_process_events()中epoll_wait()失败!&quot;</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正常返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这被认为应该是有问题，记录日志</span></span><br><span class="line">            <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,errno,<span class="string">&quot;CSocekt::ngx_epoll_process_events()中epoll_wait()失败!&quot;</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//非正常返回 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(events == <span class="number">0</span>) <span class="comment">//超时，但没事件来</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要求epoll_wait阻塞一定的时间而不是一直阻塞，这属于阻塞到时间了，则正常返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无限等待【所以不存在超时】，但却没返回任何事件，这应该不正常有问题        </span></span><br><span class="line">        <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,<span class="number">0</span>,<span class="string">&quot;CSocekt::ngx_epoll_process_events()中epoll_wait()没超时却没返回任何事件!&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非正常返回 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会惊群，一个telnet上来，4个worker进程都会被惊动，都执行下边这个</span></span><br><span class="line">    <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;惊群测试:events=%d,进程id=%d&quot;</span>,events,ngx_pid); </span><br><span class="line">    <span class="comment">//ngx_log_stderr(0,&quot;----------------------------------------&quot;); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里，就是属于有事件收到了</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn</span><br><span class="line">    <span class="keyword">uint32_t</span>           revents;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; events; ++i)    <span class="comment">//遍历本次epoll_wait返回的所有事件，注意events才是返回的实际事件数量</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_Conn = (<span class="keyword">lpngx_connection_t</span>)(m_events[i].data.ptr);           <span class="comment">//ngx_epoll_add_event()给进去的，这里能取出来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//能走到这里，我们认为这些事件都没过期，就正常开始处理</span></span><br><span class="line">        revents = m_events[i].events;<span class="comment">//取出事件类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(revents &amp; (EPOLLERR|EPOLLHUP)) //例如对方close掉套接字，这里会感应到【换句话说：如果发生了错误或者客户端断连】</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //这加上读写标记，方便后续代码处理，至于怎么处理，后续再说，这里也是参照nginx官方代码引入的这段代码；</span></span><br><span class="line"><span class="comment">            //官方说法：if the error events were returned, add EPOLLIN and EPOLLOUT，to handle the events at least in one active handler</span></span><br><span class="line"><span class="comment">            //我认为官方也是经过反复思考才加上着东西的，先放这里放着吧； </span></span><br><span class="line"><span class="comment">            revents |= EPOLLIN|EPOLLOUT;   //EPOLLIN：表示对应的链接上有数据可以读出（TCP链接的远端主动关闭连接，也相当于可读事件，因为本服务器小处理发送来的FIN包）</span></span><br><span class="line"><span class="comment">                                           //EPOLLOUT：表示对应的连接上可以写入数据发送【写准备好】            </span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(revents &amp; EPOLLIN)  <span class="comment">//如果是读事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ngx_log_stderr(errno,&quot;数据来了来了来了 ~~~~~~~~~~~~~.&quot;);</span></span><br><span class="line">            <span class="comment">//一个客户端新连入，这个会成立，</span></span><br><span class="line">            <span class="comment">//已连接发送数据来，这个也成立；</span></span><br><span class="line">            <span class="comment">//c-&gt;r_ready = 1;                         //标记可以读；【从连接池拿出一个连接时这个连接的所有成员都是0】            </span></span><br><span class="line">            (<span class="keyword">this</span>-&gt;* (p_Conn-&gt;rhandler) )(p_Conn);    <span class="comment">//注意括号的运用来正确设置优先级，防止编译出错；【如果是个新客户连入</span></span><br><span class="line">                                                      <span class="comment">//如果新连接进入，这里执行的应该是CSocekt::ngx_event_accept(c)】            </span></span><br><span class="line">                                                      <span class="comment">//如果是已经连入，发送数据到这里，则这里执行的应该是 CSocekt::ngx_read_request_handler()     </span></span><br><span class="line">                                     </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(revents &amp; EPOLLOUT) <span class="comment">//如果是写事件【对方关闭连接也触发这个，再研究。。。。。。】，注意上边的 if(revents &amp; (EPOLLERR|EPOLLHUP))  revents |= EPOLLIN|EPOLLOUT; 读写标记都给加上了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ngx_log_stderr(errno,&quot;22222222222222222222.&quot;);</span></span><br><span class="line">            <span class="keyword">if</span>(revents &amp; (EPOLLERR | EPOLLHUP | EPOLLRDHUP)) <span class="comment">//客户端关闭，如果服务器端挂着一个写通知事件，则这里个条件是可能成立的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//EPOLLERR：对应的连接发生错误                     8     = 1000 </span></span><br><span class="line">                <span class="comment">//EPOLLHUP：对应的连接被挂起                       16    = 0001 0000</span></span><br><span class="line">                <span class="comment">//EPOLLRDHUP：表示TCP连接的远端关闭或者半关闭连接   8192   = 0010  0000   0000   0000</span></span><br><span class="line">                <span class="comment">//我想打印一下日志看一下是否会出现这种情况</span></span><br><span class="line">                <span class="comment">//8221 = ‭0010 0000 0001 1101‬  ：包括 EPOLLRDHUP ，EPOLLHUP， EPOLLERR</span></span><br><span class="line">                <span class="comment">//ngx_log_stderr(errno,&quot;CSocekt::ngx_epoll_process_events()中revents&amp;EPOLLOUT成立并且revents &amp; (EPOLLERR|EPOLLHUP|EPOLLRDHUP)成立,event=%ud。&quot;,revents); </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//我们只有投递了 写事件，但对端断开时，程序流程才走到这里，投递了写事件意味着 iThrowsendCount标记肯定被+1了，这里我们减回</span></span><br><span class="line">                --p_Conn-&gt;iThrowsendCount;                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="keyword">this</span>-&gt;* (p_Conn-&gt;whandler) )(p_Conn);   <span class="comment">//如果有数据没有发送完毕，由系统驱动来发送，则这里执行的应该是 CSocekt::ngx_write_request_handler()</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//end for(int i = 0; i &lt; events; ++i)     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理三次握手连入事件ngx-event-accept"><a href="#处理三次握手连入事件ngx-event-accept" class="headerlink" title="处理三次握手连入事件ngx_event_accept"></a>处理三次握手连入事件ngx_event_accept</h3><p>三次握手进来了，触发了epoll的读事件，前来调用此函数。accept是从已完成连接established队列取出该socket。</p>
<ul>
<li>1.用accept4或者accept返回得到socket注意设置成非阻塞。如果设置非阻塞失败那么必须要回收连接池的连接并且关闭socket。</li>
<li>2.给新连接分配一个连接池内的连接ngx_get_connection。</li>
<li>3.连接池内的连接设置这个连接的处理函数<br>   newc-&gt;rhandler = &amp;CSocekt::ngx_read_request_handler;  //设置已建立连接的socket当客户端发来数据来时的读处理函数<br>   newc-&gt;whandler = &amp;CSocekt::ngx_write_request_handler; //设置已建立连接的socket的写处理函数</li>
<li>4.客户端应该主动发送第一次的数据，这里将读事件加入epoll监控<code>ngx_epoll_oper_event</code>，这样当客户端发送数据来时，ngx_read_request_handler()被ngx_epoll_process_events()调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立新连接专用函数，当新连接进入时，本函数会被ngx_epoll_process_events()所调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_event_accept</span><span class="params">(<span class="keyword">lpngx_connection_t</span> oldc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为listen套接字上用的不是ET【边缘触发】，而是LT【水平触发】，意味着客户端连入如果我要不处理，这个函数会被多次调用，所以，我这里这里可以不必多次accept()，可以只执行一次accept()</span></span><br><span class="line">         <span class="comment">//这也可以避免本函数被卡太久，注意，本函数应该尽快返回，以免阻塞程序运行；</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>    <span class="title">mysockaddr</span>;</span>        <span class="comment">//远端服务器的socket地址</span></span><br><span class="line">    <span class="keyword">socklen_t</span>          socklen;</span><br><span class="line">    <span class="keyword">int</span>                err;</span><br><span class="line">    <span class="keyword">int</span>                level;</span><br><span class="line">    <span class="keyword">int</span>                s;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>         use_accept4 = <span class="number">1</span>;   <span class="comment">//我们先认为能够使用accept4()函数</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> newc;              <span class="comment">//代表连接池中的一个连接【注意这是指针】</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ngx_log_stderr(0,&quot;这是几个\n&quot;); 这里会惊群，也就是说，epoll技术本身有惊群的问题</span></span><br><span class="line"></span><br><span class="line">    socklen = <span class="built_in"><span class="keyword">sizeof</span></span>(mysockaddr);</span><br><span class="line">    <span class="keyword">do</span>   <span class="comment">//用do，跳到while后边去方便</span></span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">if</span>(use_accept4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//以为listen套接字是非阻塞的，所以即便已完成连接队列为空，accept4()也不会卡在这里；</span></span><br><span class="line">            s = <span class="built_in">accept4</span>(oldc-&gt;fd, &amp;mysockaddr, &amp;socklen, SOCK_NONBLOCK); <span class="comment">//从内核获取一个用户端连接，最后一个参数SOCK_NONBLOCK表示返回一个非阻塞的socket，节省一次ioctl【设置为非阻塞】调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//以为listen套接字是非阻塞的，所以即便已完成连接队列为空，accept()也不会卡在这里；</span></span><br><span class="line">            s = <span class="built_in">accept</span>(oldc-&gt;fd, &amp;mysockaddr, &amp;socklen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//惊群，有时候不一定完全惊动所有4个worker进程，可能只惊动其中2个等等，其中一个成功其余的accept4()都会返回-1；错误 (11: Resource temporarily unavailable【资源暂时不可用】) </span></span><br><span class="line">        <span class="comment">//所以参考资料：https://blog.csdn.net/russell_tao/article/details/7204260</span></span><br><span class="line">        <span class="comment">//其实，在linux2.6内核上，accept系统调用已经不存在惊群了（至少我在2.6.18内核版本上已经不存在）。大家可以写个简单的程序试下，在父进程中bind,listen，然后fork出子进程，</span></span><br><span class="line">               <span class="comment">//所有的子进程都accept这个监听句柄。这样，当新连接过来时，大家会发现，仅有一个子进程返回新建的连接，其他子进程继续休眠在accept调用上，没有被唤醒。</span></span><br><span class="line">        <span class="comment">//ngx_log_stderr(0,&quot;测试惊群问题，看惊动几个worker进程%d\n&quot;,s); 【我的结论是：accept4可以认为基本解决惊群问题，但似乎并没有完全解决，有时候还会惊动其他的worker进程】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            err = errno;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期待阻塞”）</span></span><br><span class="line">            <span class="keyword">if</span>(err == EAGAIN) <span class="comment">//accept()没准备好，这个EAGAIN错误EWOULDBLOCK是一样的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//除非你用一个循环不断的accept()取走所有的连接，不然一般不会有这个错误【我们这里只取一个连接，也就是accept()一次】</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; </span><br><span class="line">            level = NGX_LOG_ALERT;</span><br><span class="line">            <span class="keyword">if</span> (err == ECONNABORTED)  <span class="comment">//ECONNRESET错误则发生在对方意外关闭套接字后【您的主机中的软件放弃了一个已建立的连接--由于超时或者其它失败而中止接连(用户插拔网线就可能有这个错误出现)】</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，</span></span><br><span class="line">                    <span class="comment">//客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。</span></span><br><span class="line">                    <span class="comment">//POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。</span></span><br><span class="line">                        <span class="comment">//服务器进程一般可以忽略该错误，直接再次调用accept。</span></span><br><span class="line">                level = NGX_LOG_ERR;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (err == EMFILE || err == ENFILE) <span class="comment">//EMFILE:进程的fd已用尽【已达到系统所允许单一进程所能打开的文件/套接字总数】。可参考：https://blog.csdn.net/sdn_prc/article/details/28661661   以及 https://bbs.csdn.net/topics/390592927</span></span><br><span class="line">                                                        <span class="comment">//ulimit -n ,看看文件描述符限制,如果是1024的话，需要改大;  打开的文件句柄数过多 ,把系统的fd软限制和硬限制都抬高.</span></span><br><span class="line">                                                    <span class="comment">//ENFILE这个errno的存在，表明一定存在system-wide的resource limits，而不仅仅有process-specific的resource limits。按照常识，process-specific的resource limits，一定受限于system-wide的resource limits。</span></span><br><span class="line">            &#123;</span><br><span class="line">                level = NGX_LOG_CRIT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ngx_log_error_core(level,errno,&quot;CSocekt::ngx_event_accept()中accept4()失败!&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(use_accept4 &amp;&amp; err == ENOSYS) <span class="comment">//accept4()函数没实现，坑爹？</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_accept4 = <span class="number">0</span>;  <span class="comment">//标记不使用accept4()函数，改用accept()函数</span></span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">//回去重新用accept()函数搞</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == ECONNABORTED)  <span class="comment">//对方关闭套接字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这个错误因为可以忽略，所以不用干啥</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (err == EMFILE || err == ENFILE) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//do nothing，这个官方做法是先把读事件从listen socket上移除，然后再弄个定时器，定时器到了则继续执行该函数，但是定时器到了有个标记，会把读事件增加到listen socket上去；</span></span><br><span class="line">                <span class="comment">//我这里目前先不处理吧【因为上边已经写这个日志了】；</span></span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  <span class="comment">//end if(s == -1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里的，表示accept4()/accept()成功了        </span></span><br><span class="line">        <span class="keyword">if</span>(m_onlineUserCount &gt;= m_worker_connections)  <span class="comment">//用户连接数过多，要关闭该用户socket，因为现在也没分配连接，所以直接关闭即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;超出系统允许的最大连入用户数(最大允许连入数%d)，关闭连入请求(%d)。&quot;,m_worker_connections,s);  </span></span><br><span class="line">            <span class="built_in">close</span>(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果某些恶意用户连上来发了1条数据就断，不断连接，会导致频繁调用ngx_get_connection()使用我们短时间内产生大量连接，危及本服务器安全</span></span><br><span class="line">        <span class="keyword">if</span>(m_connectionList.<span class="built_in">size</span>() &gt; (m_worker_connections * <span class="number">5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比如你允许同时最大2048个连接，但连接池却有了 2048*5这么大的容量，这肯定是表示短时间内 产生大量连接/断开，因为我们的延迟回收机制，这里连接还在垃圾池里没有被回收</span></span><br><span class="line">            <span class="keyword">if</span>(m_freeconnectionList.<span class="built_in">size</span>() &lt; m_worker_connections)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//整个连接池这么大了，而空闲连接却这么少了，所以我认为是  短时间内 产生大量连接，发一个包后就断开，我们不可能让这种情况持续发生，所以必须断开新入用户的连接</span></span><br><span class="line">                <span class="comment">//一直到m_freeconnectionList变得足够大【连接池中连接被回收的足够多】</span></span><br><span class="line">                <span class="built_in">close</span>(s);</span><br><span class="line">                <span class="keyword">return</span> ;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ngx_log_stderr(errno,&quot;accept4成功s=%d&quot;,s); //s这里就是 一个句柄了</span></span><br><span class="line">        newc = <span class="built_in">ngx_get_connection</span>(s); <span class="comment">//这是针对新连入用户的连接，和监听套接字 所对应的连接是两个不同的东西，不要搞混</span></span><br><span class="line">        <span class="keyword">if</span>(newc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连接池中连接不够用，那么就得把这个socekt直接关闭并返回了，因为在ngx_get_connection()中已经写日志了，所以这里不需要写日志了</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">close</span>(s) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ngx_log_error_core</span>(NGX_LOG_ALERT,errno,<span class="string">&quot;CSocekt::ngx_event_accept()中close(%d)失败!&quot;</span>,s);                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...........将来这里会判断是否连接超过最大允许连接数，现在，这里可以不处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//成功的拿到了连接池中的一个连接</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;newc-&gt;s_sockaddr,&amp;mysockaddr,socklen);  <span class="comment">//拷贝客户端地址到连接对象【要转成字符串ip地址参考函数ngx_sock_ntop()】</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    //测试将收到的地址弄成字符串，格式形如&quot;192.168.1.126:40904&quot;或者&quot;192.168.1.126&quot;</span></span><br><span class="line">        <span class="comment">//    u_char ipaddr[100]; memset(ipaddr,0,sizeof(ipaddr));</span></span><br><span class="line">        <span class="comment">//    ngx_sock_ntop(&amp;newc-&gt;s_sockaddr,1,ipaddr,sizeof(ipaddr)-10); //宽度给小点</span></span><br><span class="line">        <span class="comment">//    ngx_log_stderr(0,&quot;ip信息为%s\n&quot;,ipaddr);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!use_accept4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果不是用accept4()取得的socket，那么就要设置为非阻塞【因为用accept4()的已经被accept4()设置为非阻塞了】</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">setnonblocking</span>(s) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//设置非阻塞居然失败</span></span><br><span class="line">                <span class="built_in">ngx_close_connection</span>(newc); <span class="comment">//关闭socket,这种可以立即回收这个连接，无需延迟，因为其上还没有数据收发，谈不到业务逻辑因此无需延迟；</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newc-&gt;listening = oldc-&gt;listening;                    <span class="comment">//连接对象 和监听对象关联，方便通过连接对象找监听对象【关联到监听端口】</span></span><br><span class="line">        <span class="comment">//newc-&gt;w_ready = 1;                                    //标记可以写，新连接写事件肯定是ready的；【从连接池拿出一个连接时这个连接的所有成员都是0】            </span></span><br><span class="line">        </span><br><span class="line">        newc-&gt;rhandler = &amp;CSocekt::ngx_read_request_handler;  <span class="comment">//设置数据来时的读处理函数，其实官方nginx中是ngx_http_wait_request_handler()</span></span><br><span class="line">        newc-&gt;whandler = &amp;CSocekt::ngx_write_request_handler; <span class="comment">//设置数据发送时的写处理函数。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端应该主动发送第一次的数据，这里将读事件加入epoll监控，这样当客户端发送数据来时，会触发ngx_wait_request_handler()被ngx_epoll_process_events()调用        </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ngx_epoll_oper_event</span>(</span><br><span class="line">                                s,                  <span class="comment">//socekt句柄</span></span><br><span class="line">                                EPOLL_CTL_ADD,      <span class="comment">//事件类型，这里是增加</span></span><br><span class="line">                                EPOLLIN|EPOLLRDHUP, <span class="comment">//标志，这里代表要增加的标志,EPOLLIN：可读，EPOLLRDHUP：TCP连接的远端关闭或者半关闭 ，如果边缘触发模式可以增加 EPOLLET</span></span><br><span class="line">                                <span class="number">0</span>,                  <span class="comment">//对于事件类型为增加的，不需要这个参数</span></span><br><span class="line">                                newc                <span class="comment">//连接池中的连接</span></span><br><span class="line">                                ) == <span class="number">-1</span>)         </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//增加事件失败，失败日志在ngx_epoll_add_event中写过了，因此这里不多写啥；</span></span><br><span class="line">            <span class="built_in">ngx_close_connection</span>(newc);<span class="comment">//关闭socket,这种可以立即回收这个连接，无需延迟，因为其上还没有数据收发，谈不到业务逻辑因此无需延迟；</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_ifkickTimeCount == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AddToTimerQueue</span>(newc);</span><br><span class="line">        &#125;</span><br><span class="line">        ++m_onlineUserCount;  <span class="comment">//连入用户数量+1        </span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//一般就是循环一次就跳出去</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理TCP连接客户端发来的数据ngx-read-request-handler"><a href="#处理TCP连接客户端发来的数据ngx-read-request-handler" class="headerlink" title="处理TCP连接客户端发来的数据ngx_read_request_handler"></a>处理TCP连接客户端发来的数据ngx_read_request_handler</h3><p>引入一个消息头【结构】<code>STRUC_MSG_HEADER</code>，用来记录一些额外信息，<strong>可以用于处理过时包</strong><br>服务器 收包时，  收到： 包头+包体  ，我再额外附加一个消息头 ===》  消息头 + 包头 + 包体</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息头，引入的目的是当收到数据包时，额外记录一些内容以备将来使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRUC_MSG_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> pConn;         <span class="comment">//记录对应的链接，注意这是个指针</span></span><br><span class="line">    <span class="keyword">uint64_t</span>           iCurrsequence; <span class="comment">//收到数据包时记录对应连接的序号，将来能用于比较是否连接已经作废用</span></span><br><span class="line">    <span class="comment">//......其他以后扩展	</span></span><br><span class="line">&#125;STRUC_MSG_HEADER,*LPSTRUC_MSG_HEADER;</span><br></pre></td></tr></table></figure>

<p>对于连接池的每个连接都是有一个序号iCurrsequence，连接初始化的时候++iCurrsequence，连接释放的时候++iCurrsequence，因此当收到一个包的时候，将连接连接池的序号iCurrsequence记录在包的消息头中，当处理完这个包后想要发回给客户端的时候可以比较一下包的iCurrsequence与连接池的iCurrsequence是否一致，如果不一致说明连接已经断开了，丢弃即可。</p>
<p>因此我们需要new一块新内存专门用来存取<code>消息头 + 包头 + 包体</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来数据时候的处理，当连接上有数据来的时候，本函数会被ngx_epoll_process_events()所调用  ,官方的类似函数为ngx_http_wait_request_handler();</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_read_request_handler</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">bool</span> isflood = <span class="literal">false</span>; <span class="comment">//是否flood攻击；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//收包，注意我们用的第二个和第三个参数，我们用的始终是这两个参数，因此我们必须保证 c-&gt;precvbuf指向正确的收包位置，保证c-&gt;irecvlen指向正确的收包宽度</span></span><br><span class="line">    <span class="keyword">ssize_t</span> reco = <span class="built_in">recvproc</span>(pConn,pConn-&gt;precvbuf,pConn-&gt;irecvlen); </span><br><span class="line">    <span class="keyword">if</span>(reco &lt;= <span class="number">0</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//该处理的上边这个recvproc()函数处理过了，这里&lt;=0是直接return        </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里，说明成功收到了一些字节（&gt;0），就要开始判断收到了多少数据了     </span></span><br><span class="line">    <span class="keyword">if</span>(pConn-&gt;curStat == _PKG_HD_INIT) <span class="comment">//连接建立起来时肯定是这个状态，因为在ngx_get_connection()中已经把curStat成员赋值成_PKG_HD_INIT了</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span>(reco == m_iLenPkgHeader)<span class="comment">//正好收到完整包头，这里拆解包头</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="built_in">ngx_wait_request_handler_proc_p1</span>(pConn,isflood); <span class="comment">//那就调用专门针对包头处理完整的函数去处理把。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//收到的包头不完整--我们不能预料每个包的长度，也不能预料各种拆包/粘包情况，所以收到不完整包头【也算是缺包】是很可能的；</span></span><br><span class="line">            pConn-&gt;curStat        = _PKG_HD_RECVING;                 <span class="comment">//接收包头中，包头不完整，继续接收包头中	</span></span><br><span class="line">            pConn-&gt;precvbuf       = pConn-&gt;precvbuf + reco;              <span class="comment">//注意收后续包的内存往后走</span></span><br><span class="line">            pConn-&gt;irecvlen       = pConn-&gt;irecvlen - reco;              <span class="comment">//要收的内容当然要减少，以确保只收到完整的包头先</span></span><br><span class="line">        &#125; <span class="comment">//end  if(reco == m_iLenPkgHeader)</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pConn-&gt;curStat == _PKG_HD_RECVING) <span class="comment">//接收包头中，包头不完整，继续接收中，这个条件才会成立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pConn-&gt;irecvlen == reco) <span class="comment">//要求收到的宽度和我实际收到的宽度相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//包头收完整了</span></span><br><span class="line">            <span class="built_in">ngx_wait_request_handler_proc_p1</span>(pConn,isflood); <span class="comment">//那就调用专门针对包头处理完整的函数去处理把。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//包头还是没收完整，继续收包头</span></span><br><span class="line">            <span class="comment">//pConn-&gt;curStat        = _PKG_HD_RECVING;                 //没必要</span></span><br><span class="line">            pConn-&gt;precvbuf       = pConn-&gt;precvbuf + reco;              <span class="comment">//注意收后续包的内存往后走</span></span><br><span class="line">            pConn-&gt;irecvlen       = pConn-&gt;irecvlen - reco;              <span class="comment">//要收的内容当然要减少，以确保只收到完整的包头先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pConn-&gt;curStat == _PKG_BD_INIT) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//包头刚好收完，准备接收包体</span></span><br><span class="line">        <span class="keyword">if</span>(reco == pConn-&gt;irecvlen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//收到的宽度等于要收的宽度，包体也收完整了</span></span><br><span class="line">            <span class="keyword">if</span>(m_floodAkEnable == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Flood攻击检测是否开启</span></span><br><span class="line">                isflood = <span class="built_in">TestFlood</span>(pConn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ngx_wait_request_handler_proc_plast</span>(pConn,isflood);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//收到的宽度小于要收的宽度</span></span><br><span class="line">            pConn-&gt;curStat = _PKG_BD_RECVING;					</span><br><span class="line">            pConn-&gt;precvbuf = pConn-&gt;precvbuf + reco;</span><br><span class="line">            pConn-&gt;irecvlen = pConn-&gt;irecvlen - reco;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pConn-&gt;curStat == _PKG_BD_RECVING) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//接收包体中，包体不完整，继续接收中</span></span><br><span class="line">        <span class="keyword">if</span>(pConn-&gt;irecvlen == reco)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//包体收完整了</span></span><br><span class="line">            <span class="keyword">if</span>(m_floodAkEnable == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Flood攻击检测是否开启</span></span><br><span class="line">                isflood = <span class="built_in">TestFlood</span>(pConn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ngx_wait_request_handler_proc_plast</span>(pConn,isflood);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//包体没收完整，继续收</span></span><br><span class="line">            pConn-&gt;precvbuf = pConn-&gt;precvbuf + reco;</span><br><span class="line">            pConn-&gt;irecvlen = pConn-&gt;irecvlen - reco;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">//end if(c-&gt;curStat == _PKG_HD_INIT)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isflood == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//客户端flood服务器，则直接把客户端踢掉</span></span><br><span class="line">        <span class="comment">//ngx_log_stderr(errno,&quot;发现客户端flood，干掉该客户端!&quot;);</span></span><br><span class="line">        <span class="built_in">zdClosesocketProc</span>(pConn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个函数调用了<code>recvproc(pConn,pConn-&gt;precvbuf,pConn-&gt;irecvlen);</code>最多只能收pConn-&gt;irecvlen个字节</p>
<p>注意采用了状态机，非常的稳健！！</p>
<h4 id="recvproc"><a href="#recvproc" class="headerlink" title="recvproc"></a>recvproc</h4><p>四次挥手关闭连接，RST强制关闭连接，正常发包都能检测。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">recvproc(<span class="keyword">lpngx_connection_t</span> pConn,<span class="keyword">char</span> *buff,<span class="keyword">ssize_t</span> buflen)</span><br><span class="line">    n = recv(c-&gt;fd,buff,buflen,<span class="number">0</span>);</span><br><span class="line">    对返回值n判断，如果n的值异常，根据errno写相应日志或关闭socket，然后直接<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>  zdClosesocketProc(pConn);<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//正常四次挥手，关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)ngx_log_stderr;<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没有收到数据，不关闭连接</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)ngx_log_stderr;<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不算错误，不关闭连接</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//以下这种明显错误的必须关闭连接</span></span><br><span class="line">            <span class="keyword">if</span>(errno == ECONNRESET)<span class="keyword">do</span> nothing<span class="comment">//客户端没有四次挥手正常关闭socket连接，却关闭了整个运行程序，发RST包</span></span><br><span class="line">            <span class="keyword">else</span> ngx_log_stderr;<span class="comment">//不知道什么错误，直接打印出来</span></span><br><span class="line">            zdClosesocketProc(c);<span class="comment">//关闭socket连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是没有出现错误的</span></span><br><span class="line">    n&gt;<span class="number">0</span>,返回实际收到的字节数</span><br></pre></td></tr></table></figure>

<p>如果recv()有问题，这个函数会把该释放的释放好，该处理的处理好</p>
<p><strong>特别注意：</strong>所有从10行开始走下来的错误，都认为异常：意味着我们要关闭客户端套接字要回收连接池中连接；</p>
<p>一定要有严密的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收数据专用函数--引入这个函数是为了方便，如果断线，错误之类的，这里直接 释放连接池中连接，然后直接关闭socket，以免在其他函数中还要重复的干这些事</span></span><br><span class="line"><span class="comment">//参数c：连接池中相关连接</span></span><br><span class="line"><span class="comment">//参数buff：接收数据的缓冲区</span></span><br><span class="line"><span class="comment">//参数buflen：要接收的数据大小</span></span><br><span class="line"><span class="comment">//返回值：返回-1，则是有问题发生并且在这里把问题处理完毕了，调用本函数的调用者一般是可以直接return</span></span><br><span class="line"><span class="comment">//        返回&gt;0，则是表示实际收到的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">CSocekt::recvproc</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn,<span class="keyword">char</span> *buff,<span class="keyword">ssize_t</span> buflen)</span>  <span class="comment">//ssize_t是有符号整型，在32位机器上等同与int，在64位机器上等同与long int，size_t就是无符号型的ssize_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">recv</span>(pConn-&gt;fd, buff, buflen, <span class="number">0</span>); <span class="comment">//recv()系统函数， 最后一个参数flag，一般为0；     </span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//客户端关闭【应该是正常完成了4次挥手】，我这边就直接回收连接，关闭socket即可 </span></span><br><span class="line">        <span class="built_in">zdClosesocketProc</span>(pConn);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//客户端没断，走这里 </span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="comment">//这被认为有错误发生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//EAGAIN和EWOULDBLOCK[【这个应该常用在hp上】应该是一样的值，表示没收到数据，一般来讲，在ET模式下会出现这个错误，因为ET模式下是不停的recv肯定有一个时刻收到这个errno，但LT模式下一般是来事件才收，所以不该出现这个返回值</span></span><br><span class="line">        <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//我认为LT模式不该出现这个errno，而且这个其实也不是错误，所以不当做错误处理</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::recvproc()中errno == EAGAIN || errno == EWOULDBLOCK成立，出乎我意料！&quot;</span>);<span class="comment">//epoll为LT模式不应该出现这个返回值，所以直接打印出来瞧瞧</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不当做错误处理，只是简单返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//EINTR错误的产生：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。</span></span><br><span class="line">        <span class="comment">//例如：在socket服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使accept返回一个EINTR错误(被中断的系统调用)。</span></span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)  <span class="comment">//这个不算错误，是我参考官方nginx，官方nginx这个就不算错误；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//我认为LT模式不该出现这个errno，而且这个其实也不是错误，所以不当做错误处理</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::recvproc()中errno == EINTR成立，出乎我意料！&quot;</span>);<span class="comment">//epoll为LT模式不应该出现这个返回值，所以直接打印出来瞧瞧</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不当做错误处理，只是简单返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有从这里走下来的错误，都认为异常：意味着我们要关闭客户端套接字要回收连接池中连接；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//errno参考：http://dhfapiran1.360drm.com        </span></span><br><span class="line">        <span class="keyword">if</span>(errno == ECONNRESET)  <span class="comment">//#define ECONNRESET 104 /* Connection reset by peer */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果客户端没有正常关闭socket连接，却关闭了整个运行程序【真是够粗暴无理的，应该是直接给服务器发送rst包而不是4次挥手包完成连接断开】，那么会产生这个错误            </span></span><br><span class="line">            <span class="comment">//10054(WSAECONNRESET)--远程程序正在连接的时候关闭会产生这个错误--远程主机强迫关闭了一个现有的连接</span></span><br><span class="line">            <span class="comment">//算常规错误吧【普通信息型】，日志都不用打印，没啥意思，太普通的错误</span></span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//....一些大家遇到的很普通的错误信息，也可以往这里增加各种，代码要慢慢完善，一步到位，不可能，很多服务器程序经过很多年的完善才比较圆满；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//能走到这里的，都表示错误，我打印一下日志，希望知道一下是啥错误，我准备打印到屏幕上</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EBADF)  <span class="comment">// #define EBADF   9 /* Bad file descriptor */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//因为多线程，偶尔会干掉socket，所以不排除产生这个错误的可能性</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::recvproc()中发生错误，我打印出来看看是啥错误！&quot;</span>);  <span class="comment">//正式运营时可以考虑这些日志打印去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ngx_log_stderr(0,&quot;连接被客户端 非 正常关闭！&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这种真正的错误就要，直接关闭套接字，释放连接池中连接了</span></span><br><span class="line">        <span class="comment">//ngx_close_connection(pConn);</span></span><br><span class="line">        <span class="comment">//inRecyConnectQueue(pConn);</span></span><br><span class="line">        <span class="built_in">zdClosesocketProc</span>(pConn);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能走到这里的，就认为收到了有效数据</span></span><br><span class="line">    <span class="keyword">return</span> n; <span class="comment">//返回收到的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ngx-wait-request-handler-proc-p1"><a href="#ngx-wait-request-handler-proc-p1" class="headerlink" title="ngx_wait_request_handler_proc_p1"></a>ngx_wait_request_handler_proc_p1</h4><p>包头收完整后的处理，我们称为包处理阶段1</p>
<ul>
<li>1.判断包是否合法，若不合法则状态机恢复为_PKG_HD_INIT，并且连接池的缓冲区头指针重新指定为最开始的</li>
<li>2.那么<code>char *pTmpBuffer  = (char *)p_memory-&gt;AllocMemory(m_iLenMsgHeader + e_pkgLen,false);</code><strong>新分配一段内存</strong>并且将连接池的成员指针<code>pConn-&gt;precvMemPointer = pTmpBuffer;</code>指向这块内存（消息头加整个包长度的内存 ）</li>
<li>3.填写消息头的内容，把连接池中连接序号记录到消息头里来，连接池的连接指针也记录到消息头里</li>
<li>4.再填写包头内容，把包体内容拷贝到pTmpBuffer中</li>
<li>5.如果该报文只有包头无包体，调用ngx_wait_request_handler_proc_plast()收完整包后的处理函数。</li>
<li>6.如果该报文还需要继续收包体，修改状态机为_PKG_BD_INIT，并且连接池的缓冲区头指针指向包体。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包头收完整后的处理，我们称为包处理阶段1【p1】：写成函数，方便复用</span></span><br><span class="line"><span class="comment">//注意参数isflood是个引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_wait_request_handler_proc_p1</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn,<span class="keyword">bool</span> &amp;isflood)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();		</span><br><span class="line"></span><br><span class="line">    LPCOMM_PKG_HEADER pPkgHeader;</span><br><span class="line">    pPkgHeader = (LPCOMM_PKG_HEADER)pConn-&gt;dataHeadInfo; <span class="comment">//正好收到包头时，包头信息肯定是在dataHeadInfo里；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> e_pkgLen; </span><br><span class="line">    e_pkgLen = <span class="built_in">ntohs</span>(pPkgHeader-&gt;pkgLen);  <span class="comment">//注意这里网络序转本机序，所有传输到网络上的2字节数据，都要用htons()转成网络序，所有从网络上收到的2字节数据，都要用ntohs()转成本机序</span></span><br><span class="line">                                                <span class="comment">//ntohs/htons的目的就是保证不同操作系统数据之间收发的正确性，【不管客户端/服务器是什么操作系统，发送的数字是多少，收到的就是多少】                                               </span></span><br><span class="line">    <span class="comment">//恶意包或者错误包的判断</span></span><br><span class="line">    <span class="keyword">if</span>(e_pkgLen &lt; m_iLenPkgHeader) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//伪造包/或者包错误，否则整个包长怎么可能比包头还小？（整个包长是包头+包体，就算包体为0字节，那么至少e_pkgLen == m_iLenPkgHeader）</span></span><br><span class="line">        <span class="comment">//报文总长度 &lt; 包头长度，认定非法用户，废包</span></span><br><span class="line">        <span class="comment">//状态和接收位置都复原，这些值都有必要，因为有可能在其他状态比如_PKG_HD_RECVING状态调用这个函数；</span></span><br><span class="line">        pConn-&gt;curStat = _PKG_HD_INIT;      </span><br><span class="line">        pConn-&gt;precvbuf = pConn-&gt;dataHeadInfo;</span><br><span class="line">        pConn-&gt;irecvlen = m_iLenPkgHeader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e_pkgLen &gt; (_PKG_MAX_LENGTH<span class="number">-1000</span>))   <span class="comment">//客户端发来包居然说包长度 &gt; 29000?肯定是恶意包</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//恶意包，太大，认定非法用户，废包【包头中说这个包总长度这么大，这不行】</span></span><br><span class="line">        <span class="comment">//状态和接收位置都复原，这些值都有必要，因为有可能在其他状态比如_PKG_HD_RECVING状态调用这个函数；</span></span><br><span class="line">        pConn-&gt;curStat = _PKG_HD_INIT;</span><br><span class="line">        pConn-&gt;precvbuf = pConn-&gt;dataHeadInfo;</span><br><span class="line">        pConn-&gt;irecvlen = m_iLenPkgHeader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//合法的包头，继续处理</span></span><br><span class="line">        <span class="comment">//我现在要分配内存开始收包体，因为包体长度并不是固定的，所以内存肯定要new出来；</span></span><br><span class="line">        <span class="keyword">char</span> *pTmpBuffer  = (<span class="keyword">char</span> *)p_memory-&gt;<span class="built_in">AllocMemory</span>(m_iLenMsgHeader + e_pkgLen,<span class="literal">false</span>); <span class="comment">//分配内存【长度是 消息头长度  + 包头长度 + 包体长度】，最后参数先给false，表示内存不需要memset;        </span></span><br><span class="line">        pConn-&gt;precvMemPointer = pTmpBuffer;  <span class="comment">//内存开始指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a)先填写消息头内容</span></span><br><span class="line">        LPSTRUC_MSG_HEADER ptmpMsgHeader = (LPSTRUC_MSG_HEADER)pTmpBuffer;</span><br><span class="line">        ptmpMsgHeader-&gt;pConn = pConn;</span><br><span class="line">        ptmpMsgHeader-&gt;iCurrsequence = pConn-&gt;iCurrsequence; <span class="comment">//收到包时的连接池中连接序号记录到消息头里来，以备将来用；</span></span><br><span class="line">        <span class="comment">//b)再填写包头内容</span></span><br><span class="line">        pTmpBuffer += m_iLenMsgHeader;                 <span class="comment">//往后跳，跳过消息头，指向包头</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pTmpBuffer,pPkgHeader,m_iLenPkgHeader); <span class="comment">//直接把收到的包头拷贝进来</span></span><br><span class="line">        <span class="keyword">if</span>(e_pkgLen == m_iLenPkgHeader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//该报文只有包头无包体【我们允许一个包只有包头，没有包体】</span></span><br><span class="line">            <span class="comment">//这相当于收完整了，则直接入消息队列待后续业务逻辑线程去处理吧</span></span><br><span class="line">            <span class="keyword">if</span>(m_floodAkEnable == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Flood攻击检测是否开启</span></span><br><span class="line">                isflood = <span class="built_in">TestFlood</span>(pConn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ngx_wait_request_handler_proc_plast</span>(pConn,isflood);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//开始收包体，注意我的写法</span></span><br><span class="line">            pConn-&gt;curStat = _PKG_BD_INIT;                   <span class="comment">//当前状态发生改变，包头刚好收完，准备接收包体	   </span></span><br><span class="line">            pConn-&gt;precvbuf = pTmpBuffer + m_iLenPkgHeader;  <span class="comment">//pTmpBuffer指向包头，这里 + m_iLenPkgHeader后指向包体 weizhi</span></span><br><span class="line">            pConn-&gt;irecvlen = e_pkgLen - m_iLenPkgHeader;    <span class="comment">//e_pkgLen是整个包【包头+包体】大小，-m_iLenPkgHeader【包头】  = 包体</span></span><br><span class="line">        &#125;                       </span><br><span class="line">    &#125;  <span class="comment">//end if(e_pkgLen &lt; m_iLenPkgHeader) </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ngx-wait-request-handler-proc-plast"><a href="#ngx-wait-request-handler-proc-plast" class="headerlink" title="ngx_wait_request_handler_proc_plast"></a>ngx_wait_request_handler_proc_plast</h4><p>如果包没问题那么就加上消息头加入<strong>收包消息队列CThreadPool::m_MsgRecvq1ueue</strong>并触发线程处理消息，注意进入<br>并且要将<strong>当前连接的状态机</strong>恢复为_PKG_HD_INIT，并且连接池的缓冲区头指针重新指定为最开始的，且将precvMemPointer指针置为NULL（原先指向消息头加整个包的内存）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到一个完整包后的处理【plast表示最后阶段】，放到一个函数中，方便调用</span></span><br><span class="line"><span class="comment">//注意参数isflood是个引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_wait_request_handler_proc_plast</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn,<span class="keyword">bool</span> &amp;isflood)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isflood == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_threadpool.<span class="built_in">inMsgRecvQueueAndSignal</span>(pConn-&gt;precvMemPointer); <span class="comment">//入消息队列并触发线程处理消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对于有攻击倾向的恶人，先把他的包丢掉</span></span><br><span class="line">        CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(pConn-&gt;precvMemPointer); <span class="comment">//直接释放掉内存，根本不往消息队列入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pConn-&gt;precvMemPointer = <span class="literal">NULL</span>;</span><br><span class="line">    pConn-&gt;curStat         = _PKG_HD_INIT;     <span class="comment">//收包状态机的状态恢复为原始态，为收下一个包做准备                    </span></span><br><span class="line">    pConn-&gt;precvbuf        = pConn-&gt;dataHeadInfo;  <span class="comment">//设置好收包的位置</span></span><br><span class="line">    pConn-&gt;irecvlen        = m_iLenPkgHeader;  <span class="comment">//设置好要接收数据的大小</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inMsgRecvQueueAndSignal"><a href="#inMsgRecvQueueAndSignal" class="headerlink" title="inMsgRecvQueueAndSignal"></a>inMsgRecvQueueAndSignal</h4><p>注意传入的参数是消息头+包头+包体，这是另外new出来的一块内存</p>
<p>将这一个完整消息放入<strong>线程池中的线程</strong>的<strong>收包的消息队列</strong>里去</p>
<p>并且调用Call<strong>激发线程来干活</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到一个完整消息后，入消息队列，并触发线程池中线程来处理该消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CThreadPool::inMsgRecvQueueAndSignal</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//互斥</span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="built_in">pthread_mutex_lock</span>(&amp;m_pthreadMutex);     </span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::inMsgRecvQueueAndSignal()pthread_mutex_lock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    m_MsgRecvQueue.<span class="built_in">push_back</span>(buf);	         <span class="comment">//入消息队列</span></span><br><span class="line">    ++m_iRecvMsgQueueCount;                  <span class="comment">//收消息队列数字+1，个人认为用变量更方便一点，比 m_MsgRecvQueue.size()高效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消互斥</span></span><br><span class="line">    err = <span class="built_in">pthread_mutex_unlock</span>(&amp;m_pthreadMutex);   </span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::inMsgRecvQueueAndSignal()pthread_mutex_unlock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以激发一个线程来干活了</span></span><br><span class="line">    <span class="built_in">Call</span>();                                  </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>pthread_cond_signal唤醒一个等待该条件的线程，也就是可以唤醒卡在<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex)</code>的线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( (pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">size</span>() == <span class="number">0</span>) &amp;&amp; m_shutdown == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pThread-&gt;ifrunning == <span class="literal">false</span>)            </span><br><span class="line">        pThread-&gt;ifrunning = <span class="literal">true</span>; </span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;m_pthreadCond, &amp;m_pthreadMutex); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果拿得到消息即<code>m_MsgRecvQueue.size()</code>大小不为0，那么其中1个线程就可以拿到锁并且退出while循环，退出while循环去取消息并且调用相应的消息处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来任务了，调一个线程池中的线程下来干活</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CThreadPool::Call</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="built_in">pthread_cond_signal</span>(&amp;m_pthreadCond); <span class="comment">//唤醒一个等待该条件的线程，也就是可以唤醒卡在pthread_cond_wait()的线程</span></span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这是有问题啊，要打印日志啊</span></span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::Call()中pthread_cond_signal()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(1)如果当前的工作线程全部都忙，则要报警</span></span><br><span class="line">    <span class="comment">//bool ifallthreadbusy = false;</span></span><br><span class="line">    <span class="keyword">if</span>(m_iThreadNum == m_iRunningThreadNum) <span class="comment">//线程池中线程总量，跟当前正在干活的线程数量一样，说明所有线程都忙碌起来，线程不够用了</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">//线程不够用了</span></span><br><span class="line">        <span class="comment">//ifallthreadbusy = true;</span></span><br><span class="line">        <span class="keyword">time_t</span> currtime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(currtime - m_iLastEmgTime &gt; <span class="number">10</span>) <span class="comment">//最少间隔10秒钟才报一次线程池中线程不够用的问题；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两次报告之间的间隔必须超过10秒，不然如果一直出现当前工作线程全忙，但频繁报告日志也够烦的</span></span><br><span class="line">            m_iLastEmgTime = currtime;  <span class="comment">//更新时间</span></span><br><span class="line">            <span class="comment">//写日志，通知这种紧急情况给用户，用户要考虑增加线程池中线程数量了</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CThreadPool::Call()中发现线程池中当前空闲线程数量为0，要考虑扩容线程池了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//end if </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理TCP连接发送数据"><a href="#处理TCP连接发送数据" class="headerlink" title="处理TCP连接发送数据"></a>处理TCP连接发送数据</h3><p><strong>什么叫socekt可写？</strong><br>每一个tcp连接(socket)，都会有一个接收缓冲区 和 一个发送缓冲；<br>发送缓冲区缺省大小一般10几k，接收缓冲区大概几十k，setsocketopt()来设置；</p>
<p>send()【Windows端】,write()【linux】发送数据时，实际上这两个函数是把数据放到了发送缓冲区，之后这两个函数返回了；【这两个函数执行成功不代表客户端已经成功收到数据，只有在客户端用了recv()或read()收到数据后，告诉服务器已经确认收到了数据，这样服务器才会把发送缓冲区中这些数据清空】</p>
<p>如果服务器端的发送 缓冲区满了，那么服务器再调用send(),write()发送数据的时候，那么send(),write()函数就会返回一个EAGAIN；；EAGAIN不是一个错误，只是示意发送缓冲区已经满了，迟一些再调用send(),write()来发送数据吧；</p>
<p>针对 当socket可写的时候【发送缓冲区没满】，会不停的触发socket可写事件 ,我们提出两种解决方案【重要】；</p>
<p>两种解决方案，来自网络,意义在于我们可以通过这种解决方案来指导我们写代码；</p>
<ul>
<li>第一种最普遍的解决方案:</li>
</ul>
<p>需要向socket写数据的时候把socket写事件通知加入到epoll中，等待可写事件，当可写事件来时操作系统会通知咱们；此时咱们可以调用wirte/send函数发送数据，当发送数据完毕后，把socket的写事件通知从红黑树中移除；<br>缺点：即使发送很少的数据，也需要把事件通知加入到epoll，写完毕后，有需要把写事件通知从红黑树干掉,对效率有一定的影响【有一定的操作代价】</p>
<ul>
<li>改进方案：</li>
</ul>
<p>开始不把socket写事件通知加入到epoll,当我需要写数据的时候，<strong>直接调用write/send发送数据</strong>，如果能全部发送完那么最好；</p>
<p>但如果<strong>发送缓冲区满了send()返回了EAGIN</strong>无法一次性全部发送完，此时，我再把写事件通知加入到epoll，此时，就变成了在epoll驱动下写数据</p>
<p>当发送缓冲区可写（即有空间了）的时候，ngx_epoll_process_events函数中epoll_wait会通知有可写事件，这个时候我们调用ngx_write_request_handler来处理可写事件，当全部数据发送完毕后，再把写事件通知从epoll中干掉；</p>
<p>优点：数据不多的时候，可以避免epoll的写事件的增加/删除，提高了程序的执行效率；</p>
<h4 id="msgSend待发送消息入到发消息队列"><a href="#msgSend待发送消息入到发消息队列" class="headerlink" title="msgSend待发送消息入到发消息队列"></a>msgSend待发送消息入到发消息队列</h4><p>主要的逻辑：</p>
<p>1.CSocket::m_MsgSendQueue.push_back(psendbuf);将消息放入<strong>待发包消息队列</strong>中</p>
<p>2.sem_post(&amp;m_semEventSendQueue)让ServerSendQueueThread()流程走下来干活</p>
<p><strong>同步原理：</strong></p>
<p><code>CSocekt::Initialize_subproc</code>函数中初始化调用<code>sem_init(&amp;m_semEventSendQueue,0,0)</code>对此信号量进行初始化为0。</p>
<p>sem_wait()：测试指定信号量的值，如果该值&gt;0，那么将该值<strong>减1</strong>然后该函数立即返回；如果该值 等于0，那么该线程将投入睡眠中，一直到该值&gt;0，这个时候  那么将该值<strong>减1</strong>然后该函数立即返回；  </p>
<p>semd_post()：能够将指定信号量值<strong>加1</strong>，即便当前没有其他线程在等待该信号量值也没关系；这也就保证了信号量不会丢失</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个待发送消息入到发消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::msgSend</span><span class="params">(<span class="keyword">char</span> *psendbuf)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_sendMessageQueueMutex)</span></span>;  <span class="comment">//互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息队列过大也可能给服务器带来风险</span></span><br><span class="line">    <span class="keyword">if</span>(m_iSendMsgQueueCount &gt; <span class="number">50000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发送队列过大，比如客户端恶意不接受数据，就会导致这个队列越来越大</span></span><br><span class="line">        <span class="comment">//那么可以考虑为了服务器安全，干掉一些数据的发送，虽然有可能导致客户端出现问题，但总比服务器不稳定要好很多</span></span><br><span class="line">        m_iDiscardSendPkgCount++;</span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(psendbuf);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总体数据并无风险，不会导致服务器崩溃，要看看个体数据，找一下恶意者了    </span></span><br><span class="line">    LPSTRUC_MSG_HEADER pMsgHeader = (LPSTRUC_MSG_HEADER)psendbuf;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn = pMsgHeader-&gt;pConn;</span><br><span class="line">    <span class="keyword">if</span>(p_Conn-&gt;iSendCount &gt; <span class="number">400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该用户收消息太慢【或者干脆不收消息】，累积的该用户的发送队列中有的数据条目数过大，认为是恶意用户，直接切断</span></span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::msgSend()中发现某用户%d积压了大量待发送数据包，切断与他的连接！&quot;</span>,p_Conn-&gt;fd);      </span><br><span class="line">        m_iDiscardSendPkgCount++;</span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(psendbuf);</span><br><span class="line">        <span class="built_in">zdClosesocketProc</span>(p_Conn); <span class="comment">//直接关闭</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++p_Conn-&gt;iSendCount; <span class="comment">//发送队列中有的数据条目数+1；</span></span><br><span class="line">    m_MsgSendQueue.<span class="built_in">push_back</span>(psendbuf);     </span><br><span class="line">    ++m_iSendMsgQueueCount;   <span class="comment">//原子操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将信号量的值+1,这样其他卡在sem_wait的就可以走下去</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_post</span>(&amp;m_semEventSendQueue)==<span class="number">-1</span>)  <span class="comment">//让ServerSendQueueThread()流程走下来干活</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::msgSend()中sem_post(&amp;m_semEventSendQueue)失败.&quot;</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServerSendQueueThread处理发送消息队列的线程"><a href="#ServerSendQueueThread处理发送消息队列的线程" class="headerlink" title="ServerSendQueueThread处理发送消息队列的线程*"></a>ServerSendQueueThread处理发送消息队列的线程*</h4><p>pthread_mutex_lock(&amp;pSocketObj-&gt;m_sendMessageQueueMutex); //因为我们要操作发送消息对列</p>
<p>发送消息，如果发送缓冲区满了，则需要通过epoll事件来驱动消息的继续发送，所以如果发送缓冲区满，则用这个连接池成员变量<code>ngx_connection_s::atomic&lt;int&gt;iThrowsendCount;</code>标记是依靠epoll来驱动的</p>
<ul>
<li>1.sendsize&gt;0且成功发送了整个包的所有数据，一下就发送出去这很顺利，那么把堆里面的存放消息的那块内存释放掉即可</li>
<li>2.sendsize&gt;0但是没有全部发送完毕(EAGAIN)，数据只发出去了一部分，但肯定是因为 发送缓冲区满了，EPOLL_MOD给当前连接增加一个监听可写事件</li>
<li>3.sendsize == 0对方断开了，对方断开这个事件属于可读事件，会再recvproc函数中处理</li>
<li>4.sendsize == -1表明 errno == EAGAIN ，服务器的发送缓冲区满了，那么和第2种清空一样，需要通过EPOLL_MOD给当前连接增加一个监听可写事件</li>
<li>5.sendsize == -2，一般我认为都是对端断开的错误，对端断开需要把堆里面的存放消息的那块内存释放掉即可，操作系统会帮我们将这个socket连接从红黑树中移除掉</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理发送消息队列的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CSocekt::ServerSendQueueThread</span><span class="params">(<span class="keyword">void</span>* threadData)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ThreadItem *pThread = <span class="keyword">static_cast</span>&lt;ThreadItem*&gt;(threadData);</span><br><span class="line">    CSocekt *pSocketObj = pThread-&gt;_pThis;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    std::list &lt;<span class="keyword">char</span> *&gt;::iterator pos,pos2,posend;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *pMsgBuf;	</span><br><span class="line">    LPSTRUC_MSG_HEADER	pMsgHeader;</span><br><span class="line">    LPCOMM_PKG_HEADER   pPkgHeader;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span>  p_Conn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>      itmp;</span><br><span class="line">    <span class="keyword">ssize_t</span>             sendsize;  </span><br><span class="line"></span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(g_stopEvent == <span class="number">0</span>) <span class="comment">//不退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果信号量值&gt;0，则 -1(减1) 并走下去，否则卡这里卡着【为了让信号量值+1，可以在其他线程调用sem_post达到，实际上在CSocekt::msgSend()调用sem_post就达到了让这里sem_wait走下去的目的】</span></span><br><span class="line">        <span class="comment">//******如果被某个信号中断，sem_wait也可能过早的返回，错误为EINTR；</span></span><br><span class="line">        <span class="comment">//整个程序退出之前，也要sem_post()一下，确保如果本线程卡在sem_wait()，也能走下去从而让本线程成功返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_wait</span>(&amp;pSocketObj-&gt;m_semEventSendQueue) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//失败？及时报告，其他的也不好干啥</span></span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) <span class="comment">//这个我就不算个错误了【当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。】</span></span><br><span class="line">                <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ServerSendQueueThread()中sem_wait(&amp;pSocketObj-&gt;m_semEventSendQueue)失败.&quot;</span>);            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般走到这里都表示需要处理数据收发了</span></span><br><span class="line">        <span class="keyword">if</span>(g_stopEvent != <span class="number">0</span>)  <span class="comment">//要求整个进程退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pSocketObj-&gt;m_iSendMsgQueueCount &gt; <span class="number">0</span>) <span class="comment">//原子的 </span></span><br><span class="line">        &#123;</span><br><span class="line">            err = <span class="built_in">pthread_mutex_lock</span>(&amp;pSocketObj-&gt;m_sendMessageQueueMutex); <span class="comment">//因为我们要操作发送消息对列m_MsgSendQueue，所以这里要临界            </span></span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>) <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerSendQueueThread()中pthread_mutex_lock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line"></span><br><span class="line">            pos    = pSocketObj-&gt;m_MsgSendQueue.<span class="built_in">begin</span>();</span><br><span class="line">            posend = pSocketObj-&gt;m_MsgSendQueue.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pos != posend)</span><br><span class="line">            &#123;</span><br><span class="line">                pMsgBuf = (*pos);                          <span class="comment">//拿到的每个消息都是 消息头+包头+包体【但要注意，我们是不发送消息头给客户端的】</span></span><br><span class="line">                pMsgHeader = (LPSTRUC_MSG_HEADER)pMsgBuf;  <span class="comment">//指向消息头</span></span><br><span class="line">                pPkgHeader = (LPCOMM_PKG_HEADER)(pMsgBuf+pSocketObj-&gt;m_iLenMsgHeader);	<span class="comment">//指向包头</span></span><br><span class="line">                p_Conn = pMsgHeader-&gt;pConn;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//包过期，因为如果 这个连接被回收，比如在ngx_close_connection(),inRecyConnectQueue()中都会自增iCurrsequence</span></span><br><span class="line">                     <span class="comment">//而且这里有没必要针对 本连接 来用m_connectionMutex临界 ,只要下面条件成立，肯定是客户端连接已断，要发送的数据肯定不需要发送了</span></span><br><span class="line">                <span class="keyword">if</span>(p_Conn-&gt;iCurrsequence != pMsgHeader-&gt;iCurrsequence) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//本包中保存的序列号与p_Conn【连接池中连接】中实际的序列号已经不同，丢弃此消息，小心处理该消息的删除</span></span><br><span class="line">                    pos2=pos;</span><br><span class="line">                    pos++;</span><br><span class="line">                    pSocketObj-&gt;m_MsgSendQueue.<span class="built_in">erase</span>(pos2);</span><br><span class="line">                    --pSocketObj-&gt;m_iSendMsgQueueCount; <span class="comment">//发送消息队列容量少1		</span></span><br><span class="line">                    p_memory-&gt;<span class="built_in">FreeMemory</span>(pMsgBuf);	</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="comment">//end if</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(p_Conn-&gt;iThrowsendCount &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//靠系统驱动来发送消息，所以这里不能再发送</span></span><br><span class="line">                    pos++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --p_Conn-&gt;iSendCount;   <span class="comment">//发送队列中有的数据条目数-1；</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">//走到这里，可以发送消息，一些必须的信息记录，要发送的东西也要从发送队列里干掉</span></span><br><span class="line">                p_Conn-&gt;psendMemPointer = pMsgBuf;      <span class="comment">//发送后释放用的，因为这段内存是new出来的</span></span><br><span class="line">                pos2=pos;</span><br><span class="line">                pos++;</span><br><span class="line">                pSocketObj-&gt;m_MsgSendQueue.<span class="built_in">erase</span>(pos2);</span><br><span class="line">                --pSocketObj-&gt;m_iSendMsgQueueCount;      <span class="comment">//发送消息队列容量少1	</span></span><br><span class="line">                p_Conn-&gt;psendbuf = (<span class="keyword">char</span> *)pPkgHeader;   <span class="comment">//要发送的数据的缓冲区指针，因为发送数据不一定全部都能发送出去，我们要记录数据发送到了哪里，需要知道下次数据从哪里开始发送</span></span><br><span class="line">                itmp = <span class="built_in">ntohs</span>(pPkgHeader-&gt;pkgLen);        <span class="comment">//包头+包体 长度 ，打包时用了htons【本机序转网络序】，所以这里为了得到该数值，用了个ntohs【网络序转本机序】；</span></span><br><span class="line">                p_Conn-&gt;isendlen = itmp;                 <span class="comment">//要发送多少数据，因为发送数据不一定全部都能发送出去，我们需要知道剩余有多少数据还没发送</span></span><br><span class="line">                                </span><br><span class="line">                <span class="comment">//这里是重点，我们采用 epoll水平触发的策略，能走到这里的，都应该是还没有投递 写事件 到epoll中</span></span><br><span class="line">                    <span class="comment">//epoll水平触发发送数据的改进方案：</span></span><br><span class="line">                    <span class="comment">//开始不把socket写事件通知加入到epoll,当我需要写数据的时候，直接调用write/send发送数据；</span></span><br><span class="line">                    <span class="comment">//如果返回了EAGIN【发送缓冲区满了，需要等待可写事件才能继续往缓冲区里写数据】，此时，我再把写事件通知加入到epoll，</span></span><br><span class="line">                    <span class="comment">//此时，就变成了在epoll驱动下写数据，全部数据发送完毕后，再把写事件通知从epoll中干掉；</span></span><br><span class="line">                    <span class="comment">//优点：数据不多的时候，可以避免epoll的写事件的增加/删除，提高了程序的执行效率；                         </span></span><br><span class="line">                <span class="comment">//(1)直接调用write或者send发送数据</span></span><br><span class="line">                <span class="comment">//ngx_log_stderr(errno,&quot;即将发送数据%ud。&quot;,p_Conn-&gt;isendlen);</span></span><br><span class="line"></span><br><span class="line">                sendsize = pSocketObj-&gt;<span class="built_in">sendproc</span>(p_Conn,p_Conn-&gt;psendbuf,p_Conn-&gt;isendlen); <span class="comment">//注意参数</span></span><br><span class="line">                <span class="keyword">if</span>(sendsize &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;                    </span><br><span class="line">                    <span class="keyword">if</span>(sendsize == p_Conn-&gt;isendlen) <span class="comment">//成功发送出去了数据，一下就发送出去这很顺利</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//成功发送的和要求发送的数据相等，说明全部发送成功了 发送缓冲区去了【数据全部发完】</span></span><br><span class="line">                        p_memory-&gt;<span class="built_in">FreeMemory</span>(p_Conn-&gt;psendMemPointer);  <span class="comment">//释放内存</span></span><br><span class="line">                        p_Conn-&gt;psendMemPointer = <span class="literal">NULL</span>;</span><br><span class="line">                        p_Conn-&gt;iThrowsendCount = <span class="number">0</span>;  <span class="comment">//这行其实可以没有，因此此时此刻这东西就是=0的                        </span></span><br><span class="line">                        <span class="comment">//ngx_log_stderr(0,&quot;CSocekt::ServerSendQueueThread()中数据发送完毕，很好。&quot;); //做个提示吧，商用时可以干掉</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>  <span class="comment">//没有全部发送完毕(EAGAIN)，数据只发出去了一部分，但肯定是因为 发送缓冲区满了,那么</span></span><br><span class="line">                    &#123;                        </span><br><span class="line">                        <span class="comment">//发送到了哪里，剩余多少，记录下来，方便下次sendproc()时使用</span></span><br><span class="line">                        p_Conn-&gt;psendbuf = p_Conn-&gt;psendbuf + sendsize;</span><br><span class="line">                        p_Conn-&gt;isendlen = p_Conn-&gt;isendlen - sendsize;	</span><br><span class="line">                        <span class="comment">//因为发送缓冲区慢了，所以 现在我要依赖系统通知来发送数据了</span></span><br><span class="line">                        ++p_Conn-&gt;iThrowsendCount;             <span class="comment">//标记发送缓冲区满了，需要通过epoll事件来驱动消息的继续发送【原子+1，且不可写成p_Conn-&gt;iThrowsendCount = p_Conn-&gt;iThrowsendCount +1 ，这种写法不是原子+1】</span></span><br><span class="line">                        <span class="comment">//投递此事件后，我们将依靠epoll驱动调用ngx_write_request_handler()函数发送数据</span></span><br><span class="line">                        <span class="keyword">if</span>(pSocketObj-&gt;<span class="built_in">ngx_epoll_oper_event</span>(</span><br><span class="line">                                p_Conn-&gt;fd,         <span class="comment">//socket句柄</span></span><br><span class="line">                                EPOLL_CTL_MOD,      <span class="comment">//事件类型，这里是增加【因为我们准备增加个写通知】</span></span><br><span class="line">                                EPOLLOUT,           <span class="comment">//标志，这里代表要增加的标志,EPOLLOUT：可写【可写的时候通知我】</span></span><br><span class="line">                                <span class="number">0</span>,                  <span class="comment">//对于事件类型为增加的，EPOLL_CTL_MOD需要这个参数, 0：增加   1：去掉 2：完全覆盖</span></span><br><span class="line">                                p_Conn              <span class="comment">//连接池中的连接</span></span><br><span class="line">                                ) == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//有这情况发生？这可比较麻烦，不过先do nothing</span></span><br><span class="line">                            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ServerSendQueueThread()ngx_epoll_oper_event()失败.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//ngx_log_stderr(errno,&quot;CSocekt::ServerSendQueueThread()中数据没发送完毕【发送缓冲区满】，整个要发送%d，实际发送了%d。&quot;,p_Conn-&gt;isendlen,sendsize);</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="comment">//end if(sendsize &gt; 0)</span></span><br><span class="line">                    <span class="keyword">continue</span>;  <span class="comment">//继续处理其他消息                    </span></span><br><span class="line">                &#125;  <span class="comment">//end if(sendsize &gt; 0)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//能走到这里，应该是有点问题的</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sendsize == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//发送0个字节，首先因为我发送的内容不是0个字节的；</span></span><br><span class="line">                    <span class="comment">//然后如果发送 缓冲区满则返回的应该是-1，而错误码应该是EAGAIN，所以我综合认为，这种情况我就把这个发送的包丢弃了【按对端关闭了socket处理】</span></span><br><span class="line">                    <span class="comment">//这个打印下日志，我还真想观察观察是否真有这种现象发生</span></span><br><span class="line">                    <span class="comment">//ngx_log_stderr(errno,&quot;CSocekt::ServerSendQueueThread()中sendproc()居然返回0？&quot;); //如果对方关闭连接出现send=0，那么这个日志可能会常出现，商用时就 应该干掉</span></span><br><span class="line">                    <span class="comment">//然后这个包干掉，不发送了</span></span><br><span class="line">                    p_memory-&gt;<span class="built_in">FreeMemory</span>(p_Conn-&gt;psendMemPointer);  <span class="comment">//释放内存</span></span><br><span class="line">                    p_Conn-&gt;psendMemPointer = <span class="literal">NULL</span>;</span><br><span class="line">                    p_Conn-&gt;iThrowsendCount = <span class="number">0</span>;  <span class="comment">//这行其实可以没有，因此此时此刻这东西就是=0的    </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//能走到这里，继续处理问题</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sendsize == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//发送缓冲区已经满了【一个字节都没发出去，说明发送 缓冲区当前正好是满的】</span></span><br><span class="line">                    ++p_Conn-&gt;iThrowsendCount; <span class="comment">//标记发送缓冲区满了，需要通过epoll事件来驱动消息的继续发送</span></span><br><span class="line">                    <span class="comment">//投递此事件后，我们将依靠epoll驱动调用ngx_write_request_handler()函数发送数据</span></span><br><span class="line">                    <span class="keyword">if</span>(pSocketObj-&gt;<span class="built_in">ngx_epoll_oper_event</span>(</span><br><span class="line">                                p_Conn-&gt;fd,         <span class="comment">//socket句柄</span></span><br><span class="line">                                EPOLL_CTL_MOD,      <span class="comment">//事件类型，这里是增加【因为我们准备增加个写通知】</span></span><br><span class="line">                                EPOLLOUT,           <span class="comment">//标志，这里代表要增加的标志,EPOLLOUT：可写【可写的时候通知我】</span></span><br><span class="line">                                <span class="number">0</span>,                  <span class="comment">//对于事件类型为增加的，EPOLL_CTL_MOD需要这个参数, 0：增加   1：去掉 2：完全覆盖</span></span><br><span class="line">                                p_Conn              <span class="comment">//连接池中的连接</span></span><br><span class="line">                                ) == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//有这情况发生？这可比较麻烦，不过先do nothing</span></span><br><span class="line">                        <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ServerSendQueueThread()中ngx_epoll_add_event()_2失败.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//能走到这里的，应该就是返回值-2了，一般就认为对端断开了，等待recv()来做断开socket以及回收资源</span></span><br><span class="line">                    p_memory-&gt;<span class="built_in">FreeMemory</span>(p_Conn-&gt;psendMemPointer);  <span class="comment">//释放内存</span></span><br><span class="line">                    p_Conn-&gt;psendMemPointer = <span class="literal">NULL</span>;</span><br><span class="line">                    p_Conn-&gt;iThrowsendCount = <span class="number">0</span>;  <span class="comment">//这行其实可以没有，因此此时此刻这东西就是=0的  </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="comment">//end while(pos != posend)</span></span><br><span class="line"></span><br><span class="line">            err = <span class="built_in">pthread_mutex_unlock</span>(&amp;pSocketObj-&gt;m_sendMessageQueueMutex); </span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>)  <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerSendQueueThread()pthread_mutex_unlock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="comment">//if(pSocketObj-&gt;m_iSendMsgQueueCount &gt; 0)</span></span><br><span class="line">    &#125; <span class="comment">//end while</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sendproc发送数据专用函数"><a href="#sendproc发送数据专用函数" class="headerlink" title="sendproc发送数据专用函数"></a>sendproc发送数据专用函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据专用函数，返回本次发送的字节数</span></span><br><span class="line"><span class="comment">//返回 &gt; 0，成功发送了一些字节</span></span><br><span class="line"><span class="comment">//=0，估计对方断了</span></span><br><span class="line"><span class="comment">//-1，errno == EAGAIN ，本方发送缓冲区满了</span></span><br><span class="line"><span class="comment">//-2，errno != EAGAIN != EWOULDBLOCK != EINTR ，一般我认为都是对端断开的错误</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">CSocekt::sendproc</span><span class="params">(<span class="keyword">lpngx_connection_t</span> c,<span class="keyword">char</span> *buff,<span class="keyword">ssize_t</span> size)</span>  <span class="comment">//ssize_t是有符号整型，在32位机器上等同与int，在64位机器上等同与long int，size_t就是无符号型的ssize_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里参考借鉴了官方nginx函数ngx_unix_send()的写法</span></span><br><span class="line">    <span class="keyword">ssize_t</span>   n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">send</span>(c-&gt;fd, buff, size, <span class="number">0</span>); <span class="comment">//send()系统函数， 最后一个参数flag，一般为0； </span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="comment">//成功发送了一些数据</span></span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="comment">//发送成功一些数据，但发送了多少，我们这里不关心，也不需要再次send</span></span><br><span class="line">            <span class="comment">//这里有两种情况</span></span><br><span class="line">            <span class="comment">//(1) n == size也就是想发送多少都发送成功了，这表示完全发完毕了</span></span><br><span class="line">            <span class="comment">//(2) n &lt; size 没发送完毕，那肯定是发送缓冲区满了，所以也不必要重试发送，直接返回吧</span></span><br><span class="line">            <span class="keyword">return</span> n; <span class="comment">//返回本次发送的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//send()返回0？ 一般recv()返回0表示断开,send()返回0，我这里就直接返回0吧【让调用者处理】；我个人认为send()返回0，要么你发送的字节是0，要么对端可能断开。</span></span><br><span class="line">            <span class="comment">//网上找资料：send=0表示超时，对方主动关闭了连接过程</span></span><br><span class="line">            <span class="comment">//我们写代码要遵循一个原则，连接断开，我们并不在send动作里处理诸如关闭socket这种动作，集中到recv那里处理，否则send,recv都处理都处理连接断开关闭socket则会乱套</span></span><br><span class="line">            <span class="comment">//连接断开epoll会通知并且 recvproc()里会处理，不在这里处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(errno == EAGAIN)  <span class="comment">//这东西应该等于EWOULDBLOCK</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//内核缓冲区满，这个不算错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//表示发送缓冲区满了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个应该也不算错误 ，收到某个信号导致send产生这个错误？</span></span><br><span class="line">            <span class="comment">//参考官方的写法，打印个日志，其他啥也没干，那就是等下次for循环重新send试一次了</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::sendproc()中send()失败.&quot;</span>);  <span class="comment">//打印个日志看看啥时候出这个错误</span></span><br><span class="line">            <span class="comment">//其他不需要做什么，等下次for循环吧            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//走到这里表示是其他错误码，都表示错误，错误我也不断开socket，我也依然等待recv()来统一处理断开，因为我是多线程，send()也处理断开，recv()也处理断开，很难处理好</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ngx-write-request-handler-epoll通知后就调用这个函数"><a href="#ngx-write-request-handler-epoll通知后就调用这个函数" class="headerlink" title="ngx_write_request_handler(epoll通知后就调用这个函数)*"></a>ngx_write_request_handler(epoll通知后就调用这个函数)*</h4><p>调用sendproc(pConn,pConn-&gt;psendbuf,pConn-&gt;isendlen);发送数据</p>
<ul>
<li>1.数据只发送了一部分，<strong>return返回</strong>，之后如果发送缓冲区可写epoll还会通知</li>
<li>2.成功的发送完了所有的数据，就用EPOLL_MOD参数将写事件通知给去掉，epoll将不会继续监听写事件</li>
<li>3.数据发送完毕那么就可以sem_post(&amp;m_semEventSendQueue)试着通知ServerSendQueueThread可以继续发送数据了</li>
<li>4.最后清空堆中存放消息的那块内存<strong>return返回</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置数据发送时的写处理函数,当数据可写时epoll通知我们，我们在 int CSocekt::ngx_epoll_process_events(int timer)  中调用此函数</span></span><br><span class="line"><span class="comment">//能走到这里，数据就是没法送完毕， 要继续发送</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_write_request_handler</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这些代码的书写可以参照 void* CSocekt::ServerSendQueueThread(void* threadData)</span></span><br><span class="line">    <span class="keyword">ssize_t</span> sendsize = <span class="built_in">sendproc</span>(pConn,pConn-&gt;psendbuf,pConn-&gt;isendlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendsize &gt; <span class="number">0</span> &amp;&amp; sendsize != pConn-&gt;isendlen)</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">//没有全部发送完毕，数据只发出去了一部分，那么发送到了哪里，剩余多少，继续记录，方便下次sendproc()时使用</span></span><br><span class="line">        pConn-&gt;psendbuf = pConn-&gt;psendbuf + sendsize;</span><br><span class="line">        pConn-&gt;isendlen = pConn-&gt;isendlen - sendsize;	</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sendsize == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这不太可能，可以发送数据时通知我发送数据，我发送时你却通知我发送缓冲区满？</span></span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ngx_write_request_handler()时if(sendsize == -1)成立，这很怪异。&quot;</span>); <span class="comment">//打印个日志，别的先不干啥</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendsize &gt; <span class="number">0</span> &amp;&amp; sendsize == pConn-&gt;isendlen) <span class="comment">//成功发送完毕，做个通知是可以的；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是成功的发送完毕数据，则把写事件通知从epoll中干掉吧；其他情况，那就是断线了，等着系统内核把连接从红黑树中干掉即可；</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ngx_epoll_oper_event</span>(</span><br><span class="line">                pConn-&gt;fd,          <span class="comment">//socket句柄</span></span><br><span class="line">                EPOLL_CTL_MOD,      <span class="comment">//事件类型，这里是修改【因为我们准备减去写通知】</span></span><br><span class="line">                EPOLLOUT,           <span class="comment">//标志，这里代表要减去的标志,EPOLLOUT：可写【可写的时候通知我】</span></span><br><span class="line">                <span class="number">1</span>,                  <span class="comment">//对于事件类型为增加的，EPOLL_CTL_MOD需要这个参数, 0：增加   1：去掉 2：完全覆盖</span></span><br><span class="line">                pConn               <span class="comment">//连接池中的连接</span></span><br><span class="line">                ) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有这情况发生？这可比较麻烦，不过先do nothing</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(errno,<span class="string">&quot;CSocekt::ngx_write_request_handler()中ngx_epoll_oper_event()失败。&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//ngx_log_stderr(0,&quot;CSocekt::ngx_write_request_handler()中数据发送完毕，很好。&quot;); //做个提示吧，商用时可以干掉</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能走下来的，要么数据发送完毕了，要么对端断开了，那么执行收尾工作吧；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据发送完毕，或者把需要发送的数据干掉，都说明发送缓冲区可能有地方了，让发送线程往下走判断能否发送新数据</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_post</span>(&amp;m_semEventSendQueue)==<span class="number">-1</span>)       </span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::ngx_write_request_handler()中sem_post(&amp;m_semEventSendQueue)失败.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_memory-&gt;<span class="built_in">FreeMemory</span>(pConn-&gt;psendMemPointer);  <span class="comment">//释放内存</span></span><br><span class="line">    pConn-&gt;psendMemPointer = <span class="literal">NULL</span>;        </span><br><span class="line">    --pConn-&gt;iThrowsendCount;  <span class="comment">//建议放在最后执行</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>该结构表示一个TCP连接【客户端主动发起的、Nginx服务器被动接受的TCP连接】，主要包含：</p>
<ol>
<li>套接字fd</li>
<li>连接序号</li>
<li>读写事件的处理函数</li>
<li>收包缓冲区和收包状态机</li>
<li>发包缓冲区</li>
</ol>
<h3 id="连接池类"><a href="#连接池类" class="headerlink" title="连接池类"></a>连接池类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下三个结构是非常重要的三个结构，我们遵从官方nginx的写法；</span></span><br><span class="line"><span class="comment">//(1)该结构表示一个TCP连接【客户端主动发起的、Nginx服务器被动接受的TCP连接】</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_connection_s</span></span></span><br><span class="line"><span class="class">&#123;</span>		</span><br><span class="line">    <span class="built_in">ngx_connection_s</span>();                                      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ngx_connection_s</span>();                             <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetOneToUse</span><span class="params">()</span></span>;                                      <span class="comment">//分配出去的时候初始化一些内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PutOneToFree</span><span class="params">()</span></span>;                                     <span class="comment">//回收回来的时候做一些事情</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>                       fd;                            <span class="comment">//套接字句柄socket</span></span><br><span class="line">    <span class="keyword">lpngx_listening_t</span>         listening;                     <span class="comment">//如果这个链接被分配给了一个监听套接字，那么这个里边就指向监听套接字对应的那个lpngx_listening_t的内存首地址		</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------	</span></span><br><span class="line">    <span class="comment">//unsigned                  instance:1;                    //【位域】失效标志位：0：有效，1：失效【这个是官方nginx提供，到底有什么用，ngx_epoll_process_events()中详解】  </span></span><br><span class="line">    <span class="keyword">uint64_t</span>                  iCurrsequence;                 <span class="comment">//我引入的一个序号，每次分配出去时+1，此法也有可能在一定程度上检测错包废包，具体怎么用，用到了再说</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>           <span class="title">s_sockaddr</span>;</span>                    <span class="comment">//保存对方地址信息用的</span></span><br><span class="line">    <span class="comment">//char                      addr_text[100]; //地址的文本信息，100足够，一般其实如果是ipv4地址，255.255.255.255，其实只需要20字节就够</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和读有关的标志-----------------------</span></span><br><span class="line">    <span class="comment">//uint8_t                   r_ready;        //读准备好标记【暂时没闹明白官方要怎么用，所以先注释掉】</span></span><br><span class="line">    <span class="comment">//uint8_t                   w_ready;        //写准备好标记</span></span><br><span class="line"></span><br><span class="line">    ngx_event_handler_pt      rhandler;                       <span class="comment">//读事件的相关处理方法</span></span><br><span class="line">    ngx_event_handler_pt      whandler;                       <span class="comment">//写事件的相关处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和epoll事件有关</span></span><br><span class="line">    <span class="keyword">uint32_t</span>                  events;                         <span class="comment">//和epoll事件有关  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和收包有关</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>             curStat;                        <span class="comment">//当前收包的状态</span></span><br><span class="line">    <span class="keyword">char</span>                      dataHeadInfo[_DATA_BUFSIZE_];   <span class="comment">//用于保存收到的数据的包头信息			</span></span><br><span class="line">    <span class="keyword">char</span>                      *precvbuf;                      <span class="comment">//接收数据的缓冲区的头指针，对收到不全的包非常有用，看具体应用的代码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              irecvlen;                       <span class="comment">//要收到多少数据，由这个变量指定，和precvbuf配套使用，看具体应用的代码</span></span><br><span class="line">    <span class="keyword">char</span>                      *precvMemPointer;               <span class="comment">//new出来的用于收包的内存首地址，释放用的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span>           logicPorcMutex;                 <span class="comment">//逻辑处理相关的互斥量      </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和发包有关</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt;          iThrowsendCount;                <span class="comment">//发送消息，如果发送缓冲区满了，则需要通过epoll事件来驱动消息的继续发送，所以如果发送缓冲区满，则用这个变量标记</span></span><br><span class="line">    <span class="keyword">char</span>                      *psendMemPointer;               <span class="comment">//发送完成后释放用的，整个数据的头指针，其实是 消息头 + 包头 + 包体</span></span><br><span class="line">    <span class="keyword">char</span>                      *psendbuf;                      <span class="comment">//发送数据的缓冲区的头指针，开始 其实是包头+包体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              isendlen;                       <span class="comment">//要发送多少数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和回收有关</span></span><br><span class="line">    <span class="keyword">time_t</span>                    inRecyTime;                     <span class="comment">//入到资源回收站里去的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和心跳包有关</span></span><br><span class="line">    <span class="keyword">time_t</span>                    lastPingTime;                   <span class="comment">//上次ping的时间【上次发送心跳包的事件】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//和网络安全有关	</span></span><br><span class="line">    <span class="keyword">uint64_t</span>                  FloodkickLastTime;              <span class="comment">//Flood攻击上次收到包的时间</span></span><br><span class="line">    <span class="keyword">int</span>                       FloodAttackCount;               <span class="comment">//Flood攻击在该时间内收到包的次数统计</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt;          iSendCount;                     <span class="comment">//发送队列中有的数据条目数，若client只发不收，则可能造成此数过大，依据此数做出踢出处理 </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span>        next;                           <span class="comment">//这是个指针，指向下一个本类型对象，用于把空闲的连接池对象串起来构成一个单向链表，方便取用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="initconnection初始化连接池"><a href="#initconnection初始化连接池" class="headerlink" title="initconnection初始化连接池"></a>initconnection初始化连接池</h3><p>连接池的所有连接都放入m_connectionList，空闲连接都放入m_freeconnectionList，以后要取空闲连接就从空闲连接中取得。注意两个存储连接的链表类型是list<lpngx_connection_t>，存储的是指针，指向具体连接池某一连接的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化连接池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::initconnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ilenconnpool = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_connection_t</span>);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_worker_connections; ++i) <span class="comment">//先创建这么多个连接，后续不够再增加</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_Conn = (<span class="keyword">lpngx_connection_t</span>)p_memory-&gt;<span class="built_in">AllocMemory</span>(ilenconnpool,<span class="literal">true</span>); <span class="comment">//清理内存 , 因为这里分配内存new char，无法执行构造函数，所以如下：</span></span><br><span class="line">        <span class="comment">//手工调用构造函数，因为AllocMemory里无法调用构造函数</span></span><br><span class="line">        p_Conn = <span class="built_in"><span class="keyword">new</span></span>(p_Conn) <span class="built_in">ngx_connection_t</span>();  <span class="comment">//定位new，释放则显式调用p_Conn-&gt;~ngx_connection_t();		</span></span><br><span class="line">        p_Conn-&gt;<span class="built_in">GetOneToUse</span>();</span><br><span class="line">        m_connectionList.<span class="built_in">push_back</span>(p_Conn);     <span class="comment">//所有链接【不管是否空闲】都放在这个list</span></span><br><span class="line">        m_freeconnectionList.<span class="built_in">push_back</span>(p_Conn); <span class="comment">//空闲连接会放在这个list</span></span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line">    m_free_connection_n = m_total_connection_n = m_connectionList.<span class="built_in">size</span>(); <span class="comment">//开始这两个列表一样大</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetOneToUse-连接初始化"><a href="#GetOneToUse-连接初始化" class="headerlink" title="GetOneToUse()连接初始化"></a>GetOneToUse()连接初始化</h4><p>每次初始化connection都会++iCurrsequence;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配出去一个连接的时候初始化一些内容,原来内容放在 ngx_get_connection()里，现在放在这里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_connection_s::GetOneToUse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++iCurrsequence;</span><br><span class="line"></span><br><span class="line">    fd  = <span class="number">-1</span>;                                         <span class="comment">//开始先给-1</span></span><br><span class="line">    curStat = _PKG_HD_INIT;                           <span class="comment">//收包状态处于 初始状态，准备接收数据包头【状态机】</span></span><br><span class="line">    precvbuf = dataHeadInfo;                          <span class="comment">//收包我要先收到这里来，因为我要先收包头，所以收数据的buff直接就是dataHeadInfo</span></span><br><span class="line">    irecvlen = <span class="built_in"><span class="keyword">sizeof</span></span>(COMM_PKG_HEADER);               <span class="comment">//这里指定收数据的长度，这里先要求收包头这么长字节的数据</span></span><br><span class="line">    </span><br><span class="line">    precvMemPointer   = <span class="literal">NULL</span>;                         <span class="comment">//既然没new内存，那自然指向的内存地址先给NULL</span></span><br><span class="line">    iThrowsendCount   = <span class="number">0</span>;                            <span class="comment">//原子的</span></span><br><span class="line">    psendMemPointer   = <span class="literal">NULL</span>;                         <span class="comment">//发送数据头指针记录</span></span><br><span class="line">    events            = <span class="number">0</span>;                            <span class="comment">//epoll事件先给0 </span></span><br><span class="line">    lastPingTime      = <span class="built_in">time</span>(<span class="literal">NULL</span>);                   <span class="comment">//上次ping的时间</span></span><br><span class="line"></span><br><span class="line">    FloodkickLastTime = <span class="number">0</span>;                            <span class="comment">//Flood攻击上次收到包的时间</span></span><br><span class="line">    FloodAttackCount  = <span class="number">0</span>;	                          <span class="comment">//Flood攻击在该时间内收到包的次数统计</span></span><br><span class="line">    iSendCount        = <span class="number">0</span>;                            <span class="comment">//发送队列中有的数据条目数，若client只发不收，则可能造成此数过大，依据此数做出踢出处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ngx-get-connection"><a href="#ngx-get-connection" class="headerlink" title="ngx_get_connection"></a>ngx_get_connection</h3><p>多线程操纵链表CLock lock(&amp;m_connectionMutex); 因此需要加锁</p>
<p>从空闲队列取出连接池的连接并且调用GetOneToUse初始化连接，再绑定当前socket的fd。返回连接return p_Conn</p>
<p>没有空闲连接则创建一个新的连接并且要放入总表队列调用GetOneToUse初始化连接，再绑定当前socket的fd。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从连接池中获取一个空闲连接【当一个客户端连接TCP进入，我希望把这个连接和我的 连接池中的 一个连接【对象】绑到一起，后续 我可以通过这个连接，把这个对象拿到，因为对象里边可以记录各种信息】</span></span><br><span class="line"><span class="function"><span class="keyword">lpngx_connection_t</span> <span class="title">CSocekt::ngx_get_connection</span><span class="params">(<span class="keyword">int</span> isock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为可能有其他线程要访问m_freeconnectionList，m_connectionList【比如可能有专门的释放线程要释放/或者主线程要释放】之类的，所以应该临界一下</span></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_connectionMutex)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m_freeconnectionList.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有空闲的，自然是从空闲的中摘取</span></span><br><span class="line">        <span class="keyword">lpngx_connection_t</span> p_Conn = m_freeconnectionList.<span class="built_in">front</span>(); <span class="comment">//返回第一个元素但不检查元素存在与否</span></span><br><span class="line">        m_freeconnectionList.<span class="built_in">pop_front</span>();                         <span class="comment">//移除第一个元素但不返回	</span></span><br><span class="line">        p_Conn-&gt;<span class="built_in">GetOneToUse</span>();</span><br><span class="line">        --m_free_connection_n; </span><br><span class="line">        p_Conn-&gt;fd = isock;</span><br><span class="line">        <span class="keyword">return</span> p_Conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里，表示没空闲的连接了，那就考虑重新创建一个连接</span></span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn = (<span class="keyword">lpngx_connection_t</span>)p_memory-&gt;<span class="built_in">AllocMemory</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_connection_t</span>),<span class="literal">true</span>);</span><br><span class="line">    p_Conn = <span class="built_in"><span class="keyword">new</span></span>(p_Conn) <span class="built_in">ngx_connection_t</span>();</span><br><span class="line">    p_Conn-&gt;<span class="built_in">GetOneToUse</span>();</span><br><span class="line">    m_connectionList.<span class="built_in">push_back</span>(p_Conn); <span class="comment">//入到总表中来，但不能入到空闲表中来，因为凡是调这个函数的，肯定是要用这个连接的</span></span><br><span class="line">    ++m_total_connection_n;             </span><br><span class="line">    p_Conn-&gt;fd = isock;</span><br><span class="line">    <span class="keyword">return</span> p_Conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为我们要采用延迟释放的手段来释放连接，因此这种 instance就没啥用，这种手段用来处理立即释放才有用。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearconnection"><a href="#clearconnection" class="headerlink" title="clearconnection"></a>clearconnection</h3><p>清空整个连接池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终回收连接池，释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::clearconnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!m_connectionList.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p_Conn = m_connectionList.<span class="built_in">front</span>();</span><br><span class="line">        m_connectionList.<span class="built_in">pop_front</span>(); </span><br><span class="line">        p_Conn-&gt;~<span class="built_in">ngx_connection_t</span>();     <span class="comment">//手工调用析构函数</span></span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(p_Conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ngx-free-connection-立即回收"><a href="#ngx-free-connection-立即回收" class="headerlink" title="ngx_free_connection()立即回收"></a>ngx_free_connection()立即回收</h3><p>用户没有三次握手接入之前我们可以直接立即回收</p>
<p>PutOneToFree中会将此连接的序列号iCurrsequence自加1，以避免过期包的发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归还参数pConn所代表的连接到到连接池中，注意参数类型是lpngx_connection_t</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::ngx_free_connection</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为有线程可能要动连接池中连接，所以在合理互斥也是必要的</span></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_connectionMutex)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先明确一点，连接，所有连接全部都在m_connectionList里；</span></span><br><span class="line">    pConn-&gt;<span class="built_in">PutOneToFree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扔到空闲连接列表里</span></span><br><span class="line">    m_freeconnectionList.<span class="built_in">push_back</span>(pConn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空闲连接数+1</span></span><br><span class="line">    ++m_free_connection_n;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PutOneToFree"><a href="#PutOneToFree" class="headerlink" title="PutOneToFree"></a>PutOneToFree</h4><p>收到的包不全并且用户退出了，有必要将收到一半的包的内存释放掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收回来一个连接的时候做一些事</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_connection_s::PutOneToFree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++iCurrsequence;   </span><br><span class="line">    <span class="keyword">if</span>(precvMemPointer != <span class="literal">NULL</span>)<span class="comment">//我们曾经给这个连接分配过接收数据的内存，则要释放内存</span></span><br><span class="line">    &#123;        </span><br><span class="line">        CMemory::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">FreeMemory</span>(precvMemPointer);</span><br><span class="line">        precvMemPointer = <span class="literal">NULL</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(psendMemPointer != <span class="literal">NULL</span>) <span class="comment">//如果发送数据的缓冲区里有内容，则要释放内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        CMemory::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">FreeMemory</span>(psendMemPointer);</span><br><span class="line">        psendMemPointer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iThrowsendCount = <span class="number">0</span>;                              <span class="comment">//设置不设置感觉都行         </span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="inRecyConnectQueue延时回收"><a href="#inRecyConnectQueue延时回收" class="headerlink" title="inRecyConnectQueue延时回收"></a>inRecyConnectQueue延时回收</h3><p>用户三次握手进来了，但是断了，还是采用延时回收吧，延时回收也会将连接的序列号pConn-&gt;iCurrsequence自加1，以避免过期包的发送</p>
<p>放入<code>CSocekt::list&lt;lpngx_connection_t&gt;m_recyconnectionList</code>然后ServerRecyConnectionThread线程自会处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将要回收的连接放到一个队列中来，后续有专门的线程会处理这个队列中的连接的回收</span></span><br><span class="line"><span class="comment">//有些连接，我们不希望马上释放，要隔一段时间后再释放以确保服务器的稳定，所以，我们把这种隔一段时间才释放的连接先放到一个队列中来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::inRecyConnectQueue</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">lpngx_connection_t</span>&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">bool</span> iffind = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_recyconnqueueMutex)</span></span>; <span class="comment">//针对连接回收列表的互斥量，因为线程ServerRecyConnectionThread()也有要用到这个回收列表；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如下判断防止连接被多次扔到回收站中来</span></span><br><span class="line">    <span class="keyword">for</span>(pos = m_recyconnectionList.<span class="built_in">begin</span>(); pos != m_recyconnectionList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*pos) == pConn)		</span><br><span class="line">        &#123;	</span><br><span class="line">            iffind = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iffind == <span class="literal">true</span>) <span class="comment">//找到了，不必再入了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//我有义务保证这个只入一次嘛</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pConn-&gt;inRecyTime = <span class="built_in">time</span>(<span class="literal">NULL</span>);        <span class="comment">//记录回收时间</span></span><br><span class="line">    ++pConn-&gt;iCurrsequence;</span><br><span class="line">    m_recyconnectionList.<span class="built_in">push_back</span>(pConn); <span class="comment">//等待ServerRecyConnectionThread线程自会处理 </span></span><br><span class="line">    ++m_totol_recyconnection_n;            <span class="comment">//待释放连接队列大小+1</span></span><br><span class="line">    --m_onlineUserCount;                   <span class="comment">//连入用户数量-1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServerRecyConnectionThread处理连接回收的线程"><a href="#ServerRecyConnectionThread处理连接回收的线程" class="headerlink" title="ServerRecyConnectionThread处理连接回收的线程"></a>ServerRecyConnectionThread处理连接回收的线程</h3><p><strong>伪代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理连接回收的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CSocekt::ServerRecyConnectionThread</span><span class="params">(<span class="keyword">void</span>* threadData)</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">usleep</span><span class="params">(<span class="number">200</span> * <span class="number">1000</span>)</span></span>;<span class="comment">//睡眠200毫秒</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex);<span class="comment">//上锁</span></span><br><span class="line">        <span class="keyword">for</span>(; pos != posend; ++pos)</span><br><span class="line">            <span class="keyword">if</span>(进入回收站时间+等待回收时间&gt;当前时间)<span class="keyword">continue</span>;<span class="comment">//未到释放时间</span></span><br><span class="line">            m_recyconnectionList.<span class="built_in">erase</span>(pos);<span class="comment">//将释放连接容器里的连接释放</span></span><br><span class="line">            <span class="built_in">ngx_free_connection</span>(p_Conn);<span class="comment">////归还参数pConn所代表的连接到到连接池中</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex);<span class="comment">//解锁</span></span><br><span class="line">        <span class="keyword">if</span>(g_stopEvent == <span class="number">1</span>) <span class="comment">//要退出整个程序，那么肯定要先退出这个循环，所有连接硬释放</span></span><br><span class="line">        做上面的相同行为而且不加时间判断，对所有连接全回收</span><br><span class="line">    <span class="built_in">endwhile</span>(<span class="number">1</span>)   </span><br></pre></td></tr></table></figure>

<p>CSocket的静态成员函数，与线程池无关</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理连接回收的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CSocekt::ServerRecyConnectionThread</span><span class="params">(<span class="keyword">void</span>* threadData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadItem *pThread = <span class="keyword">static_cast</span>&lt;ThreadItem*&gt;(threadData);</span><br><span class="line">    CSocekt *pSocketObj = pThread-&gt;_pThis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">time_t</span> currtime;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    std::list&lt;<span class="keyword">lpngx_connection_t</span>&gt;::iterator pos,posend;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//为简化问题，我们直接每次休息200毫秒</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span> * <span class="number">1000</span>);  <span class="comment">//单位是微妙,又因为1毫秒=1000微妙，所以 200 *1000 = 200毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不管啥情况，先把这个条件成立时该做的动作做了</span></span><br><span class="line">        <span class="keyword">if</span>(pSocketObj-&gt;m_totol_recyconnection_n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currtime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            err = <span class="built_in">pthread_mutex_lock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex);  </span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>) <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerRecyConnectionThread()中pthread_mutex_lock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line"></span><br><span class="line">lblRRTD:</span><br><span class="line">            pos    = pSocketObj-&gt;m_recyconnectionList.<span class="built_in">begin</span>();</span><br><span class="line">            posend = pSocketObj-&gt;m_recyconnectionList.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">for</span>(; pos != posend; ++pos)</span><br><span class="line">            &#123;</span><br><span class="line">                p_Conn = (*pos);</span><br><span class="line">                <span class="keyword">if</span>(</span><br><span class="line">                    ( (p_Conn-&gt;inRecyTime + pSocketObj-&gt;m_RecyConnectionWaitTime) &gt; currtime)  &amp;&amp; (g_stopEvent == <span class="number">0</span>) <span class="comment">//如果不是要整个系统退出，你可以continue，否则就得要强制释放</span></span><br><span class="line">                    )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//没到释放的时间</span></span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="comment">//到释放的时间了: </span></span><br><span class="line">                <span class="comment">//......这将来可能还要做一些是否能释放的判断[在我们写完发送数据代码之后吧]，先预留位置</span></span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//我认为，凡是到释放时间的，iThrowsendCount都应该为0；这里我们加点日志判断下</span></span><br><span class="line">                <span class="comment">//if(p_Conn-&gt;iThrowsendCount != 0)</span></span><br><span class="line">                <span class="keyword">if</span>(p_Conn-&gt;iThrowsendCount &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//这确实不应该，打印个日志吧；</span></span><br><span class="line">                    <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CSocekt::ServerRecyConnectionThread()中到释放时间却发现p_Conn.iThrowsendCount!=0，这个不该发生&quot;</span>);</span><br><span class="line">                    <span class="comment">//其他先暂时啥也不敢，路程继续往下走，继续去释放吧。</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//流程走到这里，表示可以释放，那我们就开始释放</span></span><br><span class="line">                --pSocketObj-&gt;m_totol_recyconnection_n;        <span class="comment">//待释放连接队列大小-1</span></span><br><span class="line">                pSocketObj-&gt;m_recyconnectionList.<span class="built_in">erase</span>(pos);   <span class="comment">//迭代器已经失效，但pos所指内容在p_Conn里保存着呢</span></span><br><span class="line">           </span><br><span class="line">                pSocketObj-&gt;<span class="built_in">ngx_free_connection</span>(p_Conn);	   <span class="comment">//归还参数pConn所代表的连接到到连接池中</span></span><br><span class="line">                <span class="keyword">goto</span> lblRRTD; </span><br><span class="line">            &#125; <span class="comment">//end for</span></span><br><span class="line">            err = <span class="built_in">pthread_mutex_unlock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex); </span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>)  <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerRecyConnectionThread()pthread_mutex_unlock()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">        &#125; <span class="comment">//end if</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(g_stopEvent == <span class="number">1</span>) <span class="comment">//要退出整个程序，那么肯定要先退出这个循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pSocketObj-&gt;m_totol_recyconnection_n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//因为要退出，所以就得硬释放了【不管到没到时间，不管有没有其他不 允许释放的需求，都得硬释放】</span></span><br><span class="line">                err = <span class="built_in">pthread_mutex_lock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex);  </span><br><span class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>) <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerRecyConnectionThread()中pthread_mutex_lock2()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line"></span><br><span class="line">        lblRRTD2:</span><br><span class="line">                pos    = pSocketObj-&gt;m_recyconnectionList.<span class="built_in">begin</span>();</span><br><span class="line">                posend = pSocketObj-&gt;m_recyconnectionList.<span class="built_in">end</span>();</span><br><span class="line">                <span class="keyword">for</span>(; pos != posend; ++pos)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_Conn = (*pos);</span><br><span class="line">                    --pSocketObj-&gt;m_totol_recyconnection_n;        <span class="comment">//待释放连接队列大小-1</span></span><br><span class="line">                    pSocketObj-&gt;m_recyconnectionList.<span class="built_in">erase</span>(pos);   <span class="comment">//迭代器已经失效，但pos所指内容在p_Conn里保存着呢</span></span><br><span class="line">                    pSocketObj-&gt;<span class="built_in">ngx_free_connection</span>(p_Conn);	   <span class="comment">//归还参数pConn所代表的连接到到连接池中</span></span><br><span class="line">                    <span class="keyword">goto</span> lblRRTD2; </span><br><span class="line">                &#125; <span class="comment">//end for</span></span><br><span class="line">                err = <span class="built_in">pthread_mutex_unlock</span>(&amp;pSocketObj-&gt;m_recyconnqueueMutex); </span><br><span class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)  <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerRecyConnectionThread()pthread_mutex_unlock2()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">            &#125; <span class="comment">//end if</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//整个程序要退出了，所以break;</span></span><br><span class="line">        &#125;  <span class="comment">//end if</span></span><br><span class="line">    &#125; <span class="comment">//end while    </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池相关类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CThreadPool();               </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~CThreadPool();                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span>;                     <span class="comment">//创建该线程池中的所有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopAll</span><span class="params">()</span></span>;                                 <span class="comment">//使线程池中的所有线程退出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueueAndSignal</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;        <span class="comment">//收到一个完整消息后，入消息队列，并触发线程池中线程来处理该消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Call</span><span class="params">()</span></span>;                                    <span class="comment">//来任务了，调一个线程池中的线程下来干活  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">getRecvMsgQueueCount</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_iRecvMsgQueueCount;&#125; <span class="comment">//获取接收消息队列大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *threadData)</span></span>;      <span class="comment">//新线程的线程回调函数    </span></span><br><span class="line">    <span class="comment">//char *outMsgRecvQueue();                        //将一个消息出消息队列	，不需要，直接在ThreadFunc()中处理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearMsgRecvQueue</span><span class="params">()</span></span>;                       <span class="comment">//清理接收消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义一个 线程池中的 线程 的结构，以后可能做一些统计之类的 功能扩展，所以引入这么个结构来 代表线程 感觉更方便一些</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadItem</span>   </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">pthread_t</span>   _Handle;                        <span class="comment">//线程句柄</span></span><br><span class="line">        CThreadPool *_pThis;                        <span class="comment">//记录线程池的指针	</span></span><br><span class="line">        <span class="keyword">bool</span>        ifrunning;                      <span class="comment">//标记是否正式启动起来，启动起来后，才允许调用StopAll()来释放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        ThreadItem(CThreadPool *pthis):_pThis(pthis),ifrunning(<span class="literal">false</span>)&#123;&#125;                             </span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        ~ThreadItem()&#123;&#125;        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span>     m_pthreadMutex;      <span class="comment">//线程同步互斥量/也叫线程同步锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_cond_t</span>      m_pthreadCond;       <span class="comment">//线程同步条件变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span>                m_shutdown;          <span class="comment">//线程退出标志，false不退出，true退出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>                        m_iThreadNum;        <span class="comment">//要创建的线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int                        m_iRunningThreadNum; //线程数, 运行中的线程数	</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;           m_iRunningThreadNum; <span class="comment">//线程数, 运行中的线程数，原子操作</span></span><br><span class="line">    <span class="keyword">time_t</span>                     m_iLastEmgTime;      <span class="comment">//上次发生线程不够用【紧急事件】的时间,防止日志报的太频繁</span></span><br><span class="line">    <span class="comment">//time_t                     m_iPrintInfoTime;    //打印信息的一个间隔时间，我准备10秒打印出一些信息供参考和调试</span></span><br><span class="line">    <span class="comment">//time_t                     m_iCurrTime;         //当前时间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ThreadItem *&gt;  m_threadVector;      <span class="comment">//线程 容器，容器里就是各个线程了 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息队列相关</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span> *&gt;          m_MsgRecvQueue;      <span class="comment">//接收数据消息队列 </span></span><br><span class="line">    <span class="keyword">int</span>                        m_iRecvMsgQueueCount;<span class="comment">//收消息队列大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="创建线程池（worker进程中执行）"><a href="#创建线程池（worker进程中执行）" class="headerlink" title="创建线程池（worker进程中执行）"></a>创建线程池（worker进程中执行）</h3><h4 id="Create-会激发线程入口函数ThreadFunc"><a href="#Create-会激发线程入口函数ThreadFunc" class="headerlink" title="Create()会激发线程入口函数ThreadFunc"></a>Create()会激发线程入口函数ThreadFunc</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池中的线程，要手工调用，不在构造函数里调用了</span></span><br><span class="line"><span class="comment">//返回值：所有线程都创建成功则返回true，出现错误则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CThreadPool::Create</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ThreadItem *pNew;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    m_iThreadNum = threadNum; <span class="comment">//保存要创建的线程数量    </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threadVector.<span class="built_in">push_back</span>(pNew = <span class="keyword">new</span> <span class="built_in">ThreadItem</span>(<span class="keyword">this</span>));             <span class="comment">//创建 一个新线程对象 并入到线程池容器中         </span></span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;pNew-&gt;_Handle, <span class="literal">NULL</span>, ThreadFunc, pNew);      <span class="comment">//创建线程，错误不返回到errno，一般返回错误码</span></span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建线程有错</span></span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::Create()创建线程%d失败，返回的错误码为%d!&quot;</span>,i,err);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建线程成功</span></span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;CThreadPool::Create()创建线程%d成功,线程id=%d&quot;,pNew-&gt;_Handle);</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; <span class="comment">//end for</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们必须保证每个线程都启动并运行到pthread_cond_wait()，本函数才返回，只有这样，这几个线程才能进行后续的正常工作 </span></span><br><span class="line">    std::vector&lt;ThreadItem*&gt;::iterator iter;</span><br><span class="line">lblfor:</span><br><span class="line">    <span class="keyword">for</span>(iter = m_threadVector.<span class="built_in">begin</span>(); iter != m_threadVector.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (*iter)-&gt;ifrunning == <span class="literal">false</span>) <span class="comment">//这个条件保证所有线程完全启动起来，以保证整个线程池中的线程正常工作；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这说明有没有启动完全的线程</span></span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span> * <span class="number">1000</span>);  <span class="comment">//单位是微妙,又因为1毫秒=1000微妙，所以 100 *1000 = 100毫秒</span></span><br><span class="line">            <span class="keyword">goto</span> lblfor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>m_threadVector.push_back(pNew = new ThreadItem(this));</code>这个this指针是线程池CThreadPool的指针，通过这一句指向CthreadPool的指针就传入ThreadItem中去了。</p>
<p>CThreadPool是线程池的管理类，整个服务器只需这一个对象即可</p>
<p>ThreadItem是线程的结构，包含线程句柄，线程各个状态等等，<code>CthreadPool::vector&lt;ThreadItem *&gt;  m_threadVector;</code> 就是线程 容器，容器里就是各个线程了</p>
<p><strong>特别注意：</strong>【很重要】</p>
<p>线程池要求都执行阻塞到这一行<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex);</code>，在此之前create()函数不允许返回。因为如果不这样的话，先开的线程可能create()函数已经执行完毕了并且开始执行比如StopAll()函数进行修改甚至关闭了线程池资源了，但是所有线程还没有完全启动，这样会导致线程池异常。 </p>
<p>所以上面的lblfor循环是为了保证所有线程完全启动起来，以保证整个线程池中的线程正常工作。</p>
<h4 id="ThreadFunc-线程入口函数"><a href="#ThreadFunc-线程入口函数" class="headerlink" title="ThreadFunc()线程入口函数"></a>ThreadFunc()线程入口函数</h4><p>精华代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = <span class="built_in">pthread_mutex_lock</span>(&amp;m_pthreadMutex);  </span><br><span class="line"><span class="keyword">while</span> ( (pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">size</span>() == <span class="number">0</span>) &amp;&amp; m_shutdown == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pThread-&gt;ifrunning == <span class="literal">false</span>)            </span><br><span class="line">        pThread-&gt;ifrunning = <span class="literal">true</span>; </span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;m_pthreadCond, &amp;m_pthreadMutex); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>注意在CThreadPool类中<code>static void* ThreadFunc(void *threadData); </code>是一个静态函数，不存在this指针，因此临时定义<code>CThreadPool *pThreadPoolObj = pThread-&gt;_pThis;</code></li>
<li>注意m_pthreadCond是一个静态成员<code>static pthread_cond_t    m_pthreadCond;</code><br><code>pthread_cond_t CThreadPool::m_pthreadCond = PTHREAD_COND_INITIALIZER;   //初始化</code></li>
<li>因此对于m_pthreadCond 而言<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex); </code>刚开始时初始状态，没有什么东西来激发它，<strong>会卡在这里，而且m_pthreadMutex会被释放掉；</strong><br>第一个线程执行到这一句的时候，m_pthreadMutex会被释放掉，第二个线程得以在while循环中往下执行。如果有100个线程，最终结果是100个线程都会卡在这里并且m_pthreadMutex会被释放掉。这100个线程都在等待m_pthreadCond这个条件。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程入口函数，当用pthread_create()创建线程后，这个ThreadFunc()函数都会被立即执行；注意这个是静态函数，不带有this参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CThreadPool::ThreadFunc</span><span class="params">(<span class="keyword">void</span>* threadData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这个是静态成员函数，是不存在this指针的；</span></span><br><span class="line">    ThreadItem *pThread = <span class="keyword">static_cast</span>&lt;ThreadItem*&gt;(threadData);</span><br><span class="line">    CThreadPool *pThreadPoolObj = pThread-&gt;_pThis;</span><br><span class="line">    </span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();	    </span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>(); <span class="comment">//获取线程自身id，以方便调试打印信息等    </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//线程用pthread_mutex_lock()函数去锁定指定的mutex变量，若该mutex已经被另外一个线程锁定了，该调用将会阻塞线程直到mutex被解锁。  </span></span><br><span class="line">        err = <span class="built_in">pthread_mutex_lock</span>(&amp;m_pthreadMutex);  </span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>) <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::ThreadFunc()中pthread_mutex_lock()失败，返回的错误码为%d!&quot;</span>,err);<span class="comment">//有问题，要及时报告</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下这行程序写法技巧十分重要，必须要用while这种写法，</span></span><br><span class="line">        <span class="comment">//因为：pthread_cond_wait()是个值得注意的函数，调用一次pthread_cond_signal()可能会唤醒多个【惊群】【官方描述是 至少一个/pthread_cond_signal 在多处理器上可能同时唤醒多个线程】</span></span><br><span class="line">        <span class="comment">//pthread_cond_wait()函数，如果只有一条消息 唤醒了两个线程干活，那么其中有一个线程拿不到消息，那如果不用while写，就会出问题，所以被惊醒后必须再次用while拿消息，拿到才走下来；</span></span><br><span class="line">        <span class="keyword">while</span> ( (pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">size</span>() == <span class="number">0</span>) &amp;&amp; m_shutdown == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果这个pthread_cond_wait被唤醒【被唤醒后程序执行流程往下走的前提是拿到了锁--官方：pthread_cond_wait()返回时，互斥量再次被锁住】，</span></span><br><span class="line">              <span class="comment">//那么会立即再次执行g_socket.outMsgRecvQueue()，如果拿到了一个NULL，则继续在这里wait着();</span></span><br><span class="line">            <span class="keyword">if</span>(pThread-&gt;ifrunning == <span class="literal">false</span>)            </span><br><span class="line">                pThread-&gt;ifrunning = <span class="literal">true</span>; <span class="comment">//标记为true了才允许调用StopAll()：测试中发现如果Create()和StopAll()紧挨着调用，就会导致线程混乱，所以每个线程必须执行到这里，才认为是启动成功了；</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;执行了pthread_cond_wait-------------begin&quot;);</span></span><br><span class="line">            <span class="comment">//刚开始执行pthread_cond_wait()的时候，会卡在这里，而且m_pthreadMutex会被释放掉；</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;m_pthreadCond, &amp;m_pthreadMutex); <span class="comment">//整个服务器程序刚初始化的时候，所有线程必然是卡在这里等待的；</span></span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;执行了pthread_cond_wait-------------end&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//能走下来的，必然是 拿到了真正的 消息队列中的数据   或者 m_shutdown == true</span></span><br><span class="line">        <span class="comment">//走到这里时刻，互斥量肯定是锁着的。。。。。。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先判断线程退出这个条件</span></span><br><span class="line">        <span class="keyword">if</span>(m_shutdown)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;m_pthreadMutex); <span class="comment">//解锁互斥量</span></span><br><span class="line">            <span class="keyword">break</span>;                     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里，可以取得消息进行处理了【消息队列中必然有消息】,注意，目前还是互斥着呢</span></span><br><span class="line">        <span class="keyword">char</span> *jobbuf = pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">front</span>();     <span class="comment">//返回第一个元素但不检查元素存在与否</span></span><br><span class="line">        pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">pop_front</span>();                <span class="comment">//移除第一个元素但不返回	</span></span><br><span class="line">        --pThreadPoolObj-&gt;m_iRecvMsgQueueCount;                    <span class="comment">//收消息队列数字-1</span></span><br><span class="line">               </span><br><span class="line">        <span class="comment">//可以解锁互斥量了</span></span><br><span class="line">        err = <span class="built_in">pthread_mutex_unlock</span>(&amp;m_pthreadMutex); </span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)  <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CThreadPool::ThreadFunc()中pthread_mutex_unlock()失败，返回的错误码为%d!&quot;</span>,err);<span class="comment">//有问题，要及时报告</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//能走到这里的，就是有消息可以处理，开始处理</span></span><br><span class="line">        ++pThreadPoolObj-&gt;m_iRunningThreadNum;    <span class="comment">//原子+1【记录正在干活的线程数量增加1】，这比互斥量要快很多</span></span><br><span class="line"></span><br><span class="line">        g_socket.<span class="built_in">threadRecvProcFunc</span>(jobbuf);     <span class="comment">//处理消息队列中来的消息</span></span><br><span class="line"></span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(jobbuf);              <span class="comment">//释放消息内存 </span></span><br><span class="line">        --pThreadPoolObj-&gt;m_iRunningThreadNum;     <span class="comment">//原子-1【记录正在干活的线程数量减少1】</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//end while(true)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//能走出来表示整个程序要结束啊，怎么判断所有线程都结束？</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程处理消息队列"><a href="#线程处理消息队列" class="headerlink" title="线程处理消息队列"></a>线程处理消息队列</h3><p>所有线程都卡在<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex);</code>才能初始化线程。</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成员函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(CLogicSocket::*handler)</span><span class="params">(  <span class="keyword">lpngx_connection_t</span> pConn,      <span class="comment">//连接池中连接的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        LPSTRUC_MSG_HEADER pMsgHeader,  <span class="comment">//消息头指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">char</span> *pPkgBody,                 <span class="comment">//包体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">unsigned</span> <span class="keyword">short</span> iBodyLength)</span></span>;    <span class="comment">//包体长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来保存 成员函数指针 的这么个数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> handler statusHandler[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//数组前5个元素，保留，以备将来增加一些基本服务器功能</span></span><br><span class="line">    &amp;CLogicSocket::_HandlePing,                             <span class="comment">//【0】：心跳包的实现</span></span><br><span class="line">    <span class="literal">NULL</span>,                                                   <span class="comment">//【1】：下标从0开始</span></span><br><span class="line">    <span class="literal">NULL</span>,                                                   <span class="comment">//【2】：下标从0开始</span></span><br><span class="line">    <span class="literal">NULL</span>,                                                   <span class="comment">//【3】：下标从0开始</span></span><br><span class="line">    <span class="literal">NULL</span>,                                                   <span class="comment">//【4】：下标从0开始</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//开始处理具体的业务逻辑</span></span><br><span class="line">    &amp;CLogicSocket::_HandleRegister,                         <span class="comment">//【5】：实现具体的注册功能</span></span><br><span class="line">    &amp;CLogicSocket::_HandleLogIn,                            <span class="comment">//【6】：实现具体的登录功能</span></span><br><span class="line">    <span class="comment">//......其他待扩展，比如实现攻击功能，实现加血功能等等；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTH_TOTAL_COMMANDS sizeof(statusHandler)/sizeof(handler) <span class="comment">//整个命令有多少个，编译时即可知道</span></span></span><br></pre></td></tr></table></figure>

<h4 id="threadRecvProcFunc"><a href="#threadRecvProcFunc" class="headerlink" title="threadRecvProcFunc"></a>threadRecvProcFunc</h4><p><strong>ThreadFunc所有线程都阻塞在pthread_cond_wait处，当有消息来时有线程取到消息后会调用当前函数</strong></p>
<ul>
<li>1.用强制类型转换取得消息头和包头两个结构体。从包头中取出包的长度（注意要ntohs网络序转本机序）。</li>
<li>2.如果没有包体只有包头，crc32校验码应该是0，若不为0丢弃包return。</li>
<li>3.如果有包体，拿到包体并且服务器通过包体计算得到的crc32校验码，然后与客户端传来pPkgHeader-&gt;crc32校验码比较是否一致，若不一致丢弃且return。</li>
<li>4.然后通过消息头取出连接池的连接指针p_Conn和消息头的iCurrsequence，然后比较连接池的此连接的p_Conn-&gt;iCurrsequence与消息头的iCurrsequence是否一致，若不一致说明连接已经关闭了。丢弃包直接return。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRUC_MSG_HEADER</span>&#123;</span><span class="comment">//消息头结构体</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> pConn;         <span class="comment">//记录对应的链接，注意这是个指针</span></span><br><span class="line">    <span class="keyword">uint64_t</span>           iCurrsequence; <span class="comment">//收到数据包时记录对应连接的序号，将来能用于比较是否连接已经作废用</span></span><br><span class="line">&#125;STRUC_MSG_HEADER,*LPSTRUC_MSG_HEADER;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.判断长度是否大于AUTH_TOTAL_COMMANDS，若大于是恶意包，根本没有这么多命令，丢弃包并且return。</li>
<li>6.<code>(this-&gt;*statusHandler[imsgCode])(p_Conn,pMsgHeader,(char *)pPkgBody,pkglen-m_iLenPkgHeader);</code>根据客户端发来包头内部的消息类型代码（区别每个不同的命令）调用对应的函数实现各个不同消息类型的处理逻辑。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///处理收到的数据包，由线程池来调用本函数，本函数是一个单独的线程；</span></span><br><span class="line"><span class="comment">//pMsgBuf：消息头 + 包头 + 包体 ：自解释；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLogicSocket::threadRecvProcFunc</span><span class="params">(<span class="keyword">char</span> *pMsgBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">    LPSTRUC_MSG_HEADER pMsgHeader = (LPSTRUC_MSG_HEADER)pMsgBuf;                  <span class="comment">//消息头</span></span><br><span class="line">    LPCOMM_PKG_HEADER  pPkgHeader = (LPCOMM_PKG_HEADER)(pMsgBuf+m_iLenMsgHeader); <span class="comment">//包头</span></span><br><span class="line">    <span class="keyword">void</span>  *pPkgBody;                                                              <span class="comment">//指向包体的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> pkglen = <span class="built_in">ntohs</span>(pPkgHeader-&gt;pkgLen);                            <span class="comment">//客户端指明的包宽度【包头+包体】</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_iLenPkgHeader == pkglen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有包体，只有包头</span></span><br><span class="line">        <span class="keyword">if</span>(pPkgHeader-&gt;crc32 != <span class="number">0</span>) <span class="comment">//只有包头的crc值给0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//crc错，直接丢弃</span></span><br><span class="line">        &#125;</span><br><span class="line">        pPkgBody = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有包体，走到这里</span></span><br><span class="line">        pPkgHeader-&gt;crc32 = <span class="built_in">ntohl</span>(pPkgHeader-&gt;crc32);		          <span class="comment">//针对4字节的数据，网络序转主机序</span></span><br><span class="line">        pPkgBody = (<span class="keyword">void</span> *)(pMsgBuf+m_iLenMsgHeader+m_iLenPkgHeader); <span class="comment">//跳过消息头 以及 包头 ，指向包体</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ngx_log_stderr(0,&quot;CLogicSocket::threadRecvProcFunc()中收到包的crc值为%d!&quot;,pPkgHeader-&gt;crc32);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算crc值判断包的完整性        </span></span><br><span class="line">        <span class="keyword">int</span> calccrc = CCRC32::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get_CRC</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)pPkgBody,pkglen-m_iLenPkgHeader); <span class="comment">//计算纯包体的crc值</span></span><br><span class="line">        <span class="keyword">if</span>(calccrc != pPkgHeader-&gt;crc32) <span class="comment">//服务器端根据包体计算crc值，和客户端传递过来的包头中的crc32信息比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CLogicSocket::threadRecvProcFunc()中CRC错误[服务器:%d/客户端:%d]，丢弃数据!&quot;</span>,calccrc,pPkgHeader-&gt;crc32);    <span class="comment">//正式代码中可以干掉这个信息</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//crc错，直接丢弃</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;CLogicSocket::threadRecvProcFunc()中CRC正确[服务器:%d/客户端:%d]，不错!&quot;,calccrc,pPkgHeader-&gt;crc32);</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包crc校验OK才能走到这里    	</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> imsgCode = <span class="built_in">ntohs</span>(pPkgHeader-&gt;msgCode); <span class="comment">//消息代码拿出来</span></span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn = pMsgHeader-&gt;pConn;        <span class="comment">//消息头中藏着连接池中连接的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们要做一些判断</span></span><br><span class="line">    <span class="comment">//(1)如果从收到客户端发送来的包，到服务器释放一个线程池中的线程处理该包的过程中，客户端断开了，那显然，这种收到的包我们就不必处理了；    </span></span><br><span class="line">    <span class="keyword">if</span>(p_Conn-&gt;iCurrsequence != pMsgHeader-&gt;iCurrsequence)   <span class="comment">//该连接池中连接以被其他tcp连接【其他socket】占用，这说明原来的 客户端和本服务器的连接断了，这种包直接丢弃不理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//丢弃不理这种包了【客户端断开了】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)判断消息码是正确的，防止客户端恶意侵害我们服务器，发送一个不在我们服务器处理范围内的消息码</span></span><br><span class="line">    <span class="keyword">if</span>(imsgCode &gt;= AUTH_TOTAL_COMMANDS) <span class="comment">//无符号数不可能&lt;0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CLogicSocket::threadRecvProcFunc()中imsgCode=%d消息码不对!&quot;</span>,imsgCode); <span class="comment">//这种有恶意倾向或者错误倾向的包，希望打印出来看看是谁干的</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//丢弃不理这种包【恶意包或者错误包】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能走到这里的，包没过期，不恶意，那好继续判断是否有相应的处理函数</span></span><br><span class="line">    <span class="comment">//(3)有对应的消息处理函数吗</span></span><br><span class="line">    <span class="keyword">if</span>(statusHandler[imsgCode] == <span class="literal">NULL</span>) <span class="comment">//这种用imsgCode的方式可以使查找要执行的成员函数效率特别高</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ngx_log_stderr</span>(<span class="number">0</span>,<span class="string">&quot;CLogicSocket::threadRecvProcFunc()中imsgCode=%d消息码找不到对应的处理函数!&quot;</span>,imsgCode); <span class="comment">//这种有恶意倾向或者错误倾向的包，希望打印出来看看是谁干的</span></span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//没有相关的处理函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一切正确，可以放心大胆的处理了</span></span><br><span class="line">    <span class="comment">//(4)调用消息码对应的成员函数来处理</span></span><br><span class="line">    (<span class="keyword">this</span>-&gt;*statusHandler[imsgCode])(p_Conn,pMsgHeader,(<span class="keyword">char</span> *)pPkgBody,pkglen-&gt;m_iLenPkgHeader);</span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放线程池"><a href="#释放线程池" class="headerlink" title="释放线程池"></a>释放线程池</h3><p>虽然一般不会调用这个函数，而且实在不行直接关闭程序系统帮我们释放资源，但是为了优雅一点自己实现一下。</p>
<h4 id="StopAll"><a href="#StopAll" class="headerlink" title="StopAll()"></a>StopAll()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = <span class="built_in">pthread_mutex_lock</span>(&amp;m_pthreadMutex);  </span><br><span class="line"><span class="keyword">while</span> ( (pThreadPoolObj-&gt;m_MsgRecvQueue.<span class="built_in">size</span>() == <span class="number">0</span>) &amp;&amp; m_shutdown == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pThread-&gt;ifrunning == <span class="literal">false</span>)            </span><br><span class="line">        pThread-&gt;ifrunning = <span class="literal">true</span>; </span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;m_pthreadCond, &amp;m_pthreadMutex); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将所有线程安全退出后，再将内存释放。“优雅干净”</p>
<ul>
<li>1.首先给个判断m_shutdown避免重复释放，然后m_shutdown置为true表示要关闭线程池了，这是个静态变量<code>static bool CThreadPool::m_shutdown = false;</code></li>
<li>2.pthread_cond_broadcast广播会激发ThreadPool的静态成员m_pthreadCond，一旦激发成功pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex); 的线程被唤醒了，并且这个while循环条件不满足，所有线程都去拿锁m_pthreadMutex，其他未拿到锁的线程只能卡死，等待上个线程退出释放锁，最终所有线程return退出。</li>
<li>3.for循环pthread_join回收退出的线程资源直至所有线程都退出</li>
<li>4.通过m_threadVector容器中的成员指针将之前new出来的ThreadItem内存释放。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//停止所有线程【等待结束线程池中所有线程，该函数返回后，应该是所有线程池中线程都结束了】</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CThreadPool::StopAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//(1)已经调用过，就不要重复调用了</span></span><br><span class="line">    <span class="keyword">if</span>(m_shutdown == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)唤醒等待该条件【卡在pthread_cond_wait()的】的所有线程，一定要在改变条件状态以后再给线程发信号</span></span><br><span class="line">    <span class="keyword">int</span> err = pthread_cond_broadcast(&amp;m_pthreadCond); </span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这肯定是有问题，要打印紧急日志</span></span><br><span class="line">        ngx_log_stderr(err,<span class="string">&quot;CThreadPool::StopAll()中pthread_cond_broadcast()失败，返回的错误码为%d!&quot;</span>,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3)等等线程，让线程真返回    </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ThreadItem*&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = m_threadVector.begin(); iter != m_threadVector.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join((*iter)-&gt;_Handle, <span class="literal">NULL</span>); <span class="comment">//等待一个线程终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流程走到这里，那么所有的线程池中的线程肯定都返回了；</span></span><br><span class="line">    pthread_mutex_destroy(&amp;m_pthreadMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;m_pthreadCond);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4)释放一下new出来的ThreadItem【线程池中的线程】    </span></span><br><span class="line">    <span class="keyword">for</span>(iter = m_threadVector.begin(); iter != m_threadVector.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter)</span><br><span class="line">            <span class="keyword">delete</span> *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    m_threadVector.clear();</span><br><span class="line"></span><br><span class="line">    ngx_log_stderr(<span class="number">0</span>,<span class="string">&quot;CThreadPool::StopAll()成功返回，线程池中线程全部正常结束!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p>线程池里面地线程都“嗷嗷待哺”地等待客户端发来消息，线程池地线程都会执行threadRecvProcFunc函数，这个函数会根据发来的消息包的不同执行不同的逻辑函数。目前逻辑并不多，只处理了一个心跳包的逻辑。</p>
<h3 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h3><p>心跳包其实就是 一个普通的数据包；</p>
<p>一般每个几十秒，最长一般也就是1分钟【10秒-60秒之间】，有客户端主动发送给服务器；服务器收到之后，一般会给客户端返回一个心跳包；</p>
<p>三路握手，tcp连接建立之后，才存在发送心跳包的问题—— 如果c不给s发心跳包，服务器会怎样；约定 30秒发送 一次； 服务器可能会在90秒或者100秒内，主动关闭该客户端的socket连接；</p>
<p>作为一个好的客户端程序，如果你发送了心跳包给服务器，但是在90或者100秒之内，你[客户端]没有收到服务器回应的心跳包，那么你就应该主动关闭与服务器端的链接，并且如果业务需要重连，客户端程序在关闭这个连接后还要重新主动再次尝试连接服务器端；客户端程序 也有必要提示使用者 与服务器的连接已经断开；</p>
<p><strong>为什么引入心跳包？</strong></p>
<p>常规客户端关闭，服务器端能感知到；但是有一种特殊情况，连接断开c/s都感知不到；</p>
<p>c /s程序运行在不同的两个物理电脑上；tcp已经建立；<br>拔掉c /s程序的网线； <strong>拔掉网线导致服务器感知不到客户端断开</strong>，这个事实，一定要知道；<br>为了应对拔网线，导致不知道对方是否断开了tcp连接这种事，这就是我们引入心跳包机制的原因；<br>超时没有发送来心跳包，那么就会将对端的socket连接close掉，回收资源；这就是心跳包的作用；<br>其他作用：检测网络延迟等等<br>这里心跳包主要目的就是检测双方的链接是否断开；</p>
<p>tcp本身keepalive机制；因为检测时间不好控制，所以不适合我们；</p>
<p>因此连接池的每个连接引入一个成员变量lastPingTime记录上一次的ping命令（心跳包）的时间，不断地更新</p>
<h4 id="处理发来的心跳包"><a href="#处理发来的心跳包" class="headerlink" title="处理发来的心跳包"></a>处理发来的心跳包</h4><h5 id="HandlePing"><a href="#HandlePing" class="headerlink" title="_HandlePing"></a>_HandlePing</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收并处理客户端发送过来的ping包</span></span><br><span class="line"><span class="keyword">bool</span> CLogicSocket::_HandlePing(<span class="keyword">lpngx_connection_t</span> pConn,LPSTRUC_MSG_HEADER pMsgHeader,<span class="keyword">char</span> *pPkgBody,<span class="keyword">unsigned</span> <span class="keyword">short</span> iBodyLength)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//心跳包要求没有包体；</span></span><br><span class="line">    <span class="keyword">if</span>(iBodyLength != <span class="number">0</span>)  <span class="comment">//有包体则认为是 非法包</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;pConn-&gt;logicPorcMutex)</span></span>; <span class="comment">//凡是和本用户有关的访问都考虑用互斥，以免该用户同时发送过来两个命令达到各种作弊目的</span></span><br><span class="line">    pConn-&gt;lastPingTime = <span class="built_in">time</span>(<span class="literal">NULL</span>);   <span class="comment">//更新该变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器也发送 一个只有包头的数据包给客户端，作为返回的数据</span></span><br><span class="line">    <span class="built_in">SendNoBodyPkgToClient</span>(pMsgHeader,_CMD_PING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ngx_log_stderr(0,&quot;成功收到了心跳包并返回结果！&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SendNoBodyPkgToClient"><a href="#SendNoBodyPkgToClient" class="headerlink" title="SendNoBodyPkgToClient"></a>SendNoBodyPkgToClient</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送没有包体的数据包给客户端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLogicSocket::SendNoBodyPkgToClient</span><span class="params">(LPSTRUC_MSG_HEADER pMsgHeader,<span class="keyword">unsigned</span> <span class="keyword">short</span> iMsgCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMemory  *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p_sendbuf = (<span class="keyword">char</span> *)p_memory-&gt;<span class="built_in">AllocMemory</span>(m_iLenMsgHeader+m_iLenPkgHeader,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">char</span> *p_tmpbuf = p_sendbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(p_tmpbuf,pMsgHeader,m_iLenMsgHeader);</span><br><span class="line">    p_tmpbuf += m_iLenMsgHeader;</span><br><span class="line"></span><br><span class="line">    LPCOMM_PKG_HEADER pPkgHeader = (LPCOMM_PKG_HEADER)p_tmpbuf;	  <span class="comment">//指向的是我要发送出去的包的包头	</span></span><br><span class="line">    pPkgHeader-&gt;msgCode = <span class="built_in">htons</span>(iMsgCode);	</span><br><span class="line">    pPkgHeader-&gt;pkgLen = <span class="built_in">htons</span>(m_iLenPkgHeader); </span><br><span class="line">    pPkgHeader-&gt;crc32 = <span class="number">0</span>;		</span><br><span class="line">    <span class="built_in">msgSend</span>(p_sendbuf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测心跳时间"><a href="#检测心跳时间" class="headerlink" title="检测心跳时间"></a>检测心跳时间</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>20秒；超过20*3 +10 =70秒，仍旧没收到心跳包，那么服务器端就把tcp断开；或者20秒直接断开TCP连接<br>增加配置Sock_WaitTimeEnable，Sock_MaxWaitTime</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Sock_WaitTimeEnable：是否开启踢人时钟，1：开启   0：不开启</span><br><span class="line">Sock_WaitTimeEnable = 1</span><br><span class="line">#多少秒检测一次是否 心跳超时，只有当Sock_WaitTimeEnable = 1时，本项才有用</span><br><span class="line">Sock_MaxWaitTime = 20</span><br><span class="line">#当时间到达Sock_MaxWaitTime指定的时间时，直接把客户端踢出去，只有当Sock_WaitTimeEnable = 1时，本项才有用</span><br><span class="line">Sock_TimeOutKick = 0</span><br></pre></td></tr></table></figure>

<h5 id="CSocekt-AddToTimerQueue"><a href="#CSocekt-AddToTimerQueue" class="headerlink" title="CSocekt::AddToTimerQueue"></a>CSocekt::AddToTimerQueue</h5><p>在<strong>ngx_event_accept</strong>（三次握手成功后）调用AddToTimerQueue()添加一个<strong>定时器</strong>。每次进来一个用户，就往时间队列multimap（有序的键/值对，但它可以保存重复的元素）增加一个连接。<br>每次插入时间队列会按键值 自动排序 小-&gt;大。并且将时间队列<strong>头部时间值（最早时间）</strong>保存到m_timer_value_里<br><code>std::multimap&lt;time_t, LPSTRUC_MSG_HEADER&gt;  m_timerQueuemap;</code>键：时间，值：消息头（消息头存放连接指针和连接序号）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置踢出时钟(向multimap表中增加内容)，用户三次握手成功连入，然后我们开启了踢人开关【Sock_WaitTimeEnable = 1】，那么本函数被调用；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::AddToTimerQueue</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> futtime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    futtime += m_iWaitTime;  <span class="comment">//20秒之后的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_timequeueMutex)</span></span>; <span class="comment">//互斥，因为要操作m_timeQueuemap了</span></span><br><span class="line">    LPSTRUC_MSG_HEADER tmpMsgHeader = (LPSTRUC_MSG_HEADER)p_memory-&gt;<span class="built_in">AllocMemory</span>(m_iLenMsgHeader,<span class="literal">false</span>);</span><br><span class="line">    tmpMsgHeader-&gt;pConn = pConn;</span><br><span class="line">    tmpMsgHeader-&gt;iCurrsequence = pConn-&gt;iCurrsequence;</span><br><span class="line">    m_timerQueuemap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(futtime,tmpMsgHeader)); <span class="comment">//按键 自动排序 小-&gt;大</span></span><br><span class="line">    m_cur_size_++;  <span class="comment">//计时队列尺寸+1</span></span><br><span class="line">    m_timer_value_ = <span class="built_in">GetEarliestTime</span>(); <span class="comment">//计时队列头部时间值保存到m_timer_value_里</span></span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CSocekt-ServerSendQueueThread处理时间队列线程"><a href="#CSocekt-ServerSendQueueThread处理时间队列线程" class="headerlink" title="CSocekt::ServerSendQueueThread处理时间队列线程"></a>CSocekt::ServerSendQueueThread处理时间队列线程</h5><p>创建一个新线程，专门处理事件队列里心跳包未发送的连接</p>
<ul>
<li>每次取出m_timer_value_最早时间，判断有没有连接是已经过期的（过久未发心跳包）</li>
<li>通过GetOverTimeTimer根据给的当前时间，从m_timeQueuemap找到比这个时间更老（更早）的节点【1个】返回去，这些节点都是时间超过了，要处理的节点</li>
<li>然后对要处理的时间过期节点，该去检测心跳包是否超时的事宜，是否要踢出这个连接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间队列监视和处理线程，处理到期不发心跳包的用户踢出的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CSocekt::ServerTimerQueueMonitorThread</span><span class="params">(<span class="keyword">void</span>* threadData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadItem *pThread = <span class="keyword">static_cast</span>&lt;ThreadItem*&gt;(threadData);</span><br><span class="line">    CSocekt *pSocketObj = pThread-&gt;_pThis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> absolute_time,cur_time;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(g_stopEvent == <span class="number">0</span>) <span class="comment">//不退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里没互斥判断，所以只是个初级判断，目的至少是队列为空时避免系统损耗		</span></span><br><span class="line">        <span class="keyword">if</span>(pSocketObj-&gt;m_cur_size_ &gt; <span class="number">0</span>)<span class="comment">//队列不为空，有内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//时间队列中最近发生事情的时间放到 absolute_time里；</span></span><br><span class="line">            absolute_time = pSocketObj-&gt;m_timer_value_; <span class="comment">//这个可是省了个互斥，十分划算</span></span><br><span class="line">            cur_time = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(absolute_time &lt; cur_time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//时间到了，可以处理了</span></span><br><span class="line">                std::list&lt;LPSTRUC_MSG_HEADER&gt; m_lsIdleList; <span class="comment">//保存要处理的内容</span></span><br><span class="line">                LPSTRUC_MSG_HEADER result;</span><br><span class="line"></span><br><span class="line">                err = <span class="built_in">pthread_mutex_lock</span>(&amp;pSocketObj-&gt;m_timequeueMutex);  </span><br><span class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>) <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerTimerQueueMonitorThread()中pthread_mutex_lock()失败，返回的错误码为%d!&quot;</span>,err);<span class="comment">//有问题，要及时报告</span></span><br><span class="line">                <span class="keyword">while</span> ((result = pSocketObj-&gt;<span class="built_in">GetOverTimeTimer</span>(cur_time)) != <span class="literal">NULL</span>) <span class="comment">//一次性的把所有超时节点都拿过来</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_lsIdleList.<span class="built_in">push_back</span>(result); </span><br><span class="line">                &#125;<span class="comment">//end while</span></span><br><span class="line">                err = <span class="built_in">pthread_mutex_unlock</span>(&amp;pSocketObj-&gt;m_timequeueMutex); </span><br><span class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)  <span class="built_in">ngx_log_stderr</span>(err,<span class="string">&quot;CSocekt::ServerTimerQueueMonitorThread()pthread_mutex_unlock()失败，返回的错误码为%d!&quot;</span>,err);<span class="comment">//有问题，要及时报告                </span></span><br><span class="line">                LPSTRUC_MSG_HEADER tmpmsg;</span><br><span class="line">                <span class="keyword">while</span>(!m_lsIdleList.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmpmsg = m_lsIdleList.<span class="built_in">front</span>();</span><br><span class="line">                    m_lsIdleList.<span class="built_in">pop_front</span>(); </span><br><span class="line">                    pSocketObj-&gt;<span class="built_in">procPingTimeOutChecking</span>(tmpmsg,cur_time); <span class="comment">//这里需要检查心跳超时问题</span></span><br><span class="line">                &#125; <span class="comment">//end while(!m_lsIdleList.empty())</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//end if(pSocketObj-&gt;m_cur_size_ &gt; 0)</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500</span> * <span class="number">1000</span>); <span class="comment">//为简化问题，我们直接每次休息500毫秒</span></span><br><span class="line">    &#125; <span class="comment">//end while</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CLogicSocket-procPingTimeOutChecking"><a href="#CLogicSocket-procPingTimeOutChecking" class="headerlink" title="CLogicSocket::procPingTimeOutChecking"></a>CLogicSocket::procPingTimeOutChecking</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//心跳包检测时间到，该去检测心跳包是否超时的事宜，本函数是子类函数，实现具体的判断动作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLogicSocket::procPingTimeOutChecking</span><span class="params">(LPSTRUC_MSG_HEADER tmpmsg,<span class="keyword">time_t</span> cur_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tmpmsg-&gt;iCurrsequence == tmpmsg-&gt;pConn-&gt;iCurrsequence) <span class="comment">//此连接没断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lpngx_connection_t</span> p_Conn = tmpmsg-&gt;pConn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*m_ifkickTimeCount == 1 &amp;&amp; */</span>m_ifTimeOutKick == <span class="number">1</span>)  <span class="comment">//能调用到本函数第一个条件肯定成立，所以第一个条件加不加无所谓，主要是第二个条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//到时间直接踢出去的需求</span></span><br><span class="line">            <span class="built_in">zdClosesocketProc</span>(p_Conn); </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( (cur_time - p_Conn-&gt;lastPingTime ) &gt; (m_iWaitTime*<span class="number">3</span>+<span class="number">10</span>) ) <span class="comment">//超时踢的判断标准就是 每次检查的时间间隔*3，超过这个时间没发送心跳包，就踢【大家可以根据实际情况自由设定】</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//踢出去【如果此时此刻该用户正好断线，则这个socket可能立即被后续上来的连接复用  如果真有人这么倒霉，赶上这个点了，那么可能错踢，错踢就错踢】            </span></span><br><span class="line">            <span class="comment">//ngx_log_stderr(0,&quot;时间到不发心跳包，踢出去!&quot;);   //感觉OK</span></span><br><span class="line">            <span class="built_in">zdClosesocketProc</span>(p_Conn); </span><br><span class="line">        &#125;   </span><br><span class="line">             </span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(tmpmsg);<span class="comment">//内存要释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//此连接断了</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_memory-&gt;<span class="built_in">FreeMemory</span>(tmpmsg);<span class="comment">//内存要释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CSocekt-DeleteFromTimerQueue"><a href="#CSocekt-DeleteFromTimerQueue" class="headerlink" title="CSocekt::DeleteFromTimerQueue"></a>CSocekt::DeleteFromTimerQueue</h5><p>zdClosesocketProc(p_Conn)会调用此函数，主要从时间队列中删除并且释放内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把指定用户tcp连接从timer表中抠出去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::DeleteFromTimerQueue</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="keyword">time_t</span>, LPSTRUC_MSG_HEADER&gt;::iterator pos,posend;</span><br><span class="line">    CMemory *p_memory = CMemory::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_timequeueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为实际情况可能比较复杂，将来可能还扩充代码等等，所以如下我们遍历整个队列找 一圈，而不是找到一次就拉倒，以免出现什么遗漏</span></span><br><span class="line">lblMTQM:</span><br><span class="line">    pos    = m_timerQueuemap.<span class="built_in">begin</span>();</span><br><span class="line">    posend = m_timerQueuemap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span>(; pos != posend; ++pos)	</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos-&gt;second-&gt;pConn == pConn)</span><br><span class="line">        &#123;			</span><br><span class="line">            p_memory-&gt;<span class="built_in">FreeMemory</span>(pos-&gt;second);  <span class="comment">//释放内存</span></span><br><span class="line">            m_timerQueuemap.<span class="built_in">erase</span>(pos);</span><br><span class="line">            --m_cur_size_; <span class="comment">//减去一个元素，必然要把尺寸减少1个;								</span></span><br><span class="line">            <span class="keyword">goto</span> lblMTQM;</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_cur_size_ &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_timer_value_ = <span class="built_in">GetEarliestTime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h2><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#是注释行，</span><br><span class="line">#每个有效配置项用 等号 处理，等号前不超过40个字符，等号后不超过400个字符；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#[开头的表示组信息，也等价于注释行</span><br><span class="line">#[Socket]</span><br><span class="line">#ListenPort = 5678    </span><br><span class="line">#DBInfo = 127.0.0.1;1234;myr;123456;mxdb_g</span><br><span class="line"></span><br><span class="line">#日志相关</span><br><span class="line">[Log]</span><br><span class="line">#日志文件输出目录和文件名</span><br><span class="line">#Log=logs/error.log</span><br><span class="line">Log=error.log</span><br><span class="line"></span><br><span class="line">#只打印日志等级&lt;= 数字 的日志到日志文件中 ，日志等级0-8,0级别最高，8级别最低。</span><br><span class="line">LogLevel = 8</span><br><span class="line"></span><br><span class="line">#进程相关</span><br><span class="line">[Proc]</span><br><span class="line">#创建 这些个 worker进程</span><br><span class="line">WorkerProcesses = 4</span><br><span class="line"></span><br><span class="line">#是否按守护进程方式运行，1：按守护进程方式运行，0：不按守护进程方式运行</span><br><span class="line">Daemon = 1</span><br><span class="line"></span><br><span class="line">#处理接收到的消息的线程池中线程数量，不建议超过300</span><br><span class="line">ProcMsgRecvWorkThreadCount = 120</span><br><span class="line"></span><br><span class="line">#和网络相关</span><br><span class="line">[Net]</span><br><span class="line">#监听的端口数量，一般都是1个，当然如果支持多于一个也是可以的</span><br><span class="line">ListenPortCount = 1</span><br><span class="line">#ListenPort+数字【数字从0开始】，这种ListenPort开头的项有几个，取决于ListenPortCount的数量，</span><br><span class="line">ListenPort0 = 80</span><br><span class="line">#ListenPort1 = 443</span><br><span class="line"></span><br><span class="line">#epoll连接的最大数【是每个worker进程允许连接的客户端数】，实际其中有一些连接要被监听socket使用，实际允许的客户端连接数会比这个数小一些</span><br><span class="line">worker_connections = 2048</span><br><span class="line"></span><br><span class="line">#Sock_RecyConnectionWaitTime:为确保系统稳定socket关闭后资源不会立即收回，而要等一定的秒数，在这个秒数之后，才进行资源/连接的回收</span><br><span class="line">Sock_RecyConnectionWaitTime = 150</span><br><span class="line"></span><br><span class="line">#Sock_WaitTimeEnable：是否开启踢人时钟，1：开启   0：不开启</span><br><span class="line">Sock_WaitTimeEnable = 1</span><br><span class="line">#多少秒检测一次是否 心跳超时，只有当Sock_WaitTimeEnable = 1时，本项才有用</span><br><span class="line">Sock_MaxWaitTime = 20</span><br><span class="line">#当时间到达Sock_MaxWaitTime指定的时间时，直接把客户端踢出去，只有当Sock_WaitTimeEnable = 1时，本项才有用</span><br><span class="line">Sock_TimeOutKick = 0</span><br><span class="line"></span><br><span class="line">#和网络安全相关</span><br><span class="line">[NetSecurity]</span><br><span class="line">#flood检测</span><br><span class="line">#Flood攻击检测是否开启,1：开启   0：不开启</span><br><span class="line">Sock_FloodAttackKickEnable = 1</span><br><span class="line">#Sock_FloodTimeInterval表示每次收到数据包的时间间隔是100(单位：毫秒)</span><br><span class="line">Sock_FloodTimeInterval = 100</span><br><span class="line">#Sock_FloodKickCounter表示计算到连续10次，每次100毫秒时间间隔内发包，就算恶意入侵，把他kick出去</span><br><span class="line">Sock_FloodKickCounter = 10</span><br></pre></td></tr></table></figure>

<p>这种配置文件依赖于自己的想法设定，没有固定格式，主要还是看如何读取配置文件的各个参数的信息，这才是关键所在。</p>
<p>最终所有的信息都保存到了CConfig:: vector<LPCConfItem> m_ConfigItemList; 存储配置信息的列表。之后我们想取出配置信息就从这个容器中取出即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CConfig::Load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pconfName)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(pconfName,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一行配置文件读出来都放这里</span></span><br><span class="line">    <span class="keyword">char</span>  linebuf[<span class="number">501</span>];   <span class="comment">//每行配置都不要太长，保持&lt;500字符内，防止出现问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//走到这里，文件打开成功 </span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))  <span class="comment">//检查文件是否结束 ，没有结束则条件成立</span></span><br><span class="line">    &#123;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fgets</span>(linebuf,<span class="number">500</span>,fp) == <span class="literal">NULL</span>) <span class="comment">//从文件中读数据，每次读一行，一行最多不要超过500个字符 </span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理注释行</span></span><br><span class="line">        <span class="keyword">if</span>(*linebuf==<span class="string">&#x27;;&#x27;</span> || *linebuf==<span class="string">&#x27; &#x27;</span> || *linebuf==<span class="string">&#x27;#&#x27;</span> || *linebuf==<span class="string">&#x27;\t&#x27;</span>|| *linebuf==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    lblprocstring:</span><br><span class="line">        <span class="comment">//屁股后边若有换行，回车，空格等都截取掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(linebuf) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(linebuf[<span class="built_in">strlen</span>(linebuf)<span class="number">-1</span>] == <span class="number">10</span> || linebuf[<span class="built_in">strlen</span>(linebuf)<span class="number">-1</span>] == <span class="number">13</span> || linebuf[<span class="built_in">strlen</span>(linebuf)<span class="number">-1</span>] == <span class="number">32</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                linebuf[<span class="built_in">strlen</span>(linebuf)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> lblprocstring;</span><br><span class="line">            &#125;		</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*linebuf==<span class="string">&#x27;[&#x27;</span>) <span class="comment">//[开头的也不处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这种 “ListenPort = 5678”走下来；</span></span><br><span class="line">        <span class="keyword">char</span> *ptmp = <span class="built_in">strchr</span>(linebuf,<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*typedef struct _CConfItem</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                char ItemName[50];</span></span><br><span class="line"><span class="comment">                char ItemContent[500];</span></span><br><span class="line"><span class="comment">            &#125;CConfItem,*LPCConfItem;*/</span></span><br><span class="line">            LPCConfItem p_confitem = <span class="keyword">new</span> CConfItem;                    <span class="comment">//注意前边类型带LP，后边new这里的类型不带</span></span><br><span class="line">            <span class="built_in">memset</span>(p_confitem,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(CConfItem));</span><br><span class="line">            <span class="built_in">strncpy</span>(p_confitem-&gt;ItemName,linebuf,(<span class="keyword">int</span>)(ptmp-linebuf)); <span class="comment">//等号左侧的拷贝到p_confitem-&gt;ItemName</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p_confitem-&gt;ItemContent,ptmp+<span class="number">1</span>);                    <span class="comment">//等号右侧的拷贝到p_confitem-&gt;ItemContent</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//printf(&quot;itemname=%s | itemcontent=%s\n&quot;,p_confitem-&gt;ItemName,p_confitem-&gt;ItemContent);            </span></span><br><span class="line">            m_ConfigItemList.<span class="built_in">push_back</span>(p_confitem);  <span class="comment">//内存要释放，因为这里是new出来的 </span></span><br><span class="line">        &#125; <span class="comment">//end if</span></span><br><span class="line">    &#125; <span class="comment">//end while(!feof(fp)) </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fp); <span class="comment">//这步不可忘记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置文件标题"><a href="#设置文件标题" class="headerlink" title="设置文件标题"></a>设置文件标题</h3><p>argc:命令行参数的个数<br>argv:是个数组，每个数组元素都是指向一个字符串的char *，里边存储的内容是所有命令行参数；<br>比如你输入 <code>./nginx -12 -v 568 -q gess</code></p>
<p>argv内存之后，<strong>接着连续的就是环境变量参数信息内存</strong>【是咱们这个可执行程序执行时有关的所有环境变量参数信息】可以通过一个全局的environ[char **]就可以访问</p>
<p>environ内存和argv内存紧紧的挨着</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220310122258634.png" alt="image-20220310122258634"></p>
<p>为了修改可执行程序的命令行参数，我们必须修改argv参数而且<strong>千万不可以影响到环境变量参数信息</strong><br>实现思路：<br>(1)重新分配一块内存，用来保存environ中的内容；<br>(2)修改argv[0]所指向的内存；</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220310122315622.png" alt="image-20220310122315622"></p>
<h4 id="ngx-init-setproctitle环境变量拷贝到新内存"><a href="#ngx-init-setproctitle环境变量拷贝到新内存" class="headerlink" title="ngx_init_setproctitle环境变量拷贝到新内存"></a>ngx_init_setproctitle环境变量拷贝到新内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置可执行程序标题相关函数：分配内存，并且把环境变量拷贝到新内存中来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_init_setproctitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//这里无需判断penvmen == NULL,有些编译器new会返回NULL，有些会报异常，但不管怎样，如果在重要的地方new失败了，你无法收场，让程序失控崩溃，助你发现问题为好； </span></span><br><span class="line">    gp_envmem = <span class="keyword">new</span> <span class="keyword">char</span>[g_envneedmem]; </span><br><span class="line">    <span class="built_in">memset</span>(gp_envmem,<span class="number">0</span>,g_envneedmem);  <span class="comment">//内存要清空防止出现问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ptmp = gp_envmem;</span><br><span class="line">    <span class="comment">//把原来的内存内容搬到新地方来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; environ[i]; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(environ[i])+<span class="number">1</span> ; <span class="comment">//不要拉下+1，否则内存全乱套了，因为strlen是不包括字符串末尾的\0的</span></span><br><span class="line">        <span class="built_in">strcpy</span>(ptmp,environ[i]);      <span class="comment">//把原环境变量内容拷贝到新地方【新内存】</span></span><br><span class="line">        environ[i] = ptmp;            <span class="comment">//然后还要让新环境变量指向这段新内存</span></span><br><span class="line">        ptmp += size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ngx-setproctitle设置可执行程序标题"><a href="#ngx-setproctitle设置可执行程序标题" class="headerlink" title="ngx_setproctitle设置可执行程序标题"></a>ngx_setproctitle设置可执行程序标题</h4><p>主要思路是：</p>
<ol>
<li>获取argv[]和environ内存总长度</li>
<li>将标题title复制到argv起始位置</li>
<li>将剩下未用上的长度全部清空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置可执行程序标题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_setproctitle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *title)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我们假设，所有的命令 行参数我们都不需要用到了，可以被随意覆盖了；</span></span><br><span class="line">    <span class="comment">//注意：我们的标题长度，不会长到原始标题和原始环境变量都装不下，否则怕出问题，不处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(1)计算新标题长度</span></span><br><span class="line">    <span class="keyword">size_t</span> ititlelen = <span class="built_in">strlen</span>(title); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)计算总的原始的argv那块内存的总长度【包括各种参数】    </span></span><br><span class="line">    <span class="keyword">size_t</span> esy = g_argvneedmem + g_envneedmem; <span class="comment">//argv和environ内存总和</span></span><br><span class="line">    <span class="keyword">if</span>( esy &lt;= ititlelen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//你标题多长啊，我argv和environ总和都存不下？注意字符串末尾多了个 \0，所以这块判断是 &lt;=【也就是=都算存不下】</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间够保存标题的，够长，存得下，继续走下来    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3)设置后续的命令行参数为空，表示只有argv[]中只有一个元素了，这是好习惯；防止后续argv被滥用，因为很多判断是用argv[] == NULL来做结束标记判断的;</span></span><br><span class="line">    g_os_argv[<span class="number">1</span>] = <span class="literal">NULL</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4)把标题弄进来，注意原来的命令行参数都会被覆盖掉，不要再使用这些命令行参数,而且g_os_argv[1]已经被设置为NULL了</span></span><br><span class="line">    <span class="keyword">char</span> *ptmp = g_os_argv[<span class="number">0</span>]; <span class="comment">//让ptmp指向g_os_argv所指向的内存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ptmp,title);</span><br><span class="line">    ptmp += ititlelen; <span class="comment">//跳过标题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5)把剩余的原argv以及environ所占的内存全部清0，否则会出现在ps的cmd列可能还会残余一些没有被覆盖的内容；</span></span><br><span class="line">    <span class="keyword">size_t</span> cha = esy - ititlelen;  <span class="comment">//内存总和减去标题字符串长度(不含字符串末尾的\0)，剩余的大小，就是要memset的；</span></span><br><span class="line">    <span class="built_in">memset</span>(ptmp,<span class="number">0</span>,cha);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p><a href="https://yunf194.github.io/2022/01/29/2022129-%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/">日志功能</a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="如何把发送缓冲区撑满"><a href="#如何把发送缓冲区撑满" class="headerlink" title="如何把发送缓冲区撑满"></a>如何把发送缓冲区撑满</h3><p>（1）每次服务器给客户端发送65K左右的数据，发送到第20次才出现服务器的发送缓冲区满；这时**客户端收了1个包(65K)**，【触发了epoll可写事件，此时执行了 ngx_write_request_handler()】</p>
<p>（2）我又发包，连续成功发送了16次，才又出现发送缓冲区满；我客户端再收包，结果连续<strong>收了16个包</strong>，服务器才又出现ngx_write_request_handler()函数被成功执行，这表示客户端连续收了16次包，服务器的发送缓冲区才倒出地方来；</p>
<p>（3）此后，大概服务器能够连续发送16次才再出现发送缓冲区满，客户端连续收16次，服务器端才出现ngx_write_request_handler()被执行【服务器的发送缓冲区有地方】；</p>
<p>测试结论：</p>
<p>（1）ngx_write_request_handler（）逻辑正确；能够通过此函数把剩余的未成功发送的数据发送出去；</p>
<p>（2）LT模式下，我们发送数据采用的 改进方案 是非常有效的，在很大程度上提高了效率；</p>
<p>（3） 发送缓冲区大概10-几10K,但是我们实际测试的时候，成功的发送出去了1000多k数据才报告发送缓冲区满；<br>当我们发送端调用send()发送数据时，操作系统底层已经把数据发送到了 该连接的接收端 的<strong>接收缓存</strong>，这个接收缓存大概有几百K，<br>千万不要认为发送缓冲区只有几十K，所以我们send()几十k就能把发送缓冲区填满；</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220309160014668.png" alt="image-20220309160014668"></p>
<p>（4）不管怎么说，主要对方不接收数据，发送方的发送缓冲区总有满的时候；当发送缓冲满的时候，我们发送数据就会使用ngx_write_request_handler（）来执行了，所以现在看起来，我们整个的服务器的发送数据的实现代码是正确的；</p>
<h3 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h3><p>并发数量取决于很多因素：</p>
<ul>
<li>(1)采用的开发技术：epoll，支持数十万并发</li>
<li>(2)这个程序收发数据的频繁程度，以及具体 要处理的业务复杂程度</li>
<li>(3)服务器实际的物理内存；可用的物理内存数量，会直接决定你能支持的并发连接</li>
<li>(4)一些其他的tcp/ip配置项</li>
</ul>
<p>一般，我们日常所写的服务器程序，支持几千甚至1-2万的并发，基本上就差不多了；一个服务器程序，要根据我们具体的物理内存，以及我们具体要实现的业务等等因素，控制能够同时连入的客户端数量；如果你允许客户端无限连入，那么你的服务器肯定会崩溃；</p>
<p>这里我的解决方法是引入一个新变量m_onlineUserCount</p>
<p>void CSocekt::ngx_event_accept(lpngx_connection_t oldc) 连入人数+1<br>void CSocekt::inRecyConnectQueue(lpngx_connection_t pConn) 连入人数-1</p>
<p>控制连入用户数量的解决思路：如果同时连入的用户数量超过了允许的最大连入数量时，我们就把这个连入的用户直接踢出去；</p>
<h3 id="安全问题思考"><a href="#安全问题思考" class="headerlink" title="安全问题思考"></a>安全问题思考</h3><h4 id="防范SYN-Flood攻击"><a href="#防范SYN-Flood攻击" class="headerlink" title="防范SYN Flood攻击"></a>防范SYN Flood攻击</h4><p>以游戏服务器为例：</p>
<p>假设我们认为一个合理的客户端一秒钟发送数据包给服务器不超过10个；<br>如果客户端不停的给服务器发数据包，1秒钟超过了10个数据包 ，那我服务器就认为这个玩家有恶意攻击服务器的倾向；<br>我们服务器就应该果断的把这个TCP客户端连接关闭，这个也是服务器发现恶意玩家以及保护自身安全的手段；</p>
<p>代码上如何实现 1秒钟超过10个数据包则把客户端踢出去？<br>增加了TestFlood();</p>
<p>改造了ngx_read_request_handler(),ngx_wait_request_handler_proc_p1()，在每次收到了完整包就可以调用TestFlood()</p>
<p>ngx_wait_request_handler_proc_plast（）判断是否isflood，选择释放内存还是放入消息队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试是否flood攻击成立，成立则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSocekt::TestFlood</span><span class="params">(<span class="keyword">lpngx_connection_t</span> pConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">sCurrTime</span>;</span>   <span class="comment">//当前时间结构</span></span><br><span class="line">    <span class="keyword">uint64_t</span>        iCurrTime;   <span class="comment">//当前时间（单位：毫秒）</span></span><br><span class="line">    <span class="keyword">bool</span>  reco      = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;sCurrTime, <span class="literal">NULL</span>); <span class="comment">//取得当前时间</span></span><br><span class="line">    iCurrTime =  (sCurrTime.tv_sec * <span class="number">1000</span> + sCurrTime.tv_usec / <span class="number">1000</span>);  <span class="comment">//毫秒</span></span><br><span class="line">    <span class="keyword">if</span>((iCurrTime - pConn-&gt;FloodkickLastTime) &lt; m_floodTimeInterval)   <span class="comment">//两次收到包的时间 &lt; 100毫秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发包太频繁记录</span></span><br><span class="line">        pConn-&gt;FloodAttackCount++;</span><br><span class="line">        pConn-&gt;FloodkickLastTime = iCurrTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//既然发布不这么频繁，则恢复计数值</span></span><br><span class="line">        pConn-&gt;FloodAttackCount = <span class="number">0</span>;</span><br><span class="line">        pConn-&gt;FloodkickLastTime = iCurrTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ngx_log_stderr(0,&quot;pConn-&gt;FloodAttackCount=%d,m_floodKickCount=%d.&quot;,pConn-&gt;FloodAttackCount,m_floodKickCount);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pConn-&gt;FloodAttackCount &gt;= m_floodKickCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以踢此人的标志</span></span><br><span class="line">        reco = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reco;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收到太多数据包处理不过来"><a href="#收到太多数据包处理不过来" class="headerlink" title="收到太多数据包处理不过来"></a>收到太多数据包处理不过来</h4><p>限速：epoll技术，一个限速的思路；在epoll红黑树节点中，把这个EPOLLIN【可读】通知干掉；系统不会通知，服务器就不会去读，数据一直积累在接收缓冲区里，客户端那边会的发送缓冲区会满，客户端会减慢速度发送甚至停止发送。</p>
<p>数据报太多的话，会在printTDInfo()中做了一个简单提示</p>
<h4 id="积压太多数据包发送不出去"><a href="#积压太多数据包发送不出去" class="headerlink" title="积压太多数据包发送不出去"></a>积压太多数据包发送不出去</h4><p>见void CSocekt::msgSend(char *psendbuf) ，增加一个判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个待发送消息入到发消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSocekt::msgSend</span><span class="params">(<span class="keyword">char</span> *psendbuf)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMemory *p_memory = CMemory::GetInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function">CLock <span class="title">lock</span><span class="params">(&amp;m_sendMessageQueueMutex)</span></span>;  <span class="comment">//互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息队列过大也可能给服务器带来风险</span></span><br><span class="line">    <span class="keyword">if</span>(m_iSendMsgQueueCount &gt; <span class="number">50000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发送队列过大，比如客户端恶意不接受数据，就会导致这个队列越来越大</span></span><br><span class="line">        <span class="comment">//那么可以考虑为了服务器安全，干掉一些数据的发送，虽然有可能导致客户端出现问题，但总比服务器不稳定要好很多</span></span><br><span class="line">        m_iDiscardSendPkgCount++;</span><br><span class="line">        p_memory-&gt;FreeMemory(psendbuf);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总体数据并无风险，不会导致服务器崩溃，要看看个体数据，找一下恶意者了    </span></span><br><span class="line">    LPSTRUC_MSG_HEADER pMsgHeader = (LPSTRUC_MSG_HEADER)psendbuf;</span><br><span class="line">    <span class="keyword">lpngx_connection_t</span> p_Conn = pMsgHeader-&gt;pConn;</span><br><span class="line">    <span class="keyword">if</span>(p_Conn-&gt;iSendCount &gt; <span class="number">400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该用户收消息太慢【或者干脆不收消息】，累积的该用户的发送队列中有的数据条目数过大，认为是恶意用户，直接切断</span></span><br><span class="line">        ngx_log_stderr(<span class="number">0</span>,<span class="string">&quot;CSocekt::msgSend()中发现某用户%d积压了大量待发送数据包，切断与他的连接！&quot;</span>,p_Conn-&gt;fd);      </span><br><span class="line">        m_iDiscardSendPkgCount++;</span><br><span class="line">        p_memory-&gt;FreeMemory(psendbuf);</span><br><span class="line">        zdClosesocketProc(p_Conn); <span class="comment">//直接关闭</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++p_Conn-&gt;iSendCount; <span class="comment">//发送队列中有的数据条目数+1；</span></span><br><span class="line">    m_MsgSendQueue.push_back(psendbuf);     </span><br><span class="line">    ++m_iSendMsgQueueCount;   <span class="comment">//原子操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将信号量的值+1,这样其他卡在sem_wait的就可以走下去</span></span><br><span class="line">    <span class="keyword">if</span>(sem_post(&amp;m_semEventSendQueue)==<span class="number">-1</span>)  <span class="comment">//让ServerSendQueueThread()流程走下来干活</span></span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_stderr(<span class="number">0</span>,<span class="string">&quot;CSocekt::msgSend()中sem_post(&amp;m_semEventSendQueue)失败.&quot;</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连入安全的进一步完善"><a href="#连入安全的进一步完善" class="headerlink" title="连入安全的进一步完善"></a>连入安全的进一步完善</h4><p>void CSocekt::ngx_event_accept(lpngx_connection_t oldc)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果某些恶意用户连上来发了1条数据就断，不断连接，会导致频繁调用ngx_get_connection()使用我们短时间内产生大量连接，危及本服务器安全</span></span><br><span class="line"><span class="keyword">if</span>(m_connectionList.size() &gt; (m_worker_connections * <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//比如你允许同时最大2048个连接，但连接池却有了 2048*5这么大的容量，这肯定是表示短时间内 产生大量连接/断开，因为我们的延迟回收机制，这里连接还在垃圾池里没有被回收</span></span><br><span class="line">    <span class="keyword">if</span>(m_freeconnectionList.size() &lt; m_worker_connections)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//整个连接池这么大了，而空闲连接却这么少了，所以我认为是  短时间内 产生大量连接，发一个包后就断开，我们不可能让这种情况持续发生，所以必须断开新入用户的连接</span></span><br><span class="line">        <span class="comment">//一直到m_freeconnectionList变得足够大【连接池中连接被回收的足够多】</span></span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>一般要测试很多天，跑的时间长了可能 会暴露下次，跑的时间短了可能还暴露不出来；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CONNECTION_COUNT_          2048      <span class="comment">//创建多少个连接，此值越大，当然recv失败的机会越大，返回10060,表示超时，setsockopt里设置了5秒的；</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THREAD_COUNT_              100       <span class="comment">//准备创建这么多个线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CESHIXIBIAO _CONNECTION_COUNT_ + 2000 <span class="comment">//测试下标</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVERIPADDR <span class="meta-string">&quot;192.168.200.129&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PORT 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RECVTIMEOUT_               1500 <span class="comment">//超时等待时间（单位：毫秒）</span></span></span><br></pre></td></tr></table></figure>

<p>初始化socket后创建100个线程，线程具体执行如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScanThread</span></span><br><span class="line"><span class="function">    <span class="title">socket</span><span class="params">()</span><span class="comment">//所有线程加起来一共创建2048个线程</span></span></span><br><span class="line"><span class="function">    <span class="title">connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">FuncsendrecvData</span><span class="params">()</span><span class="comment">//模拟收发数据</span></span></span><br><span class="line"><span class="function">        <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">recv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">FunccloseSocket</span><span class="params">()</span><span class="comment">//模拟断一些socket</span></span></span><br><span class="line"><span class="function">        <span class="title">closesocket</span><span class="params">()</span></span>;</span><br><span class="line">    FunccreateSocket()<span class="comment">//模拟把断的socket进行重连</span></span><br><span class="line">        socket()</span><br><span class="line">        connect(); </span><br></pre></td></tr></table></figure>

<p>建议：</p>
<p>(1)测试收包，简单的逻辑处理，发包；</p>
<p>(2)建议如果有多个物理电脑；客户端单独放在一个电脑；</p>
<p>建议用高性能linux服务器专门运行服务器程序<br>windows也建议单独用一个电脑来测试；</p>
<p>(3)测试什么？</p>
<ol>
<li>程序崩溃，这明显不行，肯定要解决</li>
<li>程序运行异常，比如过几个小时，服务器连接不上了；没有回应了，你发过来的包服务器处理不了了；</li>
<li>服务器程序占用的内存才能不断增加，增加到一定程度，可能导致整个服务器崩溃；</li>
</ol>
<p>top -p 子进程ID：显示进程占用的内存和cpu百分比，用q可以退出；<br>top -p pid,推荐文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dragonsuc/p/5512797.html">https://www.cnblogs.com/dragonsuc/p/5512797.html</a></p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220217170617051.png" alt="image-20220217170617051"></p>
<p>cat /proc/子进程ID/status   ———其中VmRSS:     7700 kB，占用的实际内存。</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220217170312468.png" alt="image-20220217170312468"></p>
<h4 id="最大连接是1018"><a href="#最大连接是1018" class="headerlink" title="最大连接是1018"></a>最大连接是1018</h4><p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220217170445780.png" alt="image-20220217170445780"></p>
<p>日志中报：CSocekt::ngx_event_accept()中accept4()失败<br>这个跟 用户进程可打开的文件数限制有关； 因为系统为每个tcp连接都要创建一个socekt句柄，每个socket句柄同时也是一个文件句柄；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/nginx$ <span class="built_in">ulimit</span> -n</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<p>通过<code>ulimit -n</code>可以看到进程允许打开的文件数目限制是1024。而减去标准输入输出，错误输出，日志文件，监听端口等这几个占用的fd后数目是1018。</p>
<p>我们就必须修改linux对当前用户的进程 同时打开的文件数量的限制；</p>
<h3 id="惊群"><a href="#惊群" class="headerlink" title="惊群"></a>惊群</h3><p>惊群：1个master进程  4个worker进程</p>
<p>一个连接进入，惊动了4个worker进程，但是只有一个worker进程accept();其他三个worker进程被惊动，这就叫惊群；</p>
<p>但是，这三个被惊动的worker进程都做了无用功【操作系统本身的缺陷】；</p>
<p>配置nginx的worker子进程数目为4，然后借助telnet进行连接测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/nginx$ telnet <span class="number">192.168</span><span class="number">.200</span><span class="number">.129</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在ngx_epoll_process_events()加入一个测试代码<code>ngx_log_stderr(0,&quot;惊群测试:events=%d,进程id=%d&quot;,events,ngx_pid); </code></p>
<p>可以观察到尽管只有一个telnet三次握手事件连入，但是四个worker进程都被唤醒了。</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220217193302164.png" alt="image-20220217193302164"></p>
<p>如何解决惊群问题？<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385410196">深入浅出 Linux 惊群：现象、原因和解决方案</a></p>
<p>epoll底层LT逻辑</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 遍历并清空epoll的ready list，遍历过程中，对于每个epi收集其返回的events，如果没收集到event，则continue去处理其他epi，否则将当前epi的事件和用户传入的数据都copy给用户空间，并判断，如果是在LT模式下，则将当前epi重新放回epoll的ready list</span><br><span class="line">[2] 遍历epoll的ready list完成后，如果ready list不为空，则继续唤醒epoll睡眠队列wq上的其他task B。task B从epoll_wait醒来继续前行，重复上面的流程，继续唤醒wq上的其他task C，这样链式唤醒下去。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例如有两个进程 A、B 睡眠在 epoll 的睡眠队列，<strong>fd 的可读事件到来唤醒进程 A，但是 A 可能很久才会去处理 fd 的事件，或者它根本就不去处理。</strong>根据 LT 的语义，当前fd的事件未处理，因此应该要唤醒进程 B 的。</p>
<p>LT模式下惊群的原因</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] epoll在ET模式下不存在“惊群”现象，LT模式是epoll“惊群”的根源，并且LT模式下的“惊群”没办法避免。</span><br><span class="line">[2] LT的“惊群”是链式唤醒的，唤醒过程直到当前epi的事件被处理了，无法获得到新的事件才会终止唤醒过程。</span><br><span class="line">例如有A、B、C、D...等多个进程task睡眠在epoll的睡眠队列上，并且都监控同一个listen fd的可读事件。一个请求上来，会首先唤醒A进程，A在epoll_wait的处理过程中会唤醒进程B，这样进程B在epoll_wait的处理过程中会唤醒C，这个时候A的epoll_wait处理完成返回，进程A调用accept读取了当前这个请求，进程C在自己的epoll_wait处理过程中，从epi中获取不到事件了，于是终止了整个链式唤醒过程。</span><br><span class="line">[3] 多个进程的epoll fd由于指向同一个epoll内核对象，他们对epoll fd的相关epoll_ctl操作会相互影响。一不小心可能会出现一些比较诡异的行为。</span><br><span class="line">想象这样一个场景(实际上应该不是这样用)，有一个服务在1234，1235，1236这3个端口上提供服务，于是它epoll_create得到epoll fd后，fork出3个工作的子进程A、B、C，它们分别在这3个端口创建listen fd，然后加入到epoll中监听其可读事件。这个时候端口1234上来一个请求，A、B、C同时被唤醒，A在epoll_wait返回后，在进行accept前由于种种原因卡住了，没能及时accept。B、C在epoll_wait返回后去accept又不能accept到请求，这样B、C重新回到epoll_wait，这个时候又被唤醒，这样只要A没有去处理这个请求之前，B、C就一直被唤醒，然而B、C又无法处理该请求。</span><br><span class="line">[4] ET模式下，一个fd上的同事多个事件上来，只会唤醒一个睡眠在epoll上的task，如果该task没有处理完这些事件，在没有新的事件上来前，epoll不会在通知task去处理。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>官方nginx解决惊群的办法：锁，进程之间的锁；<strong>谁获得这个锁，谁就往监听端口增加EPOLLIN标记，有了这个标记，客户端连入就能够被服务器感知到；</strong></p>
<blockquote>
<p>Nginx 通过一次仅允许一个进程将 listen fd 放入自己的 epoll 来监听其 READ 事件的方式来达到 listen fd”惊群”避免。然而做好这一点并不容易，作为一个高性能 web 服务器，需要尽量避免阻塞，并且要很好平衡各个工作 worker 的请求，避免饿死情况。</p>
<p>Nginx 采用在同一时刻仅允许一个 worker 进程监听 listen fd 的可读事件的方式，来避免 listen fd 的”惊群”现象。然而这种方式编程实现起来比较难，难道不能像 accept 一样解决 epoll 的”惊群”问题么？答案是可以的</p>
</blockquote>
<p>首先我采用的是<strong>先 fork 后 epoll_create</strong>（LT模式）</p>
<blockquote>
<p>用法上，通常是在父进程创建了 listen fd 后，fork 多个 worker 子进程来共同处理同一个 listen fd 上的请求。这个时候，A、B、C…等多个子进程分别创建自己独立的 epoll fd，然后将同一个 listen fd 加入到 epoll 中，监听其可读事件。这种情况下，epoll 有以下这些特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 由于相对同一个listen fd而言， 多个进程之间的epoll是平等的，于是，listen fd上的一个请求上来，会唤醒所有睡眠在listen fd睡眠队列上的epoll，epoll又唤醒对应的进程task，从而唤醒所有的进程(这里不管listen fd是以LT还是ET模式加入到epoll)。</span><br><span class="line">[2] 多个进程间的epoll是独立的，对epoll fd的相关epoll_ctl操作相互独立不影响。</span><br></pre></td></tr></table></figure>

<p>可以看出，在使用友好度方面，多进程独立 epoll 实例要比共用 epoll 实例的模式要好很多。独立 epoll 模式要解决 fd 的排他唤醒 epoll 即可。</p>
</blockquote>
<p>3.9以上内核版本的linux，在内核中解决了惊群问题；而且性能比官方nginx解决办法效率高很多；<br>reuseport【复用端口】,是一种套接字的复用机制，允许将多个套接字bind到同一个ip地址/端口上，这样一来，就可以建立多个服务器来接收到同一个端口的连接【多个worker进程能够监听同一个端口】；</p>
<blockquote>
<p>于是，基本的解决方案是起多个 listen socket，好在我们有 SO_REUSEPORT(linux 3.9 以上内核支持)，它支持多个进程或线程 bind 相同的 ip 和端口，支持以下特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] 允许多个socket bind/listen在相同的IP，相同的TCP/UDP端口</span><br><span class="line">[2] 目的是同一个IP、PORT的请求在多个listen socket间负载均衡</span><br><span class="line">[3] 安全上，监听相同IP、PORT的socket只能位于同一个用户下</span><br></pre></td></tr></table></figure>
</blockquote>
<p><del>但是注意目前master进程中在ngx_open_listening_sockets创建了一个监听套接字，创建了四个worker进程的监听套接字和master套接字是同一个，即使设置了reuseport仍然会产生惊群现象、</del></p>
<p>于是，在一个多核 CPU 的服务器上，我们通过 SO_REUSEPORT 来创建多个监听相同 IP、PORT 的 listen socket，<strong>每个进程监听不同的 listen socket</strong>。这样，在只有 1 个新请求到达监听的端口的时候，内核只会唤醒一个进程去 accept，而在同时并发多个请求来到的时候，内核会唤醒多个进程去 accept，并且在一定程度上保证唤醒的均衡性。</p>
<p>看了这位腾讯 IEG 后台开发工程师的文章，我选择了试着<strong>在worker进程中使用ngx_open_listening_sockets，每个worker进程都会创建一个监听套接字listenfd，然后使用reuseport。</strong>这样就不再造成惊群了。</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220310112238815.png" alt="image-20220310112238815"></p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>从两个方面看下性能优化问题；</p>
<p>软件层面：</p>
<ol>
<li>充分利用cpu，比如<strong>惊群问题</strong>；</li>
<li>深入了解tcp/ip协议，通过一些协议参数配置来进一步改善性能；</li>
<li>处理业务逻辑方面，算法方面有些内容，可以提前做好；</li>
</ol>
<p>硬件层面【花钱搞定】：</p>
<ol>
<li>高速网卡，增加网络带宽；</li>
<li>专业服务器；数十个核心，马力极其强；</li>
<li>内存：容量大，访问速度快；</li>
<li>主板，总线不断升级的；</li>
</ol>
<h3 id="性能优化的实施"><a href="#性能优化的实施" class="headerlink" title="性能优化的实施"></a>性能优化的实施</h3><h4 id="绑定cpu、提升进程优先级"><a href="#绑定cpu、提升进程优先级" class="headerlink" title="绑定cpu、提升进程优先级"></a>绑定cpu、提升进程优先级</h4><ul>
<li>一个worker进程运行在一个核上；为什么能够提高性能呢？</li>
</ul>
<p>cpu：缓存；cpu缓存命中率问题；把进程固定到cpu核上，可以大大增加cpu缓存命中率，从而提高程序运行效率；<br>nginx官方有一个函数worker_cpu_affinity【cpu亲和性】，就是为了把worker进程固定的绑到某个cpu核上；<br>ngx_set_cpu_affinity,ngx_setaffinity;</p>
<ul>
<li>提升进程优先级,这样这个进程就有机会被分配到更多的cpu时间（时间片【上下文切换】），得到执行的机会就会增多；</li>
</ul>
<p>setpriority()；</p>
<p>干活时进程 处于R状态，没有连接连入时，进程处于S</p>
<p>pidstat - w - p 3660 1   看某个进程的上下文切换次数[切换频率越低越好]</p>
<p><img src="/../images/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/image-20220217201040281.png" alt="image-20220217201040281"></p>
<p>cswch/s：主动切换/秒：你还有运行时间，但是因为你等东西，你把自己挂起来了，让出了自己时间片。</p>
<p>nvcswch/s：被动切换/秒：时间片耗尽了，你必须要切出去；</p>
<ul>
<li>一个服务器程序，一般只放在一个计算机上跑,专用机；</li>
</ul>
<h4 id="TCP-IP协议的配置选项"><a href="#TCP-IP协议的配置选项" class="headerlink" title="TCP / IP协议的配置选项"></a>TCP / IP协议的配置选项</h4><p>这些配置选项都有缺省值，通过修改，在某些场合下，对性能可能会有所提升；</p>
<p>若要修改这些配置项，要求做到以下几点：</p>
<ol>
<li>对这个配置项有明确的理解；</li>
<li>对相关的配置项,记录他的缺省值，做出修改；</li>
<li>要反复不断的亲自测试，亲自验证；是否提升性能，是否有副作用；</li>
</ol>
<h4 id="TCP-IP协议的配置选项-1"><a href="#TCP-IP协议的配置选项-1" class="headerlink" title="TCP / IP协议的配置选项"></a>TCP / IP协议的配置选项</h4><ol>
<li>绑定cpu、提升进程优先级</li>
<li>TCP / IP协议的配置选项</li>
<li>TCP/IP协议额外注意的一些算法、概念等</li>
</ol>
<h4 id="配置最大允许打开的文件句柄数"><a href="#配置最大允许打开的文件句柄数" class="headerlink" title="配置最大允许打开的文件句柄数"></a>配置最大允许打开的文件句柄数</h4><p>cat /proc/sys/fs/file-max  ：查看操作系统可以使用的最大句柄数<br>cat /proc/sys/fs/file-nr   ：查看当前已经分配的，分配了没使用的，文件句柄最大数目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/nginx$ sudo cat /proc/sys/fs/file-max</span><br><span class="line">9223372036854775807</span><br><span class="line">fengyun@ubuntu:~/share/nginx$ sudo cat /proc/sys/fs/file-nr</span><br><span class="line">7872	0	9223372036854775807</span><br></pre></td></tr></table></figure>

<p>限制用户使用的最大句柄数<br> /etc/security/limit.conf文件；<br>root soft nofile 60000  :setrlimit(RLIMIT_NOFILE)<br>root hard nofile 60000</p>
<p>ulimit -n ：查看系统允许的当前用户进程打开的文件数限制<br>ulimit -HSn 5000   ：临时设置，只对当前session有效；<br>n:表示我们设置的是文件描述符<br>推荐文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xyang81/article/details/52779229">https://blog.csdn.net/xyang81/article/details/52779229</a></p>
<h3 id="内存池补充说明"><a href="#内存池补充说明" class="headerlink" title="内存池补充说明"></a>内存池补充说明</h3><p>为什么没有用内存池技术：感觉必要性不大，等待有时间再补充一下吧。<br>TCMalloc,取代malloc();<br>库地址：<a target="_blank" rel="noopener" href="https://github.com/gperftools/gperftools">https://github.com/gperftools/gperftools</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">长烟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yunf194.github.io/2022/03/01/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">http://yunf194.github.io/2022/03/01/202231-nginx%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yunf194.github.io" target="_blank">fengyun's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nginx/">nginx</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/nginx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/02/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"><img class="prev-cover" src="/images/cover/p11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">。。。。。</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/01/202231-%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src="/images/cover/p11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/25/2022125-Makefile/" title="Makefile"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">Makefile</div></div></a></div><div><a href="/2022/01/24/2022124-fork()%E4%B8%8E%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" title="fork()"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">fork()</div></div></a></div><div><a href="/2022/01/25/2022125-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" title="守护进程"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">守护进程</div></div></a></div><div><a href="/2022/01/29/2022129-%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/" title="日志功能"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-29</div><div class="title">日志功能</div></div></a></div><div><a href="/2022/02/11/2022211-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/" title="服务器设计"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">服务器设计</div></div></a></div><div><a href="/2022/02/07/202226-%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD/" title="信号功能部分"><img class="cover" src="/images/cover/nginx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-07</div><div class="title">信号功能部分</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunf194.github.io/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">长烟</div><div class="author-info__description">交际是分享快乐，独处是消化自我</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunf194"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yunf194" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2846327307@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我明白你会来所以我等</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">main函数程序入口函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#master%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">master进程工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-master-process-cycle%EF%BC%88master%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">ngx_master_process_cycle（master进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-spawn-process%EF%BC%88master%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">ngx_spawn_process（master进程创建子进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-open-listening-sockets%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E5%B9%B6%E4%B8%94%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88worker%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">ngx_open_listening_sockets监听端口并且初始化（worker）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">worker进程初始化工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-worker-process-init"><span class="toc-number">3.1.</span> <span class="toc-text">ngx_worker_process_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialize-subproc%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%8D%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">Initialize_subproc子进程中才需要执行的初始化函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-epoll-init"><span class="toc-number">3.3.</span> <span class="toc-text">ngx_epoll_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-close-connection%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.4.</span> <span class="toc-text">ngx_close_connection直接关闭连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-epoll-oper-event%E5%AF%B9epoll%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">ngx_epoll_oper_event对epoll事件的具体操作（增删改）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%EF%BC%88%E8%AF%BB%E3%80%81%E5%86%99%EF%BC%89%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">worker子进程处理网络事件（读、写）和定时器事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bngx-epoll-process-events"><span class="toc-number">4.1.</span> <span class="toc-text">事件驱动模型ngx_epoll_process_events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E5%85%A5%E4%BA%8B%E4%BB%B6ngx-event-accept"><span class="toc-number">4.2.</span> <span class="toc-text">处理三次握手连入事件ngx_event_accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86TCP%E8%BF%9E%E6%8E%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AEngx-read-request-handler"><span class="toc-number">4.3.</span> <span class="toc-text">处理TCP连接客户端发来的数据ngx_read_request_handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#recvproc"><span class="toc-number">4.3.1.</span> <span class="toc-text">recvproc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ngx-wait-request-handler-proc-p1"><span class="toc-number">4.3.2.</span> <span class="toc-text">ngx_wait_request_handler_proc_p1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ngx-wait-request-handler-proc-plast"><span class="toc-number">4.3.3.</span> <span class="toc-text">ngx_wait_request_handler_proc_plast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inMsgRecvQueueAndSignal"><span class="toc-number">4.3.4.</span> <span class="toc-text">inMsgRecvQueueAndSignal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Call"><span class="toc-number">4.3.5.</span> <span class="toc-text">Call</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86TCP%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">4.4.</span> <span class="toc-text">处理TCP连接发送数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#msgSend%E5%BE%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%85%A5%E5%88%B0%E5%8F%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">msgSend待发送消息入到发消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSendQueueThread%E5%A4%84%E7%90%86%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">ServerSendQueueThread处理发送消息队列的线程*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendproc%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E4%B8%93%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">sendproc发送数据专用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ngx-write-request-handler-epoll%E9%80%9A%E7%9F%A5%E5%90%8E%E5%B0%B1%E8%B0%83%E7%94%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.4.</span> <span class="toc-text">ngx_write_request_handler(epoll通知后就调用这个函数)*</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">连接池类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initconnection%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">5.2.</span> <span class="toc-text">initconnection初始化连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetOneToUse-%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">GetOneToUse()连接初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-get-connection"><span class="toc-number">5.3.</span> <span class="toc-text">ngx_get_connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clearconnection"><span class="toc-number">5.4.</span> <span class="toc-text">clearconnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-free-connection-%E7%AB%8B%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">5.5.</span> <span class="toc-text">ngx_free_connection()立即回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PutOneToFree"><span class="toc-number">5.5.1.</span> <span class="toc-text">PutOneToFree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inRecyConnectQueue%E5%BB%B6%E6%97%B6%E5%9B%9E%E6%94%B6"><span class="toc-number">5.6.</span> <span class="toc-text">inRecyConnectQueue延时回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerRecyConnectionThread%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%9B%9E%E6%94%B6%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">ServerRecyConnectionThread处理连接回收的线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88worker%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">创建线程池（worker进程中执行）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create-%E4%BC%9A%E6%BF%80%E5%8F%91%E7%BA%BF%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0ThreadFunc"><span class="toc-number">6.2.1.</span> <span class="toc-text">Create()会激发线程入口函数ThreadFunc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadFunc-%E7%BA%BF%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">ThreadFunc()线程入口函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.3.</span> <span class="toc-text">线程处理消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadRecvProcFunc"><span class="toc-number">6.3.1.</span> <span class="toc-text">threadRecvProcFunc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.4.</span> <span class="toc-text">释放线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StopAll"><span class="toc-number">6.4.1.</span> <span class="toc-text">StopAll()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number">7.</span> <span class="toc-text">业务逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">7.1.</span> <span class="toc-text">心跳包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%8F%91%E6%9D%A5%E7%9A%84%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">7.1.1.</span> <span class="toc-text">处理发来的心跳包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HandlePing"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">_HandlePing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SendNoBodyPkgToClient"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">SendNoBodyPkgToClient</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%BF%83%E8%B7%B3%E6%97%B6%E9%97%B4"><span class="toc-number">7.1.2.</span> <span class="toc-text">检测心跳时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSocekt-AddToTimerQueue"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">CSocekt::AddToTimerQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSocekt-ServerSendQueueThread%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E9%98%9F%E5%88%97%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">CSocekt::ServerSendQueueThread处理时间队列线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CLogicSocket-procPingTimeOutChecking"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">CLogicSocket::procPingTimeOutChecking</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSocekt-DeleteFromTimerQueue"><span class="toc-number">7.1.2.5.</span> <span class="toc-text">CSocekt::DeleteFromTimerQueue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97"><span class="toc-number">8.</span> <span class="toc-text">其他模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%87%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text">设置文件标题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ngx-init-setproctitle%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8B%B7%E8%B4%9D%E5%88%B0%E6%96%B0%E5%86%85%E5%AD%98"><span class="toc-number">8.2.1.</span> <span class="toc-text">ngx_init_setproctitle环境变量拷贝到新内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ngx-setproctitle%E8%AE%BE%E7%BD%AE%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A0%87%E9%A2%98"><span class="toc-number">8.2.2.</span> <span class="toc-text">ngx_setproctitle设置可执行程序标题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><span class="toc-number">8.3.</span> <span class="toc-text">日志模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%8A%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E6%92%91%E6%BB%A1"><span class="toc-number">9.1.</span> <span class="toc-text">如何把发送缓冲区撑满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-number">9.2.</span> <span class="toc-text">高并发测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83"><span class="toc-number">9.3.</span> <span class="toc-text">安全问题思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E8%8C%83SYN-Flood%E6%94%BB%E5%87%BB"><span class="toc-number">9.3.1.</span> <span class="toc-text">防范SYN Flood攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%88%B0%E5%A4%AA%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%84%E7%90%86%E4%B8%8D%E8%BF%87%E6%9D%A5"><span class="toc-number">9.3.2.</span> <span class="toc-text">收到太多数据包处理不过来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%AF%E5%8E%8B%E5%A4%AA%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E4%B8%8D%E5%87%BA%E5%8E%BB"><span class="toc-number">9.3.3.</span> <span class="toc-text">积压太多数据包发送不出去</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E5%85%A5%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AE%8C%E5%96%84"><span class="toc-number">9.3.4.</span> <span class="toc-text">连入安全的进一步完善</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">9.4.</span> <span class="toc-text">压力测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%98%AF1018"><span class="toc-number">9.4.1.</span> <span class="toc-text">最大连接是1018</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%8A%E7%BE%A4"><span class="toc-number">9.5.</span> <span class="toc-text">惊群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E6%96%BD"><span class="toc-number">10.1.</span> <span class="toc-text">性能优化的实施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9Acpu%E3%80%81%E6%8F%90%E5%8D%87%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.1.1.</span> <span class="toc-text">绑定cpu、提升进程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="toc-number">10.1.2.</span> <span class="toc-text">TCP &#x2F; IP协议的配置选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9-1"><span class="toc-number">10.1.3.</span> <span class="toc-text">TCP &#x2F; IP协议的配置选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9C%80%E5%A4%A7%E5%85%81%E8%AE%B8%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0"><span class="toc-number">10.1.4.</span> <span class="toc-text">配置最大允许打开的文件句柄数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">10.2.</span> <span class="toc-text">内存池补充说明</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GO的双向tls通信"/></a><div class="content"><a class="title" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信">基于GO的双向tls通信</a><time datetime="2023-01-06T16:00:00.000Z" title="发表于 2023-01-07 00:00:00">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入"/></a><div class="content"><a class="title" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2022-12-06T16:00:00.000Z" title="发表于 2022-12-07 00:00:00">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传漏洞"/></a><div class="content"><a class="title" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞">文件上传漏洞</a><time datetime="2022-12-05T16:00:00.000Z" title="发表于 2022-12-06 00:00:00">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之包"/></a><div class="content"><a class="title" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包">Go语言基础之包</a><time datetime="2022-10-22T16:00:00.000Z" title="发表于 2022-10-23 00:00:00">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之函数"/></a><div class="content"><a class="title" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数">Go语言基础之函数</a><time datetime="2022-10-21T16:00:00.000Z" title="发表于 2022-10-22 00:00:00">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/nginx.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 长烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">其实，我回头等了你好久好久，你都没来</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Yb0FJoeuYRJfbYGupEnFsg6E-gzGzoHsz',
      appKey: 'Pjo4dvB3TbjfY8clnS7fxalh',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://yunf194.github.io/css/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://yunf194.github.io/css/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>