<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>。。。。。 | fengyun's Blog</title><meta name="keywords" content="C++"><meta name="author" content="长烟"><meta name="copyright" content="长烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] C++基础[TOC] 类的构造函数、析构函数、赋值函数、拷贝函数赋值函数和拷贝构造函数的区别？构造函数 对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数 拷贝构造函数 对象不存在，但是使用别的已经存在的对象来进行初始化 赋值运算符 对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”号两侧的对象都是已存在的 区别：  拷贝构造函数是函数，赋值运算符是运算">
<meta property="og:type" content="article">
<meta property="og:title" content="。。。。。">
<meta property="og:url" content="http://yunf194.github.io/2022/03/02/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/index.html">
<meta property="og:site_name" content="fengyun&#39;s Blog">
<meta property="og:description" content="[TOC] C++基础[TOC] 类的构造函数、析构函数、赋值函数、拷贝函数赋值函数和拷贝构造函数的区别？构造函数 对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数 拷贝构造函数 对象不存在，但是使用别的已经存在的对象来进行初始化 赋值运算符 对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”号两侧的对象都是已存在的 区别：  拷贝构造函数是函数，赋值运算符是运算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yunf194.github.io/images/cover/p11.jpg">
<meta property="article:published_time" content="2022-03-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-18T09:43:48.129Z">
<meta property="article:author" content="长烟">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yunf194.github.io/images/cover/p11.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://yunf194.github.io/2022/03/02/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b5317a4316878223f02ccad7d028fa5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '。。。。。',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-18 17:43:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunf194.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/p11.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">fengyun's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">。。。。。</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-01T16:00:00.000Z" title="发表于 2022-03-02 00:00:00">2022-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-18T09:43:48.129Z" title="更新于 2022-09-18 17:43:48">2022-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">54.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>170分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="。。。。。"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><p>[TOC]</p>
<h3 id="类的构造函数、析构函数、赋值函数、拷贝函数"><a href="#类的构造函数、析构函数、赋值函数、拷贝函数" class="headerlink" title="类的构造函数、析构函数、赋值函数、拷贝函数"></a>类的构造函数、析构函数、赋值函数、拷贝函数</h3><h4 id="赋值函数和拷贝构造函数的区别？"><a href="#赋值函数和拷贝构造函数的区别？" class="headerlink" title="赋值函数和拷贝构造函数的区别？"></a><strong>赋值函数和拷贝构造函数的区别？</strong></h4><p><strong>构造函数</strong></p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p><strong>拷贝构造函数</strong></p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p><strong>赋值运算符</strong></p>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<p><strong>区别：</strong></p>
<ol>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p>
</li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p>
</li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="移动构造函数与拷贝构造函数对比"><a href="#移动构造函数与拷贝构造函数对比" class="headerlink" title="移动构造函数与拷贝构造函数对比"></a><strong>移动构造函数与拷贝构造函数对比</strong></h4><ol>
<li><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p>
</li>
<li><p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p>
<p>1）拷贝构造函数的形参是一个<strong>左值引用</strong>，而移动构造函数的形参是一个右值引用；</p>
<p>2）拷贝构造函数完成的<strong>是整个对象或变量的拷贝</strong>，而移动构造函数是<strong>生成一个指针指向源对象或变量的地址</strong>，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</p>
</li>
</ol>
<h4 id="构造函数和析构函数抛出异常？"><a href="#构造函数和析构函数抛出异常？" class="headerlink" title="构造函数和析构函数抛出异常？"></a><strong>构造函数和析构函数抛出异常？</strong></h4><p><strong>(1)构造函数可以抛出异常</strong></p>
<p>无论何时，从构造函数中抛出异常都是可以的。动态创建对象要进行两个操作：分配内存和调用构造函数。若在分配内存时出错，会抛出bad_alloc异常；若在调用构造函数初始化时出错，会不会存在内存泄漏呢？答案是不会。new运算符保证不会出现内存泄漏：</p>
<p><strong>(2)析构函数不推荐抛出异常，如果析构函数可能抛出异常，那么必须要求在析构函数内消化所有异常或者结束程序。</strong></p>
<p>more effective c++提出两点理由（析构函数不能抛出异常的理由）</p>
<p>1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 [正常情况下调用析构函数抛出异常导致资源泄露]</p>
<p>2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 [在发生异常的情况下调用析构函数抛出异常，会导致程序崩溃]</p>
<p> 解决方案：</p>
<ol>
<li><p>如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。</p>
</li>
<li><p>如果析构函数中异常非抛不可，那就用try catch来将异常吞下，必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。</p>
</li>
</ol>
<h4 id="构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h4><p><strong>1) 构造函数顺序</strong></p>
<p>① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p>
<p>② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p>
<p>③ 派生类构造函数。</p>
<p><strong>2) 析构函数顺序</strong></p>
<p>① 调用派生类的析构函数；</p>
<p>② 调用成员类对象的析构函数；</p>
<p>③ 调用基类的析构函数。</p>
<h3 id="C-与C的区别"><a href="#C-与C的区别" class="headerlink" title="C++与C的区别"></a>C++与C的区别</h3><ol>
<li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等。</li>
<li>C++是<strong>面对对象</strong>的编程语言；C语言是<strong>面对过程</strong>的编程语言。</li>
<li>C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来<strong>改善安全性</strong>，如const常量、引用、cast转换、智能指针、try—catch等等；</li>
<li>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库<strong>更灵活、更通用</strong>。</li>
</ol>
<ul>
<li><h3 id="struct与class的区别-4点"><a href="#struct与class的区别-4点" class="headerlink" title="struct与class的区别(4点)"></a>struct与class的区别(4点)</h3></li>
</ul>
<ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> iNum; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> iNum; <span class="comment">// 默认访问控制权限是 private </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在继承关系中，struct 默认是公有继承，而 class 是私有继承；</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line">&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Y&amp; y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;      <span class="comment">//TODO  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>答案解析</strong></p>
<ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制</td>
<td align="center">默认public，不能修改</td>
<td align="center">public/private/protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可从类或者其他结构体继承</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span>  iAgeNum;  </span><br><span class="line">    string strName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Student2</span>;</span> <span class="comment">//C中取别名  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span> <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line">Student stu3;   <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>C++结构体和C结构体的区别：</strong></p>
<p>（1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。</p>
<p>（2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。</p>
<p>（3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</p>
<p>（4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>（1）const_cast: 把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；</p>
<p>（2）static_cast: 隐式类型转换，用于进行比较“自然”和低风险的转换，可以<strong>实现C++中内置基本数据类型之间的相互转换</strong>，enum、struct、 int、char、float等，<strong>能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）</strong>。它<strong>不能进行无关类型(如非基类和子类)指针之间的转换</strong>，也不能作用包含底层const的对象；</p>
<p>（3）dynamic_cast：动态类型转换，用于<strong>将基类的指针或引用安全地转换成派生类的指针或引用</strong>（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常（基类指针所指对象为基类类型，在这种情况下dynamic_cast在运行时做检查，转换失败，返回结果为0；）。dynamic_cast是在运行时进行安全性检查；<strong>dynamic_cast要求操作对象是指向一个多态类型（含有虚函数）的指针或引用</strong>，否则编译不通过；</p>
<p>（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）</p>
<ul>
<li>static_cast和dynamic_cast的异同点？</li>
</ul>
<p>答：二者都会做类型安全检查，只是static_cast在编译期进行类型检查，dynamic_cast在运行期进行类型检查。后者需要父类具备虚函数，而前者不需要。</p>
<h3 id="多态，虚函数"><a href="#多态，虚函数" class="headerlink" title="多态，虚函数"></a>多态，虚函数</h3><h4 id="什么是多态？C-的多态是如何实现的？"><a href="#什么是多态？C-的多态是如何实现的？" class="headerlink" title="什么是多态？C++的多态是如何实现的？"></a><strong>什么是多态？C++的多态是如何实现的？</strong></h4><p>答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现。</p>
<h4 id="内联函数是虚函数？"><a href="#内联函数是虚函数？" class="headerlink" title="内联函数是虚函数？"></a><strong>内联函数是虚函数？</strong></h4><ol>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li><strong>内联是在编译期建议编译器内联，而虚函数的多态性在运行期</strong>，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ol>
<h4 id="虚函数实现动态多态的原理"><a href="#虚函数实现动态多态的原理" class="headerlink" title="虚函数实现动态多态的原理"></a><strong>虚函数实现动态多态的原理</strong></h4><p>虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。</p>
<h4 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">C++虚函数表解析</a></p>
<ol>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，<strong>在运行时确定</strong>。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a target="_blank" rel="noopener" href="https://github.com/huihut/interview#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在<strong>编译时根据类的声明创建</strong>。（每个包含虚函数的类都有一个虚表，虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。）</li>
</ol>
<h4 id="虚函数表的结构是怎样的？"><a href="#虚函数表的结构是怎样的？" class="headerlink" title="虚函数表的结构是怎样的？"></a><strong>虚函数表的结构是怎样的？</strong></h4><p>虚函数表是一个<strong>函数指针数组，</strong>数组里存放的都是函数指针，指向虚函数所在的位置。 对象调用虚函数时，会根据虚指针找到虚表的位置，再根据虚函数声明的顺序找到虚函数在数组的哪个位置，找到虚函数的地址，从而调用虚函数。</p>
<h4 id="虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？"><a href="#虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？" class="headerlink" title="虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？"></a><strong>虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？</strong></h4><p>答：运行时确定，通过查找虚函数表中的函数地址确定。</p>
<p>更正：此处说法不严谨，应该是<strong>只有通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的</strong>，参考这篇文章，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/491602524/answer/2165605549">虚函数一定是运行期才绑定么？ - 知乎 (zhihu.com)</a></p>
<h4 id="构造函数能不能为虚函数？为什么？"><a href="#构造函数能不能为虚函数？为什么？" class="headerlink" title="构造函数能不能为虚函数？为什么？"></a><strong>构造函数能不能为虚函数？为什么？</strong></h4><p><strong>1、 从存储空间角度，</strong>虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。</p>
<p>问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p>
<p><strong>2、 从使用角度，</strong>虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。</p>
<p>构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。</p>
<p>所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<h4 id="继承时，父类的析构函数是否为虚函数？"><a href="#继承时，父类的析构函数是否为虚函数？" class="headerlink" title="继承时，父类的析构函数是否为虚函数？"></a>继承时，父类的析构函数是否为虚函数？</h4><ol>
<li>C++中基类采用virtual虚析构函数是为了防止内存泄漏。</li>
</ol>
<p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</p>
<p>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</p>
<p>那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p>
<p>所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
<ol start="2">
<li>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</li>
</ol>
<p>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。</p>
<h4 id="在-基类的-构造函数和析构函数中调用虚函数会怎么样？"><a href="#在-基类的-构造函数和析构函数中调用虚函数会怎么样？" class="headerlink" title="在(基类的)构造函数和析构函数中调用虚函数会怎么样？"></a><strong>在(基类的)构造函数和析构函数中调用虚函数会怎么样</strong>？</h4><p>可以，虚函数底层实现原理(但是最好不要在构造和析构函数中调用) 可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 这是因为在定义子类对象的时候，会先调用父类的构造函数，<strong>而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存</strong>，C++标准规范中规定了在这种情况下，<strong>即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。</strong>所以使用的是静态绑定，调用了父类的函数。绝不在构造和析构函数中调用virtual函数：</p>
<ol>
<li>不要在构造函数中调用虚函数的原因：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。</li>
<li>不要在析构函数中调用虚函数的原因：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</li>
<li>总之，在构造和析构函数中，不要用虚函数。如果必须用，那么分离出一个Init函数和一个close函数，实现相关功能即可。</li>
</ol>
<h4 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a><strong>虚函数、纯虚函数</strong></h4><ol>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h4 id="静态函数可以是虚函数么？为什么？"><a href="#静态函数可以是虚函数么？为什么？" class="headerlink" title="静态函数可以是虚函数么？为什么？"></a><strong>静态函数可以是虚函数么？为什么？</strong></h4><ol>
<li>static成员<strong>不属于任何类对象或类实例</strong>，所以即使给此函数加上virutal也是没有任何意义的。</li>
<li>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数<strong>没有this指针</strong>。所以无法访问vptr. 进而不能访问虚函数表。</li>
</ol>
<ul>
<li><p><strong>静态类型和动态类型，静态绑定和动态绑定的介绍</strong></p>
<ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。 举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">    A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">    pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">    C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">    pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则运行结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，</p>
<ul>
<li><p>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</p>
</li>
<li><p>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</p>
</li>
<li><p>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</p>
<p><strong>本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。</strong></p>
</li>
</ul>
<p>至此总结一下静态绑定和动态绑定的区别：</p>
<ul>
<li>静态绑定发生在编译期，动态绑定发生在运行期；</li>
<li>对象的动态类型可以更改，但是静态类型无法更改；</li>
<li>要想实现动态，必须使用动态绑定；</li>
<li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li>
</ul>
</li>
</ul>
<h3 id="类的内存模型，继承问题"><a href="#类的内存模型，继承问题" class="headerlink" title="类的内存模型，继承问题"></a>类的内存模型，继承问题</h3><h4 id="c-中类对象的内存模型-布局-是怎么样的？"><a href="#c-中类对象的内存模型-布局-是怎么样的？" class="headerlink" title="c++中类对象的内存模型(布局)是怎么样的？"></a>c++中类对象的内存模型(布局)是怎么样的？</h4><p>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yunlambert/p/9876491.html">C++内存模型 - MrYun - 博客园 (cnblogs.com)</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012658346/article/details/50775742">C++内存布局（上）_qinm的专栏-CSDN博客</a></p>
<p>答：一般遵循以下几点原则：</p>
<p>（1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；</p>
<p>（2）除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；</p>
<p>（3）如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且<strong>按照继承顺序布局(虚表指针+字段）</strong>；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面；</p>
<p>（4）如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。</p>
<h4 id="C-中类的数据成员和成员函数内存分布情况"><a href="#C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="C++中类的数据成员和成员函数内存分布情况"></a>C++中类的数据成员和成员函数内存分布情况</h4><p>对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<p>要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。</p>
<p>我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。</p>
<p>就像我前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p>
<h4 id="钻石-菱形-继承存在什么问题，如何解决？"><a href="#钻石-菱形-继承存在什么问题，如何解决？" class="headerlink" title="钻石(菱形)继承存在什么问题，如何解决？"></a><strong>钻石(菱形)继承存在什么问题，如何解决</strong>？</h4><p>【参考资料】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tounaobun/article/details/8443228">C++之钻石问题和解决方案（菱形继承问题）_Benson的专栏-CSDN博客</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/duwenxing/p/7492247.html">C++：钻石继承与虚继承 - Tom文星 - 博客园 (cnblogs.com)</a>、<a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98/%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98?id=20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF">什么是虚拟继承</a></p>
<p>答：会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。</p>
<h4 id="空类有哪些函数？空类的大小？"><a href="#空类有哪些函数？空类的大小？" class="headerlink" title="空类有哪些函数？空类的大小？"></a><strong>空类有哪些函数？空类的大小？</strong></h4><p>如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">构造函数</a>、一个拷贝默认构造函数、一个默认拷贝赋值操作符、一个默认析构函数、取址运算符和一个取址运算符const。这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Empty</span>(); <span class="comment">// 缺省构造函数//</span></span><br><span class="line"><span class="built_in">Empty</span>( <span class="keyword">const</span> Empty&amp; ); <span class="comment">// 拷贝构造函数//</span></span><br><span class="line">~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数//</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> Empty&amp; ); <span class="comment">// 赋值运算符//</span></span><br><span class="line">Empty* <span class="keyword">operator</span>&amp;(); <span class="comment">// 取址运算符</span></span><br><span class="line"><span class="keyword">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>; <span class="comment">// 取址运算符 const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本来按道理而言空类应该是0个字节，<strong>但是在C++中空类会占1个字节，这是为了让对象的实例能够相互区别</strong>。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，因为实例化的过程就是在内存中分配一块地址。</p>
<h4 id="请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="请说一下以下几种情况下，下面几个类的大小各是多少？"></a>请说一下以下几种情况下，下面几个类的大小各是多少？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">    A a; </span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">    A a; </span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; <span class="keyword">int</span> b; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">    A a; </span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><ul>
<li>this指针是类的指针，指向对象的首地址。</li>
<li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li>
<li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li>
</ul>
<h5 id="类的this指针有以下特点"><a href="#类的this指针有以下特点" class="headerlink" title="类的this指针有以下特点"></a><strong>类的this指针有以下特点</strong></h5><p>(1）<strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T * const this</strong></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>func</strong>的原型在编译器看来应该是：</p>
<p><strong>int func(A * const this,int p);</strong></p>
<p>（2）由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a;a.<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//此处，编译器将会编译成：A::func(&amp;a,10);</span></span><br></pre></td></tr></table></figure>

<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h5 id="this指针调用成员变量时，堆栈会发生什么变化？"><a href="#this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="this指针调用成员变量时，堆栈会发生什么变化？"></a>this指针调用成员变量时，堆栈会发生什么变化？</h5><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h5 id="delete-this会出现什么问题？对象还可以使用吗？"><a href="#delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="delete this会出现什么问题？对象还可以使用吗？"></a>delete this会出现什么问题？对象还可以使用吗？</h5><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，<strong>只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</strong></p>
<h5 id="为什么是不可预期的问题？"><a href="#为什么是不可预期的问题？" class="headerlink" title="为什么是不可预期的问题？"></a>为什么是不可预期的问题？</h5><p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。<strong>delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</strong>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<h5 id="如果在类的析构函数中调用delete-this，会发生什么？"><a href="#如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="如果在类的析构函数中调用delete this，会发生什么？"></a>如果在类的析构函数中调用delete this，会发生什么？</h5><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="内存管理（内存分配、内存对齐）"><a href="#内存管理（内存分配、内存对齐）" class="headerlink" title="内存管理（内存分配、内存对齐）"></a><strong>内存管理（内存分配、内存对齐）</strong></h3><h4 id="C-的内存分区：全局区、堆区、栈区、常量区、代码区"><a href="#C-的内存分区：全局区、堆区、栈区、常量区、代码区" class="headerlink" title="C++的内存分区：全局区、堆区、栈区、常量区、代码区"></a>C++的内存分区：全局区、堆区、栈区、常量区、代码区</h4><ol>
<li><blockquote>
<p>栈区（stack）:存放函数形参和局部变量（auto类型），由编译器自动分配和释放</p>
</blockquote>
</li>
<li><blockquote>
<p>堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由OS回收。</p>
</blockquote>
</li>
<li><blockquote>
<p>全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块</p>
</blockquote>
</li>
<li><blockquote>
<p>文字常量区：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。</p>
</blockquote>
</li>
<li><blockquote>
<p>程序代码区：存放程序的二进制代码，内存由系统管理</p>
</blockquote>
</li>
</ol>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220302172646048.png" alt="image-20220302172646048"></p>
<p>一个程序的3个基本段：text段，data段，bss段</p>
<ul>
<li>text段在内存中被映射为只读，但data段与bss段是可写的</li>
<li>text段：代码段，就是放程序代码的，编译时确定，只读</li>
<li>data段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域</li>
<li>bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。</li>
</ul>
<h4 id="堆和栈的内存有什么区别？"><a href="#堆和栈的内存有什么区别？" class="headerlink" title="堆和栈的内存有什么区别？"></a><strong>堆和栈的内存有什么区别？</strong></h4><p>（1）堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；</p>
<p>（2）堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）；</p>
<p>（3）在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片；</p>
<p>（4）堆的分配效率低，栈的分配效率高；</p>
<p>（5）堆地址从低向上，栈由高向下。</p>
<h4 id="C-和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？"><a href="#C-和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？" class="headerlink" title="C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？"></a><strong>C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？</strong></h4><p>C使用malloc/free，C++使用new/delete，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下：</p>
<p>（1）new分配内存空间无需指定分配内存大小，malloc需要；</p>
<p>（2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；</p>
<p>（3）new是从自由存储区获得内存，malloc从堆中获取内存；</p>
<p>（4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。</p>
<h4 id="什么是内存对齐-字节对齐-，为什么要做内存对齐，如何对齐？"><a href="#什么是内存对齐-字节对齐-，为什么要做内存对齐，如何对齐？" class="headerlink" title="什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？"></a><strong>什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？</strong></h4><p>对齐参数 偏移地址 大小  满足<code>偏移地址%对齐参数 == 0</code></p>
<p>（1）内存对齐的原因：关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度；</p>
<p>（2）内容：内存对齐指的是C++结构体中的数据成员，其内存地址是否为其对齐字节大小的倍数。</p>
<p>（3）<strong>对齐原则</strong>：1）结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除；2）结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除；3）结构体总体大小能够被最宽成员大小整除；如果不满足这些条件，编译器就会进行一个填充(padding)。</p>
<p>（4）如何对齐<strong>：</strong>声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间。</p>
<h4 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a><strong>什么是内存泄露？</strong></h4><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放； 使用智能指针shared_ptr时，产生循环引用，导致内存无法释放，会造成内存泄漏；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p>
<ul>
<li><strong>怎么检测？</strong></li>
</ul>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
<h4 id="valgrind原理"><a href="#valgrind原理" class="headerlink" title="valgrind原理"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinliyinli/article/details/51346431">valgrind原理</a></h4><p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Center.jpeg" alt="img"></p>
<p>1，当要读写内存中的某个字节时，首先检查这个字节对应的A bit。如果该A bit显示该位置是无效位置，memcheck则会报告读写错误</p>
<p>2，内核（core）类似于一个虚拟的CPU环境，这样当内存中的某个字节被加载到真实的CPU时，该字节对应的V bit也会被加载到虚拟的CPU环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则memcheck会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</p>
<h3 id="内存new-malloc-delete-free使用情况"><a href="#内存new-malloc-delete-free使用情况" class="headerlink" title="内存new/malloc/delete/free使用情况"></a>内存new/malloc/delete/free使用情况</h3><ul>
<li><strong>new operator和operatornew的区别？</strong></li>
</ul>
<p>new就是new operator，调用new的时候编译器做了三件事，</p>
<p>1.是用operator new( )分配内存，</p>
<p>2.是调用构造函数（就是你new的类类型或者string等类型的构造函数）。</p>
<p>3.返回相应的指针。</p>
<p>new的底层是调用operator new( )分配内存的。该函数调用malloc申请内存。</p>
<p>参考链接：[C++ operator new和new operator区别](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26079093/article/details/94211205#:~:text=06-11">https://blog.csdn.net/qq_26079093/article/details/94211205#:~:text=06-11</a>. 990. 一、 new operator 与 operator new,内存分配 ( new ， operator new )面面观 （转）).</p>
<p>连接里面的handle函数是自定义的异常处理函数。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songchuwang1868/article/details/81353577">深入解析new、operator new、::new、placement new</a></p>
<ul>
<li><strong>面试管说还有一个placement new知道么？</strong></li>
</ul>
<p>保持一块内存，反复构造析构，这样可以省略中间的多次分配内存。</p>
<p>在使用new关键字建立一个新的对象的时候，在编译器的第二步就是调用对象的构造函数生成类对象。这一步使用的就是placement new来实现的，即在取得了一块可以容纳指定类型对象的内存之后，在这块内存上构造一个对象。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26822029/article/details/81213537">C++中new、operator new和placement new的区别</a></p>
<ul>
<li><strong>malloc的底层实现原理是什么？</strong></li>
</ul>
<p>申请内存小于128k用brk()函数。大于128k用mmap()函数。</p>
<p>1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)</p>
<p>2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。</p>
<p>具体细节参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpcoding/p/10808969.html">malloc 底层实现及原理 - 爱笑的张飞 - 博客园</a></p>
<p>讲的很清楚了。</p>
<p><strong>同时为了方便申请内存更加高效和减少内存碎片，使用了内存池的设计方式。</strong></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7af62431983e">malloc底层实现及原理</a>泄露的情况</p>
<ul>
<li><strong>野指针产生与避免</strong></li>
</ul>
<p>野指针产生的原因：</p>
<ol>
<li>创建指针时没有对指针进行初始化，导致指针指向一个随机的位置；</li>
<li>释放指针指向的内存后没有置空，从而指向垃圾内存；</li>
<li>在超越变量作用域下使用指针，如：在栈内存被释放之后，指向栈内存的指针会指向垃圾内存；</li>
</ol>
<p>野指针的避免方法：</p>
<ol>
<li>在创建指针时必须进行初始化；</li>
<li>使用delete释放指针指向的内存之后必须将指针置空；</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zpznba/article/details/89676271"><strong>delete[]怎么知道释放内存的大小？</strong></a></li>
</ul>
<p>需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>
<ul>
<li><strong>delete this会发生什么？</strong></li>
</ul>
<p>在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。假设这个成员函数名字叫release，而delete this就在这个release方法中被调用，那么这个对象在调用release方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用release之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样 了。</p>
<p>根本原因在于delete操作符的功能和类对象的内存模型。当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当 调用delete this时，类对象的内存空间被释放。<strong>在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</strong></p>
<p>为什么是不可预期的问题？delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=54%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C-delete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%9F"><strong>new和delete的实现原理， delete是如何知道释放内存的大小的？</strong></a></p>
<p>1、 new简单类型直接调用operator new分配内存；</p>
<p>而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p>
<p>对于简单类型，new[]计算好大小后调用operator new；</p>
<p>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p>
<p>① new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</p>
<p>② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p>
<p>③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
<p>2、 delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p>
<p>3、 需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=55%E3%80%81malloc%E7%94%B3%E8%AF%B7%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%83%BD%E7%94%A8delete%E9%87%8A%E6%94%BE%E5%90%97">malloc申请的存储空间能用delete释放吗?</a></strong></p>
<p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。</p>
<p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p>
<p>new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</p>
<p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>
</li>
</ul>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：</p>
<p>（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p>
<p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p>
<p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<ul>
<li><strong>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？</strong></li>
</ul>
<p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p>
<p>（2）具体实现：</p>
<p>1）构造函数：将指针指向该对象，引用计数置为1；</p>
<p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p>
<p>3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p>
<p>（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1654442">shared_ptr是线程安全的吗？ - 云+社区 - 腾讯云 (tencent.com)</a> <code>shared_ptr&lt;Foo&gt; y = x</code>但是 y=x 涉及两个成员(指向Foo类型对象指针和指向控制块的指针)的复制，这两步拷贝不会同时（原子）发生。<br>存在一种情况，智能指针A和B，首先A是nullptr，B指向一个对象，线程1中A=B，线程2中B =nullptr。</p>
<ul>
<li><strong>weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？</strong></li>
</ul>
<p>答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。</p>
<h3 id="各种关键字"><a href="#各种关键字" class="headerlink" title="各种关键字"></a>各种关键字</h3><h4 id="static的作用？static变量什么时候初始化？"><a href="#static的作用？static变量什么时候初始化？" class="headerlink" title="static的作用？static变量什么时候初始化？"></a><strong>static的作用？static变量什么时候初始化？</strong></h4><p>（1）当用于文件作用域的时候（即在.h/.cpp文件中直接修饰变量和函数），static意味着这些变量和函数只在本文件可见，其他文件是看不到也无法使用的，可以避免重定义的问题。</p>
<p>（2）当用于函数作用域时，即作为局部静态变量时，意味着这个变量是全局的，只会进行一次初始化，不会在每次调用时进行重置，但只在这个函数内可见。</p>
<p>（3）当用于类的声明时，即静态数据成员和静态成员函数，static表示这些数据和函数是所有类对象共享的一种属性，而非每个类对象独有。</p>
<p>（4）static变量在类的声明中不占用内存，因此必须在.cpp文件中定义类静态变量以分配内存。<strong>全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化。</strong></p>
<h4 id="const关键字：修饰变量、指针、类对象、类中成员函数"><a href="#const关键字：修饰变量、指针、类对象、类中成员函数" class="headerlink" title="const关键字：修饰变量、指针、类对象、类中成员函数"></a><strong>const关键字：修饰变量、指针、类对象、类中成员函数</strong></h4><p>（1）const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；</p>
<p>（2）指针常量指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改，常量指针指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。这涉及到一个顶层const和底层const的概念：顶层const，本身是const，底层const，指向的对象是const；</p>
<p>（3）const修饰的函数可以重载。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数，非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。</p>
<h4 id="extern的作用"><a href="#extern的作用" class="headerlink" title="extern的作用?"></a><strong>extern的作用?</strong></h4><ol>
<li>当它与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的；</li>
<li>当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，应该去其它模块中寻找其定义。</li>
</ol>
<h4 id="explicit的作用？"><a href="#explicit的作用？" class="headerlink" title="explicit的作用？"></a><strong>explicit的作用？</strong></h4><ol>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">    B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">    B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">    <span class="built_in">doB</span>(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="keyword">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr的作用？"><a href="#constexpr的作用？" class="headerlink" title="constexpr的作用？"></a><strong>constexpr的作用？</strong></h4><p>答：这个关键字明确的告诉编译器应该去验证(函数或变量)在编译期是否就应该是一个常数（这样编译器就可以大胆进行优化）。</p>
<h4 id="volatile的作用？"><a href="#volatile的作用？" class="headerlink" title="volatile的作用？"></a><strong>volatile的作用？</strong></h4><ol>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以<strong>被某些编译器未知的因素（操作系统、硬件、其它线程等）更改</strong>。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，<strong>每次访问时都必须从内存中取出值</strong>（没有被 volatile 修饰的变量，<strong>可能由于编译器的优化，从 CPU 寄存器中取值</strong>）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ol>
<h4 id="mutable的作用？"><a href="#mutable的作用？" class="headerlink" title="mutable的作用？"></a><strong>mutable的作用？</strong></h4><p>答：可变的意思，使<strong>类中被声明为const的函数可以修改类中的非静态成员</strong>.(还可用于lambda表达式)</p>
<h4 id="auto和deltype的作用和区别？"><a href="#auto和deltype的作用和区别？" class="headerlink" title="auto和deltype的作用和区别？"></a><strong>auto和deltype的作用和区别？</strong></h4><p>用于实现类型自动推导，让编译器来操心变量的类型；auto不能用于函数传参和推导数组类型，但deltype可以解决这个问题。</p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数default"><a href="#构造函数default" class="headerlink" title="构造函数default"></a>构造函数<strong>default</strong></h4><p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<h4 id="构造函数delete"><a href="#构造函数delete" class="headerlink" title="构造函数delete"></a>构造函数<strong>delete</strong></h4><p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>（1）左值就是具有可寻址的存储单元，并且能由用户改变其值的量（<strong>能用取址符号 <code>&amp;</code> 取出地址的皆为左值，剩下的都是右值）</strong>，比如常见的变量：一个int，float，class等。左值具有持久的状态，直到离开作用域才销毁；右值表示即将销毁的临时对象，具有短暂的状态，比如字面值常量“hello”，返回非引用类型的表达式int func()等，都会生成右值；</p>
<p>（2）右值引用就是必须绑定到右值的引用，可以通过&amp;&amp;（两个取地址符）来获得右值引用；右值引用只能绑定到即将销毁的对象，因此可以自由地移动其资源；</p>
<p>（3）右值引用是为了支持移动操作而引出的一个概念，它只能绑定到一个将要销毁的对象，使用右值引用的移动操作可以避免无谓的拷贝，提高性能。使用std::move()函数可以将一个左值转换为右值引用。（从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);)。</p>
<ul>
<li>为什么要自己定义拷贝构造函数？什么是深拷贝和浅拷贝？</li>
</ul>
<p>（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成野指针（悬浮指针）；</p>
<p>（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<ul>
<li>什么是移动构造函数，和拷贝构造函数的区别？</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36725931/article/details/85218924">C++11 移动构造函数_项脊轩-CSDN博客_c++ 移动构造</a></p>
<p>答：移动构造函数需要传递的参数是一个右值引用，移动构造函数不分配新内存，而是接管传递而来对象的内存，并在移动之后把源对象销毁；移动拷贝构造函数需要传递一个左值引用，可能会造成重新分配内存，性能更低。</p>
<p>(1)完成必要的内存移动，斩断原对象和内存的关系（赋值为nullptr）。<br>(2)确保移动后源对象处于一种“即便被销毁也没有什么问题”的一种状态</p>
<h3 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h3><ul>
<li>nullptr替代 NULL</li>
<li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li>
<li>基于范围的 for 循环for(auto&amp; i : res){}</li>
<li>类和结构体的中初始化列表</li>
<li>Lambda 表达式（匿名函数）</li>
<li>std::forward_list（单向链表）</li>
<li>右值引用和move语义</li>
<li>智能指针</li>
</ul>
<h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><h4 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h4><ul>
<li><strong>内联函数有什么作用？存不存在什么缺点</strong>？</li>
</ul>
<p>（1）作用是使编译器在函数调用点上展开函数，可以避免函数调用的开销；</p>
<p>（2）内联函数的缺点是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会重新编译头文件，增加编译时间。</p>
<ul>
<li>内联函数和宏有什么区别，有了宏为什么还需要内联函数?</li>
</ul>
<p>（1）define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的开销；</p>
<p>（2）define的话是不会对参数的类型进行检查的，因此会出现类型安全的问题，比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错，但是内联函数在编译阶段会进行类型检查；</p>
<p>（3）使用宏的时候可能要添加很多括号，比较容易出错。</p>
<h4 id="sizeof与strlen对比"><a href="#sizeof与strlen对比" class="headerlink" title="sizeof与strlen对比"></a>sizeof与strlen对比</h4><p><strong>sizeof()</strong></p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<p><strong>strlen()</strong></p>
<p>strlen 是一个函数，它用来计算指定字符串 str 的长度，但不包括结束字符（即 null 字符）。</p>
<p><strong>区别</strong></p>
<ul>
<li>strlen和sizeof区别？<ul>
<li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li>
<li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li>
<li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li>
</ul>
</li>
</ul>
<h4 id="深拷贝与浅拷贝的区别"><a href="#深拷贝与浅拷贝的区别" class="headerlink" title="深拷贝与浅拷贝的区别"></a>深拷贝与浅拷贝的区别</h4><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
<li>深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：</li>
</ol>
<h4 id="指针与引用的区别"><a href="#指针与引用的区别" class="headerlink" title="指针与引用的区别"></a>指针与引用的区别</h4><ul>
<li>指针是一个变量<br>值为一个内存地址,不需要初始化，可以保存不同的地址<br>通过指针可以访问对应内存地址中的值<br>指针可以被const修饰成为常量或者只读变量</li>
<li>引用只是一个变量的新名字<br>对引用的操作(赋值,取地址等)都会传递到代表的变量.上<br>const引用使其代表的变量具有只读属性<br>引用必须在定义时初始化,之后无法代表其它变量</li>
<li>从使用C++语言的角度来看<br>引用与指针没有任何的关系<br>引用是变量的新名字,操作引用就是操作对应的变量</li>
<li>从C++编译器的角度来看<br>为了支持新概念“引用”必须要一个有效的解决方案<br>在编译器内部,使用指针常量来实现“引用”<br>因此“引用”在定义时必须初始化</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL各种容器底层实现"><a href="#STL各种容器底层实现" class="headerlink" title="STL各种容器底层实现"></a>STL各种容器底层实现</h3><p>（1）<strong>vector</strong>，底层是一块<strong>具有连续内存的数组</strong>，vector的核心在于其长度自动可变。<strong>vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾元素的finish和指向内存末端的end_of_storage。</strong>vector的扩容机制是：当目前可用的空间不足时，分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），容量的扩张必须经过“重新配置、元素移动、释放原空间”等过程。</p>
<p>（2）list，底层是一个<strong>循环双向链表</strong>，链表结点和链表分开独立定义的，结点包含pre、next指针和data数据。</p>
<p>（3）deque，双向队列，由分段连续空间构成，每段连续空间是一个缓冲区，<strong>由一个中控器来控制。它必须维护一个map指针（中控器指针）</strong>，还要<strong>维护start和finish两个迭代器，指向第一个缓冲区，和最后一个缓冲区。</strong>deque可以在前端或后端进行扩容，这些指针和迭代器用来控制分段缓冲区之间的跳转。</p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220404103043218.png" alt="image-20220404103043218"></p>
<p>（4）stack和queue，栈和队列。它们都是由deque作为底层容器实现的，他们是一种容器配接器，修改了deque的接口，具有自己独特的性质（此二者也可以用list作为底层实现）；stack是deque封住了头端的开口，先进后出，queue是deque封住了尾端的开口，先进先出。</p>
<p>（5）priority_queue，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树。</p>
<p>（6）set和<strong>map。</strong>底层都是由红黑树实现的。红黑树是一种二叉搜索树，但是它多了一个颜色的属性。红黑树的性质如下：1）每个结点非红即黑；2）根节点是黑的；3）如果一个结点是红色的，那么它的子节点就是黑色的；4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；因此，红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。</p>
<p>补充：平衡二叉树(AVL)和红黑树的区别：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance（旋转操作），导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h3 id="STL各种容器的查找、删除和插入的时间复杂度（性能比较）？"><a href="#STL各种容器的查找、删除和插入的时间复杂度（性能比较）？" class="headerlink" title="STL各种容器的查找、删除和插入的时间复杂度（性能比较）？"></a><strong>STL各种容器的查找、删除和插入的时间复杂度（性能比较）</strong>？</h3><p>【参考资料】：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zl1991/p/4691316.html">C++STL各种容器的性能比较</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39382769/article/details/102441699">【C++】STL各容器的实现，时间复杂度，适用情况分析_Y先森0.0-CSDN博客</a></p>
<p>（1）vector，vector支持随机访问(通过下标），时间复杂度是O(1)；如果是无序vector查找的时间复杂度是O(n)，如果是有序vector，采用二分查找则是O(log n)；对于插入操作，在尾部插入最快，中部次之，头部最慢，删除同理。vector占用的内存较大，由于二倍扩容机制可能会导致内存的浪费，内存不足时扩容的拷贝也会造成较大性能开销；</p>
<p>（2）list由于底层是链表，不支持随机访问，只能通过扫描的方式查找，复杂度为O(n)，但是插入和删除的速度快，只需要调整指针的指向。（有一种说法是链表每次插入和删除都需要分配和释放内存，会造成较大的性能开销，所以如果频繁地插入和删除，list性能并不好，但很多地方都说list插入删除性能好，这点我还没有验证，希望有人能指出）；list不会造成内存的浪费，占用内存较小；</p>
<p>（3）deque支持随机访问，但性能比vector要低；支持双端扩容，因此在头部和尾部插入和删除元素很快，为O(1)，但是在中间插入和删除元素很慢；</p>
<p>（4）set和map，底层基于红黑树实现，增删查改的时间复杂度近似O(log n)，红黑树又是基于链表实现，因此占用内存较小；</p>
<p>（5）unordered_set和unordered_map，底层是基于哈希表实现的，是无序的。理论上增删查改的时间复杂度是O(1)（最差时间复杂度O(n))，实际上数据的分布是否均匀会极大影响容器的性能。</p>
<h3 id="STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？"><a href="#STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？" class="headerlink" title="STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？"></a>STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？</h3><p>（1）为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放。当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。</p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/C++-189-2.png" alt="img"></p>
<p>（2）次级配置器的内存池管理技术：每次配置一大块内存，并维护对应的自由链表(free list)。若下次再有相同大小的内存配置，就直接从自由链表中拔出。如果客户端释还小额区块，就由配置器回收到自由链表中；配置器共要维护16个自由链表，存放在一个数组里，分别管理大小为8-128B不等的内存块。分配空间的时候，首先根据所需空间的大小（调整为8B的倍数）找到对应的自由链表中相应大小的链表，并从链表中拔出第一个可用的区块；回收的时候也是一样的步骤，先找到对应的自由链表，并插到第一个区块的位置。</p>
<p>（3）优势：避免内存碎片(这里应该指的是外部碎片)，不需要频繁从用户态切换到内核态，性能高效；劣势：仍然会造成一定的内存浪费，比如申请120B就必须分配128B（内部碎片）。</p>
<h3 id="STL容器的push-back和emplace-back的区别？"><a href="#STL容器的push-back和emplace-back的区别？" class="headerlink" title="STL容器的push_back和emplace_back的区别？"></a>STL容器的push_back和emplace_back的区别？</h3><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<h3 id="STL的排序用到了哪种算法，具体如何执行？"><a href="#STL的排序用到了哪种算法，具体如何执行？" class="headerlink" title="STL的排序用到了哪种算法，具体如何执行？"></a><strong>STL的排序用到了哪种算法，具体如何执行</strong>？</h3><p>【参考资料】：<a target="_blank" rel="noopener" href="https://feihu.me/blog/2014/sgi-std-sort/">https://feihu.me/blog/2014/sgi-std-sort/</a></p>
<p>答：快速排序、插入排序和堆排序；当数据量很大的时候用快排，划分区段比较小的时候用插入排序，当划分有导致最坏情况的倾向的时候使用堆排序。</p>
<h3 id="什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？"><a href="#什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？" class="headerlink" title="什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？"></a><strong>什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素</strong>？</h3><p>【参考资料】<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144296454">图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)</a></p>
<p>（1）哈希表是一种根据关键码值直接访问数据的数据结构，它通过把关键码值映射到表中的一个位置来访问元素，以加快查找的速度。这个映射函数叫做哈希函数；</p>
<p>（2）哈希表的长度使用质数，可以降低发生冲突的概率，使哈希后的数据更加均匀，如果使用合数，可能会导致很多数据集中分布到一个点上，造成冲突；</p>
<p>（3）解决冲突的办法有开放定址法和拉链法，开放定址法包括线性测探、平方测探法；</p>
<p>（4）线性测探法并不会真正的删除一个元素，而是做一个标记，否则可能会导致正常的查找出错（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/-beyond/p/7726347.html">利用线性探测法解决hash冲突 - 寻觅beyond - 博客园 (cnblogs.com)</a>）</p>
<p><strong>STL哈希表底层扩容</strong></p>
<p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</p>
<h3 id="STL-迭代器删除元素"><a href="#STL-迭代器删除元素" class="headerlink" title="STL 迭代器删除元素"></a>STL 迭代器删除元素</h3><p>这个主要考察的是迭代器失效的问题。</p>
<p>对于序列容器 vector， deque来说，使⽤ erase(itertor) 后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动⼀个位置，但是 erase 会返回下⼀个有效的迭代器；</p>
<p>对于关联容器 map set 来说，使⽤了 erase(iterator) 后，当前元素的迭代器失效，但是其结构是红⿊树，删除当前元素的，不会影响到下⼀个元素的迭代器，所以在调⽤ erase 之前，记录下⼀个元素的迭代器即可。</p>
<p>对于 list 来说，它使⽤了不连续分配的内存，并且它的 erase ⽅法也会返回下⼀个有效的iterator，因此上⾯两种正确的⽅法都可以使⽤。  </p>
<h3 id="map与unordered-map对比"><a href="#map与unordered-map对比" class="headerlink" title="map与unordered_map对比"></a>map与unordered_map对比</h3><ol>
<li><p>map实现机理</p>
<p>  map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</p>
</li>
<li><p>unordered_map实现机理</p>
<p>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。  </p>
</li>
</ol>
<h3 id="map的下标操作和insert区别"><a href="#map的下标操作和insert区别" class="headerlink" title="map的下标操作和insert区别"></a>map的下标操作和insert区别</h3><p>insert接受一个pair参数，并且返回值也是一个pair。返回值pair中的first元素是一个<br>迭代器，如果数据插入成功，则返回插入关键字位置，用-&gt;解引用可以提取pair类型元素。second成员是一个bool类型变量，如果关键字已在map中，insert什么也不做，second返回false,插入失败；如果关键字不存在，元素被插入，second返回true.即：insert 含义是：如果key存在，则插入失败，如果key不存在，就创建这个key－value。实例: map.insert((key, value))</p>
<p>利用下标操作的含义是：如果这个key存在，就更新value；如果key不存在，就创建这个key－value对 实例：map[key] = value  </p>
<h3 id="map-和-set-区别"><a href="#map-和-set-区别" class="headerlink" title="map 和 set 区别"></a>map 和 set 区别</h3><p>map 和 set 都是 C++ 的关联容器，其底层实现都是红⿊树（RB-Tree）。<br>由于 map 和 set 所开放的各种操作接⼝， RB-tree 也都提供了，所以⼏乎所有的 map 和 set的操作⾏为，都只是转调 RB-tree 的操作⾏为。<br>map 和 set 区别在于：</p>
<p>（1） map 中的元素是 key-value（关键字—值）对：关键字起到索引的作⽤，值则表示与索引相关联的数据； Set与之相对就是关键字的简单集合， set 中每个元素只包含⼀个关键字。</p>
<p>（2） set 的迭代器是 const 的，不允许修改元素的值； map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么⾸先需要删除该键，然后调节平衡，再插⼊修改后的键值，调节平衡，如此⼀来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；⽽map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3） map⽀持下标操作， set不⽀持下标操作。 map可以⽤key做下标， map的下标运算符[ ]将关键码作为下标去执⾏查找，如果关键码不存在，则插⼊⼀个具有该关键码和mapped_type类型默认值的元素⾄map中，因此下标运算符[ ]在map应⽤中需要慎⽤，onst_map不能⽤，只希望确定某⼀个关键值是否存在⽽不希望插⼊元素时也不应该使⽤，mapped_type类型没有默认值也不应该使⽤。如果find能解决需要，尽可能⽤find。  </p>
<h3 id="STL-⾥-resize-和-reserve-的区别"><a href="#STL-⾥-resize-和-reserve-的区别" class="headerlink" title="STL ⾥ resize 和 reserve 的区别"></a>STL ⾥ resize 和 reserve 的区别</h3><p>resize()：改变当前容器内含有元素的数量(size())， eg: vectorv; v.resize(len);v的size变为len,如果原来v的size⼩于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</p>
<p>reserve()：改变当前容器的最⼤容量（capacity） ,它不会⽣成元素，只是确定这个容器允许放⼊多少对象，如果reserve(len)的值⼤于当前的capacity()，那么会重新分配⼀块能存len个对象的空间，然后把之前v.size()个对象通过 copy construtor 复制过来，销毁之前的内存；</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p> 1、OSI7层网络模型：应用层、表示层、会话层、运输层、网络层、链路层、物理层<br> 2、TCP/IP四层网络模型：应用层、传输层、网际层、网络访问层<br> 综合OSI与TCP/IP模型，学习五层网络模型：<br> 从上向下架构：应用层、运输层、网络层、链路层、物理层<br> 链路层：<br> 3、MTU</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="说说-MAC地址和IP地址分别有什么作用"><a href="#说说-MAC地址和IP地址分别有什么作用" class="headerlink" title="说说 MAC地址和IP地址分别有什么作用"></a>说说 MAC地址和IP地址分别有什么作用</h3><p><strong>参考回答</strong></p>
<ol>
<li>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。而MAC地址，指的是物理地址，用来定义网络设备的位置。</li>
<li>IP地址的分配是<strong>根据网络的拓扑结构</strong>，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。</li>
<li>当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。</li>
<li>无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由<strong>ARP</strong>（Address Resolution Protocol：地址解析协议）负责<strong>将IP地址映射到MAC地址上来完成的</strong>。</li>
</ol>
<p> 网络层：</p>
<h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><p>ARP解决了<strong>同一个局域网</strong>上的主机和路由器IP和MAC地址的解析。</p>
<ul>
<li>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。 </li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。 </li>
<li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 </li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。 </li>
<li>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ul>
<h3 id="6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？"><a href="#6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？" class="headerlink" title="6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？"></a>6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？</h3><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p>
<h3 id="7、网络层转发数据报的流程"><a href="#7、网络层转发数据报的流程" class="headerlink" title="7、网络层转发数据报的流程"></a>7、网络层转发数据报的流程</h3><h3 id="8、子网划分、子网掩码"><a href="#8、子网划分、子网掩码" class="headerlink" title="8、子网划分、子网掩码"></a>8、子网划分、子网掩码</h3><h3 id="9、网络控制报文协议ICMP"><a href="#9、网络控制报文协议ICMP" class="headerlink" title="9、网络控制报文协议ICMP"></a>9、网络控制报文协议ICMP</h3><p>ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。主机或路由器用ICMP来发送<strong>差错报告报文和询问报文</strong>，其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p>
<h3 id="10、ICMP应用举例：PING、traceroute"><a href="#10、ICMP应用举例：PING、traceroute" class="headerlink" title="10、ICMP应用举例：PING、traceroute"></a>10、ICMP应用举例：PING、traceroute</h3><p><strong>Ping</strong><br>Ping（Packet Internet Groper），即因特网包探测器，是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 响应报文，Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通畅、运行是否正常等。</p>
<p><strong>TraceRoute</strong><br>TraceRoute 是 ICMP 的另一个应用，其主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL = 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL = 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<h3 id="路由器与交换机的区别"><a href="#路由器与交换机的区别" class="headerlink" title="路由器与交换机的区别"></a>路由器与交换机的区别</h3><ul>
<li>交换机：交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li>
<li>路由器：路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li>
</ul>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ul>
<li><h3 id="TCP三次握手及状态变化"><a href="#TCP三次握手及状态变化" class="headerlink" title="TCP三次握手及状态变化"></a><strong>TCP三次握手及状态变化</strong></h3></li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220304101418589.png" alt="image-20220304101418589"></p>
<p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p>
<p>标志位为 SYN，表示请求建立连接；<br>序号为 Seq = x（x 一般取随机数）；<br>随后客户端进入 SYN-SENT 阶段。<br>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p>
<p>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；<br>序号为 Seq = y；<br>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。</p>
<p>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p>
<p><strong>标志位为 ACK，表示确认收到服务器端同意连接的信号</strong>；<br>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；<br>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。<br>随后客户端进入 ESTABLISHED。<br>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<ul>
<li><strong>两次握手可以吗？</strong></li>
</ul>
<p>考虑两种情况：<br>1.客户端第一个报文滞留了<br>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p>
<p>2.两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p>
<ul>
<li><strong>第 2 次握手传回了 ACK，为什么还要传回 SYN</strong></li>
</ul>
<p>从全双工的角度看，第一次握手的SYN是客户端向服务端的连接请求，第二次握手的SYN是服务端向客户端的连接请求，两边都是需要的，ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（Seq）同步给客户端。</p>
<ul>
<li><strong>三次握手异常情况</strong></li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220405115339668.png" alt="image-20220405115339668"></p>
<ul>
<li><h3 id="TCP四次挥手及状态变化"><a href="#TCP四次挥手及状态变化" class="headerlink" title="TCP四次挥手及状态变化"></a>TCP四次挥手及状态变化</h3></li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220303193846259.png" alt="image-20220303193846259"></p>
<ol>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li>
</ol>
<ul>
<li><h5 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5></li>
</ul>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p>
<ul>
<li><strong>客户端TIME_WAIT状态的意义是什么？</strong></li>
</ul>
<p>1.第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p>
<p>2.MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<ul>
<li><strong>TIME_WAIT 状态会导致什么问题，怎么解决？</strong></li>
</ul>
<p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p>
<p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p>
<ul>
<li><h3 id="TCP与UDP的区别及应用场景（建立连接、一对一、字节流、流量控制、拥塞控制、首部字节、所需资源）"><a href="#TCP与UDP的区别及应用场景（建立连接、一对一、字节流、流量控制、拥塞控制、首部字节、所需资源）" class="headerlink" title="TCP与UDP的区别及应用场景（建立连接、一对一、字节流、流量控制、拥塞控制、首部字节、所需资源）"></a>TCP与UDP的区别及应用场景（建立连接、一对一、字节流、流量控制、拥塞控制、首部字节、所需资源）</h3></li>
</ul>
<ol>
<li>TCP是面向连接的，UDP是无连接的；<br>什么叫无连接？ UDP发送数据之前不需要建立连接 </li>
<li>TCP是可靠的，UDP不可靠；<br>什么叫不可靠？ UDP接收方收到报文后，不需要给出任何确认 </li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多； </li>
<li>TCP是面向字节流的，UDP是面向报文的；<br>什么意思？ 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。 </li>
<li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏； </li>
<li>TCP首部开销（20字节）比UDP首部开销（8字节）要大 </li>
<li>UDP 的主机不需要维持复杂的连接状态表</li>
</ol>
<ul>
<li><h3 id="UDP、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）"><a href="#UDP、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）" class="headerlink" title="UDP、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）"></a>UDP、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）</h3></li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/v2-c01a6511abf81f867fd0e531bd51af2c_r.jpg" alt="img"></p>
<p>UDP 首部字段<strong>只有 8 个字节</strong>，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/v2-3bd45a13afe868cae6225d75b85e9c36_r.jpg" alt="img"></p>
<p>TCP 首部格式比 UDP 复杂。</p>
<p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
<p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p>
<p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p>
<p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p>
<p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p>
<p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p>
<p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p>
<p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p>
<p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p>
<p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p>
<p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p>
<p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<ul>
<li><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3></li>
</ul>
<p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>
<p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>
<ul>
<li><h5 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h5></li>
</ul>
<p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送</p>
<p><strong>拥塞控制和流量控制的区别</strong><br>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。</p>
<ul>
<li><h3 id="TCP拥塞控制（慢开始、拥塞避免、快重传、快恢复。）"><a href="#TCP拥塞控制（慢开始、拥塞避免、快重传、快恢复。）" class="headerlink" title="TCP拥塞控制（慢开始、拥塞避免、快重传、快恢复。）"></a>TCP拥塞控制（<strong>慢开始、拥塞避免、快重传、快恢复。</strong>）</h3></li>
</ul>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/v2-62529f3bda992dc7035dcb13ef0da8b7_r.jpg" alt="img"></p>
<p>TCP 主要通过四个算法来进行拥塞控制：</p>
<p><strong>慢开始、拥塞避免、快重传、快恢复。</strong></p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220315133525026.png" alt="image-20220315133525026"></p>
<ol>
<li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li>
<li>拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.</li>
<li>快重传：快重传要求接收方<strong>在收到一个失序的报文段</strong>后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，<strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</strong></li>
<li>快恢复：当发送方连续收到三个重复确认时，就<strong>把慢开始门限减半，然后执行拥塞避免算法</strong>。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</li>
</ol>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/v2-1cc37f757263f3cd58e917059cedc7b5_r.jpg" alt="img"></p>
<h3 id="TCP如何保证可靠性的？"><a href="#TCP如何保证可靠性的？" class="headerlink" title="TCP如何保证可靠性的？"></a>TCP如何保证可靠性的？</h3><ul>
<li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>
<li><strong>校验和</strong>： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li><strong>流量控制</strong>： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li>
<li><strong>拥塞控制</strong>： 当网络某个节点发生拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong>： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li>
</ul>
<h3 id="UDP为什么是不可靠的？"><a href="#UDP为什么是不可靠的？" class="headerlink" title="UDP为什么是不可靠的？"></a>UDP为什么是不可靠的？</h3><p>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的。</p>
<p>和 TCP 建立连接时采用三次握手不同，UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。</p>
<p>当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p>
<h3 id="TCP-最大连接数限制"><a href="#TCP-最大连接数限制" class="headerlink" title="TCP 最大连接数限制"></a>TCP 最大连接数限制</h3><p><strong>Client 最大 TCP 连接数</strong><br>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</p>
<p><strong>Server最大 TCP 连接数</strong><br>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</p>
<p>然而上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的。</p>
<h3 id="SYN泛洪攻击。如何解决？"><a href="#SYN泛洪攻击。如何解决？" class="headerlink" title="SYN泛洪攻击。如何解决？"></a>SYN泛洪攻击。如何解决？</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<p>在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</p>
</li>
<li><p>部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</p>
</li>
</ul>
<p>上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。</p>
<p><strong>SYN Cache：</strong>该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。</p>
<p>SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</p>
<p>然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
<p>SYN Proxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。</p>
<h3 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h3><p>为什么会发生TCP粘包和拆包?</p>
<p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p>常见解决方法</p>
<p>① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p>
<p>③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<p>什么时候需要处理粘包问题？</p>
<p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</p>
<h3 id="22、TCP心跳包"><a href="#22、TCP心跳包" class="headerlink" title="22、TCP心跳包"></a>22、TCP心跳包</h3><h3 id="24、UDP如何实现可靠传输"><a href="#24、UDP如何实现可靠传输" class="headerlink" title="24、UDP如何实现可靠传输"></a>24、UDP如何实现可靠传输</h3><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><h3 id="DNS域名系统。采用TCP还是UDP协议？为什么？"><a href="#DNS域名系统。采用TCP还是UDP协议？为什么？" class="headerlink" title="DNS域名系统。采用TCP还是UDP协议？为什么？"></a>DNS域名系统。采用TCP还是UDP协议？为什么？</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1818152">DNS 为什么同时使用 TCP 和 UDP</a></p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="26、FTP协议（了解）"><a href="#26、FTP协议（了解）" class="headerlink" title="26、FTP协议（了解）"></a>26、FTP协议（了解）</h3><h3 id="27、HTTP请求报文与响应报文首部结构"><a href="#27、HTTP请求报文与响应报文首部结构" class="headerlink" title="27、HTTP请求报文与响应报文首部结构"></a>27、HTTP请求报文与响应报文首部结构</h3><h3 id="简述-HTTP-1-0，1-1，2-0-的主要区别"><a href="#简述-HTTP-1-0，1-1，2-0-的主要区别" class="headerlink" title="简述 HTTP 1.0，1.1，2.0 的主要区别"></a>简述 HTTP 1.0，1.1，2.0 的主要区别</h3><p><strong>参考回答</strong></p>
<p><strong>1、长连接</strong>：HTTP1.0不支持长连接，每进行一次通信就要断开TCP连接；HTTP1.1支持长连接，一个TCP连接中可以传送多个HTTP请求和响应，减少了TCP连接重复建立和断开所造成的额外开销，减轻了服务端的负载。<br><strong>2、管线化</strong>：HTTP1.0工作方式为非流水线方式，发送请求后需等待并收到响应，才能发送下一个请求；HTTP1.1支持流水线工作方式，可以同时并行发送多个请求，不需要一个接一个地等待响应。</p>
<p>HTTP2.0相比HTTP1.1支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的”队头堵塞”问题。</li>
<li><strong>头部压缩</strong>，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，<strong>使用特定<a href="">算法</a>压缩头帧</strong>，有效减少头信息大小。并且HTTP2.0<strong>在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。</strong>比如请求a发送了所有的头信息字段，请求b则<strong>只需要发送差异数据</strong>，这样可以减少冗余数据，降低开销。</li>
<li><strong>服务端推送</strong>：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li>
</ul>
<h3 id="HTTP与HTTPS对比（4点）"><a href="#HTTP与HTTPS对比（4点）" class="headerlink" title="HTTP与HTTPS对比（4点）"></a>HTTP与HTTPS对比（4点）</h3><ol>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</li>
</ol>
<h3 id="HTTPS加密流程"><a href="#HTTPS加密流程" class="headerlink" title="HTTPS加密流程"></a>HTTPS加密流程</h3><p>总结https的加密流程为：<br>（1）服务器将自己的公开密钥提交给数字认证机构；<br>（2）数字认证机构用其私有密钥给公开密钥署数字签名并颁发公钥证书，然后发送给服务器；<br>（3）服务器将公钥证书（包括公开密钥+数字签名）发送给客户端；（数字签名相当于CA机构的私有密钥）<br>（4）客户端使用数字认证机构的公开密钥验证数字签名，从而验证服务器公开密钥的真实性；（客户端操作系统中已事先置入了CA数字认证机构的公开密钥）<br>（5）客户端随机生成共享密钥，使用公开密钥加密传送共享密钥给服务器；<br>（6）服务端使用私有密钥解密获取客户端的共享密钥；<br>（7）客户端和服务端使用共享密钥进行通信。</p>
<ol>
<li><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
</li>
</ol>
<p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p>
<h3 id="HTTP请求方法和状态码"><a href="#HTTP请求方法和状态码" class="headerlink" title="HTTP请求方法和状态码"></a>HTTP请求方法和状态码</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>请求方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>OPTIONS</td>
<td>请求一些选项信息，允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody></table>
<p>状态码（Status-Code）</p>
<ul>
<li>1xx：表示通知信息，如请求收到了或正在进行处理<ul>
<li>100 Continue：继续，客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li>2xx：表示成功，如接收或知道了<ul>
<li>200 OK: 请求成功</li>
</ul>
</li>
<li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul>
<li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li>
</ul>
</li>
<li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized: 请求要求用户的身份认证</li>
<li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li>
<li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li>
<li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul>
<li>500 Internal Server Error: 服务器内部错误，无法完成请求</li>
<li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li>
<li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
</ul>
</li>
</ul>
<h3 id="说说-GET请求和-POST-请求的区别【位置、明文密文、安全、长度、场景】"><a href="#说说-GET请求和-POST-请求的区别【位置、明文密文、安全、长度、场景】" class="headerlink" title="说说 GET请求和 POST 请求的区别【位置、明文密文、安全、长度、场景】"></a>说说 GET请求和 POST 请求的区别【位置、明文密文、安全、长度、场景】</h3><ol>
<li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li>
<li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li>
<li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li>
<li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li>
</ol>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。</p>
<p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p>
<h3 id="什么是cookie和session？"><a href="#什么是cookie和session？" class="headerlink" title="什么是cookie和session？"></a>什么是cookie和session？</h3><p>由于HTTP协议是无状态的协议，需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。</p>
<p><strong>cookie</strong>就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一些：<strong>当用户使用浏览器访问一个支持cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体中的，而是存放于HTTP响应头；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置</strong>。 自此，客户端再向服务器发送请求的时候，都会把相应的cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。网站的登录界面中“请记住我”这样的选项，就是通过cookie实现的。<br><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/cookie.png" alt="img"></p>
<p><strong>cookie工作流程</strong>：</p>
<p>（1）客户端第一次发送请求给服务器端；<br>（2）服务端创建Cookie（包含用户的信息，对应一个识别码）并将其发送给客户端，客户端会保存cookie文件；<br>（3）客户端再次访问服务端时，会自动在请求报文中加入Cookie值发送给服务端；<br>（4）服务端接受到报文后，通过Cookie值就能确认用户身份。</p>
<p><strong>session原理</strong>：首先浏览器请求服务器访问web站点时，服务器首先会<strong>检查</strong>这个客户端请求是否已经包含了一个session标识、称为<strong>SESSIONID</strong>，如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的<strong>sessionid存放到cookie</strong>中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。</p>
<p>（1）客户端第一次访问服务端；<br>（2）服务端创建一个sessionId和session形成一个映射关系，session保存在后端数据库，然后将sessionId发送给客户端并保存；<br>（3）客户端再次访问服务端时，会自动在请求报文的首部行中加入sessionId；<br>（4）服务端根据sessionId去查询Session对象，从而区分不同用户。</p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/session.png" alt="img"></p>
<h3 id="Cookie和Session的区别？（4点）"><a href="#Cookie和Session的区别？（4点）" class="headerlink" title="Cookie和Session的区别？（4点）"></a>Cookie和Session的区别？（4点）</h3><ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端，Session 保存在服务器端。 </li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。 </li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。 </li>
<li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<h3 id="输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）"><a href="#输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）" class="headerlink" title="输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）"></a>输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）</h3><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程与线程区别（资源调度，关系，拥有资源，内存，通信，健壮"><a href="#进程与线程区别（资源调度，关系，拥有资源，内存，通信，健壮" class="headerlink" title="进程与线程区别（资源调度，关系，拥有资源，内存，通信，健壮"></a>进程与线程区别（资源调度，关系，拥有资源，内存，通信，健壮</h4><ul>
<li><p><strong>参考回答</strong></p>
<ol>
<li><strong>进程</strong>：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。</li>
<li><strong>线程</strong>：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。</li>
<li><strong>协程</strong>：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>线程与进程的区别</strong>：</li>
</ol>
</li>
<li><p>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</p>
</li>
<li><p>线程依赖于进程而存在，一个进程至少有一个线程；</p>
<ul>
<li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>
</ul>
</li>
<li><p>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</p>
<ul>
<li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>
</ul>
</li>
<li><p>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</p>
<ul>
<li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<ol start="2">
<li><p><strong>线程与协程的区别：</strong></p>
<p>（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。</p>
<p>（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。</p>
<p>（3）一个线程可以有多个协程。</p>
</li>
<li><p>进程之间私有和共享的资源</p>
<ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
</ul>
</li>
</ol>
<ul>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
</li>
</ul>
<ol start="4">
<li>线程之间私有和共享的资源<ul>
<li><p>私有：线程栈，寄存器，程序计数器</p>
</li>
<li><p>共享：堆，地址空间，全局变量，静态变量</p>
</li>
</ul>
</li>
</ol>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220411192821098.png" alt="image-20220411192821098"></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h4 id="进程切换流程"><a href="#进程切换流程" class="headerlink" title="进程切换流程"></a><strong>进程切换流程</strong></h4><p>如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。</p>
<p>由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。</p>
<p>这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。</p>
<h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<p><strong>1. 批处理系统</strong></p>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<p><strong>2. 交互式系统</strong></p>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220411192939650.png" alt="image-20220411192939650"></p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p>[<img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220411193003902.png" alt="image-20220411193003902"></p>
<p><strong>3. 实时系统</strong></p>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h4 id="线程同步的方式：锁、信号量、信号、屏障"><a href="#线程同步的方式：锁、信号量、信号、屏障" class="headerlink" title="线程同步的方式：锁、信号量、信号、屏障"></a>线程同步的方式：锁、信号量、信号、屏障</h4><ul>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p><strong>1. 临界区</strong></p>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry section</span></span><br><span class="line"><span class="comment">// critical section;</span></span><br><span class="line"><span class="comment">// exit section</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 同步与互斥</strong></p>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<p><strong>3. 信号量</strong></p>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font size=3> <strong>使用信号量实现生产者-消费者问题</strong> </font> </br></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">produce_item</span>();</span><br><span class="line">        <span class="built_in">down</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">insert_item</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">down</span>(&amp;full);</span><br><span class="line">        <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">remove_item</span>();</span><br><span class="line">        <span class="built_in">consume_item</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 管程</strong></p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">()</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生产者-消费者问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then <span class="built_in">wait</span>(full);</span><br><span class="line">        <span class="built_in">insert_item</span>(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then <span class="built_in">signal</span>(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then <span class="built_in">wait</span>(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then <span class="built_in">signal</span>(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.<span class="built_in">insert</span>(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        <span class="built_in">consume_item</span>(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="进程间通信：PIPE、FIFO、消息队列、信号量、信号、共享内存、socket"><a href="#进程间通信：PIPE、FIFO、消息队列、信号量、信号、共享内存、socket" class="headerlink" title="进程间通信：PIPE、FIFO、消息队列、信号量、信号、共享内存、socket"></a>进程间通信：PIPE、FIFO、消息队列、信号量、信号、共享内存、socket</h4><ul>
<li>管道（PIPE）<ul>
<li>有名管道(FIFO)：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul>
<li>优点：简单方便</li>
<li>缺点：<ol>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
</li>
<li>套接字（Socket）：可用于不同计算机间的进程通信<ul>
<li>优点：<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据</li>
</ul>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><h4 id="互斥锁与自旋锁的底层区别"><a href="#互斥锁与自旋锁的底层区别" class="headerlink" title="互斥锁与自旋锁的底层区别"></a>互斥锁与自旋锁的底层区别</h4></li>
</ul>
<p><strong>自旋锁：适用于锁持有时间短的情况</strong></p>
<p>互斥锁是通过休眠使线程阻塞，此时cpu会进行线程调度，将阻塞的线程挂起并读入下一个要运行线程的内存内容，等到解锁后，被挂起的线程变为可运行状态，等待cpu调用。当互斥锁持有的时间很短时，线程调度上下文切换的时间远远大于阻塞的时间，此时进行线程调度不是最优方法。自旋锁与互斥锁类似，但其在获取锁之前一直处于忙等（未让出cpu）阻塞状态。因此，自旋锁通常用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。</p>
<p><strong>读写锁：适用于读操作远大于写的情况</strong></p>
<p>互斥锁只有两种状态：加锁状态和不加锁状态。读写锁有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式下的读写锁。</p>
<p>写模式下加锁：独占式锁，在该锁被解锁之前，所有试图对该锁进行加锁的线程都会被阻塞；<br>读模式下加锁：共享式锁，所有线程都可以以读模式来访问该锁，但是写模式下的线程都会在获取锁之前阻塞，直到所有读模式下的线程释放读锁；</p>
<h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><ol>
<li><p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。</p>
</li>
<li><p><strong>如何解决僵尸进程</strong>：</p>
<p>（1）一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。</p>
<p>（2）<strong>使用kill命令</strong>。</p>
<p>​    打开终端并输入下面命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep Z </span><br></pre></td></tr></table></figure>

<p>​    会列出进程表中所有僵尸进程的详细内容。</p>
<p>​    然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGCHLD pid(父进程pid)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="死锁及避免"><a href="#死锁及避免" class="headerlink" title="死锁及避免"></a>死锁及避免</h3><p><strong>原因</strong></p>
<ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<p><strong>产生条件</strong></p>
<ul>
<li><strong>互斥</strong>条件</li>
<li><strong>占有且等待</strong>条件：线程占有已经分配给它们的资源（如锁）并且等待其他的资源（也就是说不会<em>主动</em>释放）</li>
<li><strong>不可抢占</strong>条件（也就是说不会<em>被动</em>释放）</li>
<li><strong>环路等待</strong>条件：每个进程都在等待下一个进程占有的资源</li>
</ul>
<p><strong>预防</strong></p>
<ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h3><p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<p><strong>优劣</strong></p>
<table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody></table>
<p><strong>选择</strong></p>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h3 id="请你说说什么是守护进程，如何实现？"><a href="#请你说说什么是守护进程，如何实现？" class="headerlink" title="请你说说什么是守护进程，如何实现？"></a>请你说说什么是守护进程，如何实现？</h3><p><strong>参考回答</strong></p>
<ol>
<li><p><strong>守护进程</strong>：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。</p>
</li>
<li><p><strong>如何实现</strong>：</p>
<p>（1）创建子进程，终止父进程。方法是调用fork() 产生一个子进程，然后使父进程退出。</p>
<p>（2）调用setsid() 创建一个新会话。</p>
<p>（3）将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。</p>
<p>（4）重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限中的对应位。</p>
<p>（5）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。</p>
</li>
</ol>
<h3 id="8、管道与消息队列对比"><a href="#8、管道与消息队列对比" class="headerlink" title="8、管道与消息队列对比"></a>8、管道与消息队列对比</h3><h3 id="9、fork进程的底层：读时共享，写时复制"><a href="#9、fork进程的底层：读时共享，写时复制" class="headerlink" title="9、fork进程的底层：读时共享，写时复制"></a>9、fork进程的底层：读时共享，写时复制</h3><h3 id="进程、线程的中断切换的过程是怎样的？"><a href="#进程、线程的中断切换的过程是怎样的？" class="headerlink" title="进程、线程的中断切换的过程是怎样的？"></a>进程、线程的中断切换的过程是怎样的？</h3><p><strong>进程上线文切换</strong></p>
<p>​    和CPU上下文切换相比，进程上下文切换在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的<strong>虚拟内存、栈等保存下来</strong>。而加载了下一进程的内核态后，还需要<strong>刷新进程的虚拟内存和用户栈</strong>。下面是发生进程上线文切换的几个场景：</p>
<p>​    a）为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</p>
<p>​    b）进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p>
<p>​    c）当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</p>
<p>​    d）当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</p>
<p>​    e）发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</p>
<p><strong>线程上下文切换</strong></p>
<p>​    线程与进程最大的区别在于，线程是<strong>调度的基本单位</strong>，而进程则是<strong>资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：</p>
<p>​    a）当进程只有一个线程时，可以认为进程就等于线程。</p>
<p>​    b）当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是<strong>不需要修改</strong>的。</p>
<p>​    c）另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是<strong>需要保存</strong>的。</p>
<p>​    这么一来，线程的上下文切换其实就可以分为两种情况：</p>
<p>​    a）前后两个线程属于<strong>不同进程</strong>。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</p>
<p>​    b）前后两个线程属于<strong>同一个进程</strong>。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p>
<h3 id="阻塞IO与非阻塞IO"><a href="#阻塞IO与非阻塞IO" class="headerlink" title="阻塞IO与非阻塞IO"></a>阻塞IO与非阻塞IO</h3><ul>
<li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
<li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
<li>IO多路复用</li>
<li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。（定时器）</li>
</ul>
<h3 id="同步与异步的概念"><a href="#同步与异步的概念" class="headerlink" title="同步与异步的概念"></a>同步与异步的概念</h3><p>同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用</p>
<p>阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被<strong>挂起</strong>。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源。</p>
<p>同步和异步强调的是消息通信机制 (synchronous communication/ asynchronous communication)。所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，”调用”在发出之后，这个<strong>调用就直接返回了</strong>，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用</p>
<h3 id="静态链接与动态链接的过程"><a href="#静态链接与动态链接的过程" class="headerlink" title="静态链接与动态链接的过程"></a>静态链接与动态链接的过程</h3><p><a href="https://yunf194.github.io/2022/02/20/2022220-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/">编译链接</a></p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>由链接器在链接时将库的内容直接加入到可执行程序中。a.out包含file1.o,file2.o,libc.a三个文件，运行的时候与原始的file1.o,file2.o,libc.a三个文件没有任何关系，不需要它们就可以直接运行。</p>
<p>[<img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220220191456232.png" alt="image-20220220191456232"></p>
<p><strong>Linux下静态库的创建和使用</strong></p>
<ul>
<li>编译静态库源码: gcc -c lib.c -o libo</li>
<li>生成静态库文件: ar -q lib.a lib.o</li>
<li>使用静态库编译: gcc main.c lib.a -o main.out</li>
</ul>
<p><a href="https://yunf194.github.io/images/2022220-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/image-20220220191509821.png"><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220220191509821.png" alt="image-20220220191509821"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">fengyun@ubuntu:~/share$ gcc -c slib.c -o slib.o</span><br><span class="line">fengyun@ubuntu:~/share$ ar -q slib.a slib.o</span><br><span class="line">ar: 正在创建 slib.a</span><br><span class="line">fengyun@ubuntu:~/share$ gcc test1.c slib.a -o test1.out</span><br><span class="line">fengyun@ubuntu:~/share$ ./test1.out</span><br><span class="line">Name: Static Lib</span><br><span class="line">Result: 5</span><br><span class="line">fengyun@ubuntu:~/share$ </span><br></pre></td></tr></table></figure>

<p>Linux ar命令用于建立或修改备存文件，或是从备存文件中抽取文件。</p>
<p>ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><ul>
<li>可执行程序<strong>在运行时</strong>才动态加载库进行链接</li>
<li>库的内容不会进入可执行程序当中</li>
</ul>
<p><a href="https://yunf194.github.io/images/2022220-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/image-20220220191521275.png"><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20220220191521275.png" alt="image-20220220191521275"></a></p>
<p>lib1.so和lib2.so动态库生成的stub1和stub2，是最终生成的可执行程序可以使用的内容，程序看不到其它内容。</p>
<p><strong>1 静态链接库的优点</strong> </p>
<p> (1) 代码装载速度快，执行速度略比动态链接库快； </p>
<p> (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 </p>
<p><strong>2 动态链接库的优点</strong> </p>
<p> (1) 更加节省内存并减少页面交换；</p>
<p> (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p> (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p> (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<p><strong>3 不足之处</strong></p>
<p> (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；</p>
<p> (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。</p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><strong>什么是用户态和内核态</strong>？</p>
<p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<p><strong>如何从用户态切换到内核态?</strong></p>
<ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</li>
</ul>
<h3 id="虚拟内存概念（非常重要）"><a href="#虚拟内存概念（非常重要）" class="headerlink" title="虚拟内存概念（非常重要）"></a>虚拟内存概念（非常重要）</h3><p>最开始的时候，程序运行就是直接放进内存的，但是内存空间有限，程序放的时候成块放，有时候会造成内存空间的浪费或者造成大量的内存碎片，于是决定在磁盘上找一个空间，用来扩大内存，磁盘这段空间就成为虚拟内存。光扩大内存还不行，必须要减少内存碎片，所以，将物理内存进行了分页，每一页大小相等，同时将虚拟内存也进行了分页。平时不需要的就放在磁盘中，需要运行的磁盘通过虚拟内存放到实际的主存中，这样就不害怕主存太满放不下了。虚拟内存存放在磁盘里，它里面包括不存在的，未映射的和已经映射的内存地址。但是如果分页太多的话，每次调用进程就会特别占空间，所以又在内存中划分出一块空间，作为一级页表，后续需要哪一个页，再调用对应的页表进行查询转换。页表中存放的是虚拟地址和物理地址的映射关系。mmu负责根据页表将虚拟地址转换为实际地址。TLB里面是高速缓存，每次映射前可以先从TLB中查找是否有想用的缓存，可以大大提高转换效率。页表中的有效位会判断是否物理地址是否为空。缺页时会从主存里面选择一个牺牲页，并把该牺牲页的内容拷回到磁盘里，然后用需要的地址取代它。</p>
<h3 id="17、MMU地址翻译的具体流程"><a href="#17、MMU地址翻译的具体流程" class="headerlink" title="17、MMU地址翻译的具体流程"></a>17、MMU地址翻译的具体流程</h3><h3 id="18、缺页处理过程"><a href="#18、缺页处理过程" class="headerlink" title="18、缺页处理过程"></a>18、缺页处理过程</h3><h3 id="缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法"><a href="#缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法" class="headerlink" title="缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法"></a>缺页置换<a href="">算法</a>：最久未使用<a href="">算法</a>、先进先出<a href="">算法</a>、最佳置换<a href="">算法</a></h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li>
<li><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li>
<li><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li>
<li><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li>
<li><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li>
<li><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li>
<li><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面</li>
</ul>
<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">局部性原理</summary><slot id="details-content"><ul dir="auto" style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">时间上：最近被访问的页在不久的将来还会被访问；</li><li style="box-sizing: border-box; margin-top: 0.25em;">空间上：内存中被访问的页周围的页也很可能被访问。</li></ul></slot></details>

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">什么是颠簸现象</summary><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p><ul dir="auto" style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">修改页面置换算法；</li><li style="box-sizing: border-box; margin-top: 0.25em;">降低同时运行的程序的数量；</li><li style="box-sizing: border-box; margin-top: 0.25em;">终止该进程或增加物理内存容量。</li></ul></details>



<h3 id="1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）"><a href="#1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）" class="headerlink" title="1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）"></a>1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）</h3><p> I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p>
<blockquote>
<p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p>
</blockquote>
<p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：<strong>如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回</strong>。I/O 多路复用内部使用<em>非阻塞 I/O</em> 检查每个描述符的就绪状态。</p>
<h3 id="2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）"><a href="#2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）" class="headerlink" title="2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）"></a>2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）</h3><h3 id="3、线程池"><a href="#3、线程池" class="headerlink" title="3、线程池"></a>3、线程池</h3><h3 id="4、基于事件驱动的reactor模式"><a href="#4、基于事件驱动的reactor模式" class="headerlink" title="4、基于事件驱动的reactor模式"></a>4、基于事件驱动的reactor模式</h3><h3 id="5、边沿触发与水平触发的区别"><a href="#5、边沿触发与水平触发的区别" class="headerlink" title="5、边沿触发与水平触发的区别"></a>5、边沿触发与水平触发的区别</h3><h3 id="6、非阻塞IO与阻塞IO区别"><a href="#6、非阻塞IO与阻塞IO区别" class="headerlink" title="6、非阻塞IO与阻塞IO区别"></a>6、非阻塞IO与阻塞IO区别</h3><p> 参考书籍：《Unix网络编程》<br> ps:网络编程掌握以上几点就够了，要搞明白还是要花很久时间的。</p>
<p> 五、数据结构与<a href="">算法</a>及<a href="">刷题</a>（2个月）<br> 1、数组<br> 2、<a href="">链表</a><br> 3、栈<br> 4、队列<br> 5、堆<br> 6、<a href="">二叉树</a>：二叉搜索树、平衡树、<a href="">红黑树</a><br> 7、B树、B+树<br> 8、<a href="">哈希表</a>及哈希冲突<br> 9、<a href="">排序</a><a href="">算法</a>：冒泡<a href="">排序</a>、简单选择<a href="">排序</a>、插入<a href="">排序</a>、希尔<a href="">排序</a>、归并<a href="">排序</a>、堆<a href="">排序</a>、快速<a href="">排序</a><br> （要求能够面试时手写出堆<a href="">排序</a>和快速<a href="">排序</a>）<br> 10、二分法：<a href="">旋转数组</a>找target<br> 11、回溯法：全排列、复原IP地址<br> 12、<a href="">动态规划</a>（掌握基本的<a href="">动态规划</a>的几个题其实就够了，如：<a href="">斐波那契数列</a>、接雨水、股票的最佳买入时机）</p>
<h2 id="mySQL数据库"><a href="#mySQL数据库" class="headerlink" title="mySQL数据库"></a>mySQL数据库</h2><h3 id="数据存储引擎"><a href="#数据存储引擎" class="headerlink" title="数据存储引擎"></a>数据存储引擎</h3><p>存储引擎是MYSQL的核心技术，不同的存储引擎使用不同的存储机制、索引技巧、锁定水平并最终提供不同的功能和能力。常见的引擎分为三种：InnoDB存储引擎（MYSQL默认的事务性引擎）、MyISAM存储引擎、Memory存储引擎。<br>三种存储引擎的功能对比如下表所示：<br><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br>总结三种引擎的使用选择如下：</p>
<ol>
<li><strong>MyISAM</strong> ：由于MyISAM不支持事务、不支持外键、支持全文检索和表级锁定，读写相互阻塞，读取速度快，节约资源，所以如果应用是以<strong>查询操作</strong>和<strong>插入操作</strong>为主，只有很少的<strong>更新和删除</strong>操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li><strong>InnoDB</strong> : 是MySQL的默认存储引擎， 由于InnoDB支持事务、支持外键、行级锁定 ，支持所有辅助索引(5.5.5后不支持全文检索)，高缓存，所以用于<strong>对事务的完整性有比较高的要求</strong>，在<strong>并发</strong>条件下要求<strong>数据的一致性</strong>，<strong>读写频繁</strong>的操作，那么InnoDB存储引擎是比较合适的选择，比如BBS、计费系统、充值转账等</li>
<li><strong>MEMORY</strong>：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供更快的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li>
</ol>
<h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>1、第一范式：数据库表的每一列都是不可分割的基本数据项，即同一列不能有多个值；<br>2、第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。<br>如：设计订单信息表时，商品名称、商品价格等商品信息与表的主键不相关，而只与商品编号相关，因此可将表设计为订单信息表和商品信息表。<br>3、第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。<br>如果一张表中出现另一张表的非主键，可以将这两张表用外键关联，而不是将另一张表的非主键直接写在当前表中。<br>设计数据库表的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3></li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>索引可以帮助服务器避免排序和创建临时表<br>索引可以将随机IO变成顺序IO<br>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性<br>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）<br>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><h4 id="Mysql-数据库索引。B-树和-B-树的区别"><a href="#Mysql-数据库索引。B-树和-B-树的区别" class="headerlink" title="Mysql 数据库索引。B+ 树和 B 树的区别"></a>Mysql 数据库索引。B+ 树和 B 树的区别</h4></li>
</ul>
<p>MySQL数据库索引和存储引擎有关，MyISAM和InnoDB只支持BTREE索引。MEMORY和HEAP支持HASH和BTREE索引</p>
<p><strong>B+树和B树的区别</strong></p>
<ol>
<li>B+树非叶子节点只存储关键字和指向子节点的指针，而B树还存储了数据，在同样大小的情况下，B+树可以存储更多的关键字</li>
<li>B+树叶子节点存储了所有关键字和数据，并且多个节点用链表连接。可以快速支撑范围查找</li>
<li>B+树非叶子节点不存储数据，所以查询时间复杂度固定为<code>O(logN)</code>，B树查询时间复杂度不固定，最好是<code>O(1)</code></li>
</ol>
<ul>
<li><h4 id="为什么-B-树比-B-树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）"><a href="#为什么-B-树比-B-树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）" class="headerlink" title="为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）"></a>为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）</h4></li>
</ul>
<p>因为B树叶子节点和非叶子结点都存储了数据，这样就导致了非叶子结点能保存的关键字和指针变少，如果要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能降低</p>
<p>除数据库索引，还有操作系统的文件索引用到了B树。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33369979/article/details/89810632">操作系统 文件索引结构</a></p>
<ul>
<li><h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1541265">聚簇索引和非聚簇索引</a></p>
<ol>
<li><strong>聚簇索引</strong>，又叫主键索引，每个表只有一个主键索引，叶子节点保存主键的值和数据</li>
<li><strong>非聚簇索引</strong>，又叫辅助索引，叶子节点保存索引字段的值和主键的值</li>
</ol>
<ul>
<li><h4 id="前缀索引和覆盖索引"><a href="#前缀索引和覆盖索引" class="headerlink" title="前缀索引和覆盖索引"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lm1060891265/article/details/81482358">前缀索引和覆盖索引</a></h4></li>
</ul>
<p><strong>1.前缀索引</strong></p>
<p>对于列的值较长，比如<code>BLOB、TEXT、VARCHAR</code>，就必须建立前缀索引，即将值的前一部分作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 <code>ORDER BY</code> 和 <code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p>
<p><strong>2.覆盖索引</strong></p>
<p><code>select</code>的数据列从索引中就能获得，不必再从数据表中读取。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</p>
<p>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在<code>EXPLAIN</code>的<code>Extra</code>列可以看到<code>“Using index”</code>的信息</p>
<ul>
<li><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021464570">索引失效情况</a></p>
<p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/1460000021464574.png" alt="索引失效的情况"></p>
<ul>
<li><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4></li>
</ul>
<p>假设有联合索引（a,b,c）：<br>①where条件为（a,b,c）、（b,a,c）、（c,a,b）等，会走联合索引；<br>②where条件为（a）、（a,b）、（a,b,c），会走联合索引；<br>③where条件为（b）、（c）、（b,c），不会走索引，会全表扫描；<br>④where条件为（a,c）时，会走索引，但只使用a的索引。</p>
<p>最左前缀原则:查询从索引的最左前列开始并且不跳过索引中的列,通俗易懂的来说就是:带头大哥不能死、中间兄弟不能断</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li><h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4></li>
</ul>
<p>事务是一个操作序列，这些操作要么全部执行，要么都不执行。</p>
<p>事务具有四大特性：A（原子性）、C（一致性）、I（隔离性）、D（持久性）</p>
<p><strong>1、原子性（Atomicity）：</strong> 事务开始后的所有操作<strong>要么全部完成，要么全部不完成，不能只完成一部分。</strong>事务执行过程中发生错误，会回滚已有操作并恢复到事务开始前的状态。<br><strong>2、一致性（Consistency）：</strong> 事务开始前和结束后，数据库的完整性没有被破坏。比如：A向B转账1000元，A的账户中会减少1000元，而B的账户中会增加1000元。<strong>一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。</strong><br><strong>3、隔离性（Isolation）：</strong> <strong>多个事务并发执行时，同一时间只允许一个事务请求同一数据，不同的事务之前不会互相干扰。</strong>如：A在从一张银行卡取款的过程中，其他人不能向这张银行卡转账。<br><strong>4、持久性（Durability）：</strong> 事务完成之后，事务对数据库的所有更改应该保存在数据库中，不能回滚。</p>
<ul>
<li><h4 id="MySQL事务如何实现"><a href="#MySQL事务如何实现" class="headerlink" title="MySQL事务如何实现"></a>MySQL事务如何实现</h4></li>
</ul>
<ol>
<li>原子性：通过<code>undo log</code>实现的。每条数据变更都伴随一条<code>undo log</code>日志的生成，当系统发生错误或执行回滚根据<code>undo log</code>做逆向操作</li>
<li>持久性：通过<code>redo log</code>实现的。<code>redo log</code>记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据</li>
<li>隔离性：mysql数据库通过<code>MVCC + next-key</code>机制实现了隔离性</li>
<li>一致性：以上3大特性，保障了事务的一致性</li>
</ol>
<ul>
<li><h4 id="事务并发的三大问题"><a href="#事务并发的三大问题" class="headerlink" title="事务并发的三大问题"></a>事务并发的三大问题</h4></li>
</ul>
<p><strong>1、脏读：</strong> 一个事务读取到了另一个事务未提交的数据。</p>
<p>例子：<strong>事务A修改了数据但还未提交</strong>，事务B读取到了事务A修改的数据。然后事务A因为某些错误回滚了，这个时候事务B读取到的数据就是脏的，这就是脏读。</p>
<p><strong>2、不可重复读：</strong>在同一事务内，事务两次读取到的数据是不一样的。(<strong>原数据中同一条数据被修改或被删除</strong>)</p>
<p>例子：事务A读取了一条数据之后，事务B修改了这条数据并提交了事务，然后事务A再次读取这条数据，就会发现两次结果不一致。这就是不可重复读。</p>
<p><strong>3、幻读：</strong> 一个事务多次读取同一数据，另一事务在其读取过程中对该数据进行了<strong>插入或删除</strong>（insert操作）并提交，导致这个事务前后读取的数据结果不一致。</p>
<p>例子：事务A使用一定的条件查询，然后事务B增加了符合条件的记录，当事务A再次查询的时候，发现两次查询的结果集不一样，好像产生了幻觉。这就是幻读。</p>
<ul>
<li><h4 id="Mysql-有哪些隔离级别"><a href="#Mysql-有哪些隔离级别" class="headerlink" title="Mysql 有哪些隔离级别"></a>Mysql 有哪些隔离级别</h4></li>
</ul>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交<code>（read-uncommitted）</code></td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交<code>（read-committed）</code></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读<code>（repeatable-read）</code></td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化<code>（serializable）</code></td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>读未提交(Read Uncommitted)<strong>：一个事务还没提交时，它做的变更就能被别的事务看到。</strong>解决更新丢失</strong>问题。如果一个事务<strong>已经开始写操作</strong>，那么其他事务则<strong>不允许同时进行写</strong>操作，但<strong>允许其他事务读</strong>此行数据。</p>
<p><strong>读已提交(Read Committed)<strong>：一个事务提交之后，它做的变更才会被其他事务看到。</strong>解决了脏读</strong>。读取数据的事务允许其他事务继续访问（访问指读和写）该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p>
<p><strong>可重复读取(Repeatable Read)<strong>：可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</strong>解决了不可重复读取和脏读取</strong>，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。</p>
<p><strong>串行化(Serializable)<strong>：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</strong>解决了幻读</strong>的提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。</p>
<ul>
<li><h4 id="Binlog-和-Redo-log-的区别是什么，分别是什么用？"><a href="#Binlog-和-Redo-log-的区别是什么，分别是什么用？" class="headerlink" title="Binlog 和 Redo log 的区别是什么，分别是什么用？"></a>Binlog 和 Redo log 的区别是什么，分别是什么用？</h4></li>
</ul>
<ol>
<li><code>binlog</code>是二进制文件，记录了对数据库执行更改的所有操作，不包括 <code>select、show</code>，因为这两个操作没有对数据本身做修改。但是若操作了数据，但是数据没有发生变化，也会记录到<code>binlog</code>。常用来数据恢复，数据备份。</li>
<li><code>redo log</code>又叫做重做日志文件，记录了事务的修改，不管事务是否提交都记录下来。在实例和介质失败时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复到之前的状态，保证数据的完整性</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wanbin6470398/article/details/81941586">https://blog.csdn.net/wanbin6470398/article/details/81941586</a></p>
<p>第一:redo log是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层产生的，并且二进制日志不仅仅针对INNODB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。</p>
<p>第二：两种日志记录的内容形式不同。<strong>MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。</strong></p>
<p>第三：两种日志与记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</p>
<p>第四：binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redo log是循环使用。</p>
<p>第五：binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</p>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>SELECT</strong></p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ol>
<p>只有符合上述两个条件的记录，才能返回作为查询结果</p>
<p><strong>INSERT</strong></p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p><strong>DELETE</strong></p>
<p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p><strong>UPDATE</strong></p>
<p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<h3 id="MySQL主从复制，读写分离"><a href="#MySQL主从复制，读写分离" class="headerlink" title="MySQL主从复制，读写分离"></a>MySQL主从复制，读写分离</h3><ul>
<li><h4 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制"></a>为什么要主从复制</h4></li>
</ul>
<p><strong>1、高可用性：</strong> 若主库发生故障，可快速切换到其中一个从库，从而保证系统业务的可用性。<br><strong>2、负载均衡：</strong> 主库用于写数据，各个从库用于读数据，实现读写分离，将流量分布到各个库上，从而实现负载均衡。<br><strong>3、可扩展性好：</strong> 当业务量很大的时候，为了抗住更多的读请求，可以增加从库，从而分担流量。</p>
<ul>
<li><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3></li>
</ul>
<p>MySQL主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。<br><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="在这里插入图片描述">主从复制的流程为：<br>①当主库进行insert、update、delete操作时，会按顺序写入到binlog（二进制日志）中；<br>②从库启动I/O线程，跟主库建立客户端连接；<br>③主库启动binlog dump线程，读取主库上binlog的内容发送给从库的I/O线程；<br>④从库的I/O线程接收到 binlog 内容后，将内容写入到本地的 relay log（中继日志）；<br>⑤从库启动SQL线程，读取relay log的内容，并完成对从库数据的更新。</p>
<p>上图为一个从库的流程，实际中，有N个从库，主库就会对应有N个binlog dump线程，而每个从库都会有自己的I/O线程和SQL线程。</p>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="df（全称：disk-free）"><a href="#df（全称：disk-free）" class="headerlink" title="df（全称：disk free）"></a>df（全称：disk free）</h3><p>df 命令以磁盘分区为单位查看文件系统中磁盘空间的使用情况</p>
<ul>
<li><strong>df -h</strong></li>
</ul>
<p>单纯使用df命令，其实不利于我们直接查看分区中空间使用情况，所以我们更常用df -h来进行查看，-h选项的意思是-human-readable:使用人类可读的格式，这也是比较常见的查看方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ df -h</span><br><span class="line">df: /run/user/1000/gvfs: 传输端点尚未连接</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            938M     0  938M    0% /dev</span><br><span class="line">tmpfs           195M  1.7M  193M    1% /run</span><br><span class="line">/dev/sda5        20G   12G  7.0G   62% /</span><br><span class="line">tmpfs           971M     0  971M    0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           971M     0  971M    0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0       56M   56M     0  100% /snap/core18/2284</span><br><span class="line">/dev/loop1      219M  219M     0  100% /snap/gnome-3-34-1804/72</span><br><span class="line">/dev/loop2      219M  219M     0  100% /snap/gnome-3-34-1804/77</span><br><span class="line">/dev/loop3      249M  249M     0  100% /snap/gnome-3-38-2004/99</span><br><span class="line">/dev/loop5       56M   56M     0  100% /snap/core18/2344</span><br><span class="line">/dev/loop4       62M   62M     0  100% /snap/core20/1376</span><br><span class="line">/dev/loop6      128K  128K     0  100% /snap/bare/5</span><br><span class="line">/dev/loop8       44M   44M     0  100% /snap/snapd/15177</span><br><span class="line">/dev/loop9       51M   51M     0  100% /snap/snap-store/547</span><br><span class="line">/dev/loop10      63M   63M     0  100% /snap/gtk-common-themes/1506</span><br><span class="line">/dev/loop11      44M   44M     0  100% /snap/snapd/14978</span><br><span class="line">/dev/loop12     248M  248M     0  100% /snap/gnome-3-38-2004/87</span><br><span class="line">/dev/loop13      55M   55M     0  100% /snap/snap-store/558</span><br><span class="line">/dev/loop14      66M   66M     0  100% /snap/gtk-common-themes/1519</span><br><span class="line">/dev/sda1       511M  4.0K  511M    1% /boot/efi</span><br><span class="line">tmpfs           195M   36K  195M    1% /run/user/1000</span><br><span class="line">vmhgfs-fuse     346G  297G   50G   86% /mnt/hgfs</span><br><span class="line">/dev/loop15      62M   62M     0  100% /snap/core20/1405</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="df-i选项"><a href="#df-i选项" class="headerlink" title="df -i选项"></a><strong>df -i选项</strong></h5></li>
</ul>
<p>有时候面试官大大也会问你，<strong>如何查看分区inode使用情况</strong>，这个也是使用Linux可能会遇到的问题，那如何查看呢？使用-i选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ df -i</span><br><span class="line">df: /run/user/1000/gvfs: 传输端点尚未连接</span><br><span class="line">文件系统        Inodes 已用(I) 可用(I) 已用(I)% 挂载点</span><br><span class="line">udev            240098     494  239604       1% /dev</span><br><span class="line">tmpfs           248465     931  247534       1% /run</span><br><span class="line">/dev/sda5      1277952  276937 1001015      22% /</span><br><span class="line">tmpfs           248465       1  248464       1% /dev/shm</span><br><span class="line">tmpfs           248465       5  248460       1% /run/lock</span><br><span class="line">tmpfs           248465      19  248446       1% /sys/fs/cgroup</span><br><span class="line">/dev/loop0       10847   10847       0     100% /snap/core18/2284</span><br><span class="line">/dev/loop1       18500   18500       0     100% /snap/gnome-3-34-1804/72</span><br><span class="line">/dev/loop2       18500   18500       0     100% /snap/gnome-3-34-1804/77</span><br><span class="line">/dev/loop3       17495   17495       0     100% /snap/gnome-3-38-2004/99</span><br><span class="line">/dev/loop5       10849   10849       0     100% /snap/core18/2344</span><br><span class="line">/dev/loop4       11777   11777       0     100% /snap/core20/1376</span><br><span class="line">/dev/loop6          29      29       0     100% /snap/bare/5</span><br><span class="line">/dev/loop8         482     482       0     100% /snap/snapd/15177</span><br><span class="line">/dev/loop9       15841   15841       0     100% /snap/snap-store/547</span><br><span class="line">/dev/loop10      62342   62342       0     100% /snap/gtk-common-themes/1506</span><br><span class="line">/dev/loop11        480     480       0     100% /snap/snapd/14978</span><br><span class="line">/dev/loop12      17441   17441       0     100% /snap/gnome-3-38-2004/87</span><br><span class="line">/dev/loop13      17311   17311       0     100% /snap/snap-store/558</span><br><span class="line">/dev/loop14      65095   65095       0     100% /snap/gtk-common-themes/1519</span><br><span class="line">/dev/sda1            0       0       0        - /boot/efi</span><br><span class="line">tmpfs           248465      90  248375       1% /run/user/1000</span><br><span class="line">vmhgfs-fuse          0       0       0        - /mnt/hgfs</span><br><span class="line">/dev/loop15      11778   11778       0     100% /snap/core20/1405</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="du（全称：disk-usage）"><a href="#du（全称：disk-usage）" class="headerlink" title="du（全称：disk usage）"></a>du（全称：disk usage）</h3><p>du命令也是检查硬盘使用情况，但是两者是有一定区别的。</p>
<ul>
<li>du 命令是统计文件或目录及其子目录的硬盘空间使用情况，一般可以帮我们快速定位目录下是否存在超大文件或其他特殊大小的文件。</li>
<li>df 命令是统计磁盘分区整体的使用情况。</li>
<li>du 命令会直接到特定目录内查找所有文件数据，并统计累加，所以命令执行时会耗费一点儿时间。</li>
<li>df 命令直接从文件系统中提取信息，所以比较快速。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a或--all             #列出所有的文件和目录容量大小而不仅仅列出目录容量大小</span><br><span class="line">-s或--summarize       #仅显示总计，只列出最后加总的值</span><br><span class="line">-h或--human-readable  #以K，M，G为单位，提高信息的可读性</span><br><span class="line">-c或--total           #除了列出文件和目录的容量大小外，最后在列出总容量</span><br><span class="line">--max-depth=N         #递归显示(仅仅是显示)时的递归深度小于等于N。--max-depth=0相当于-s参数</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#方便测试，给大家建立了如下目录结构</span></span><br><span class="line">[whb@VM_0_12_centos <span class="built_in">test</span>]$ tree .</span><br><span class="line">.</span><br><span class="line">|-- dir1</span><br><span class="line">|   |-- dir2</span><br><span class="line">|   |   `-- file2.txt</span><br><span class="line">|   `-- file1.txt</span><br><span class="line">|-- dirx</span><br><span class="line">|   `-- filex.txt</span><br><span class="line">`-- file.txt</span><br><span class="line">[whb@VM_0_12_centos <span class="built_in">test</span>]$ du   <span class="comment">#默认统计各个目录+目录下文件大小(目录容量)，但只以目录形式显示</span></span><br><span class="line">480  ./dirx</span><br><span class="line">400  ./dir1/dir2</span><br><span class="line">660  ./dir1</span><br><span class="line">1148  .</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[whb@VM_0_12_centos <span class="built_in">test</span>]$ du -a <span class="comment">#列出所有的文件大小和目录容量而不仅仅列出目录容量，默认只统计目录容量</span></span><br><span class="line">4  ./file.txt</span><br><span class="line">476  ./dirx/filex.txt</span><br><span class="line">480  ./dirx                   <span class="comment">#这里为何是480？回看一下我们定义的概念，你就明白了</span></span><br><span class="line">396  ./dir1/dir2/file2.txt</span><br><span class="line">400  ./dir1/dir2</span><br><span class="line">256  ./dir1/file1.txt</span><br><span class="line">660  ./dir1</span><br><span class="line">1148  .</span><br></pre></td></tr></table></figure>

<h3 id="cat-proc-cpuinfo"><a href="#cat-proc-cpuinfo" class="headerlink" title="cat /proc/cpuinfo"></a>cat /proc/cpuinfo</h3><ul>
<li><strong>查看CPU基本硬件信息</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ cat /proc/cpuinfo</span><br><span class="line">processor	: 0</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 158</span><br><span class="line">model name	: Intel(R) Core(TM) i5-9300H CPU @ 2.40GHz</span><br><span class="line">stepping	: 10</span><br><span class="line">microcode	: 0xde</span><br><span class="line">cpu MHz		: 2400.001</span><br><span class="line">cache size	: 8192 KB</span><br><span class="line">physical id	: 0</span><br><span class="line">siblings	: 1</span><br><span class="line">core id		: 0</span><br><span class="line">cpu cores	: 1</span><br><span class="line">apicid		: 0</span><br><span class="line">initial apicid	: 0</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 22</span><br><span class="line">wp		: yes</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>

<h3 id="top（实时进程状态）"><a href="#top（实时进程状态）" class="headerlink" title="top（实时进程状态）"></a>top（实时进程状态）</h3><p>Linux top命令用于实时显示 process 的动态。</p>
<p>使用权限：所有使用者。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒；</li>
<li>-b：使用批处理模式输出。一般和”-n”选项合用，用于把 top 命令重定向到文件中；</li>
<li>-n 次数：指定 top 命令执行的次数。一般和”-“选项合用；</li>
<li>-p 进程PID：仅查看指定 ID 的进程；</li>
<li>-s：使 top 命令在安全模式中运行，避免在交互模式中出现错误；</li>
<li>-u 用户名：只监听某个用户的进程；</li>
</ul>
<p>在 top 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：</p>
<ul>
<li>? 或 h：显示交互模式的帮助；</li>
<li>P：按照 CPU 的使用率排序，默认就是此选项；</li>
<li>M：按照内存的使用率排序；</li>
<li>N：按照 PID 排序；</li>
<li>T：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；</li>
<li>k：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号；</li>
<li>r：按照 PID 给某个进程重设优先级（Nice）值；</li>
<li>q：退出 top 命令；</li>
</ul>
<p>1.查看占用内存最多的前 N 个进程</p>
<ul>
<li>先执行 top 命令, 再使用快捷键 M 即可按内存占用降序排序</li>
</ul>
<p>2.查看 CPU 占用最多的前 N 个进程</p>
<ul>
<li>先执行 top 命令, 再使用快捷键 P 即可按照 CPU 占用降序排序</li>
</ul>
<p>3.查看某个进程中的线程情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p [pid]</span><br></pre></td></tr></table></figure>

<p>然后再使用快捷键 H 即可查看线程相关信息</p>
<h3 id="cat-proc-meminfo"><a href="#cat-proc-meminfo" class="headerlink" title="cat /proc/meminfo"></a>cat /proc/meminfo</h3><p><strong>查看内存基本容量信息</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ cat /proc/meminfo </span><br><span class="line">MemTotal:        1987724 kB</span><br><span class="line">MemFree:           85284 kB</span><br><span class="line">MemAvailable:    1002196 kB</span><br><span class="line">Buffers:          215668 kB</span><br><span class="line">Cached:           329224 kB</span><br><span class="line">SwapCached:        27432 kB</span><br><span class="line">Active:           406764 kB</span><br><span class="line">Inactive:         449960 kB</span><br><span class="line">Active(anon):     114820 kB</span><br><span class="line">Inactive(anon):   198272 kB</span><br><span class="line">Active(file):     291944 kB</span><br><span class="line">Inactive(file):   251688 kB</span><br><span class="line">Unevictable:           0 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:        945416 kB</span><br><span class="line">SwapFree:         555956 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 top 命令的内存部分非常相似。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>以 Byte（字节）为单位，显示内存使用情况。</td>
</tr>
<tr>
<td>-k</td>
<td>以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。</td>
</tr>
<tr>
<td>-m</td>
<td>以 MB 为单位，显示内存使用情况。</td>
</tr>
<tr>
<td>-g</td>
<td>以 GB 为单位，显示内存使用情况。</td>
</tr>
<tr>
<td>-t</td>
<td>在输出的最终结果中，输出内存和 swap 分区的总量。</td>
</tr>
<tr>
<td>-o</td>
<td>不显示系统缓冲区这一列。</td>
</tr>
<tr>
<td>-s 间隔秒数</td>
<td>根据指定的间隔时间，持续显示内存使用情况。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ free</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：     1987724      795200       82544        2824     1109980     1003556</span><br><span class="line">交换：      945416      389460      555956</span><br></pre></td></tr></table></figure>

<h3 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h3><p>查看<strong>Linux 查看系统版本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~/share/sign$ uname -a</span><br><span class="line">Linux ubuntu 5.13.0-35-generic <span class="comment">#40~20.04.1-Ubuntu SMP Mon Mar 7 09:18:32 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>使用 <strong>netstat</strong> 命令查看网络连接情况</p>
<p>参数解释:</p>
<ul>
<li>-a 显示所有选项</li>
<li>-t (tcp)仅显示tcp相关选项</li>
<li>-u (udp)仅显示udp相关选项</li>
<li>-n 拒绝显示别名，能显示数字的全部转化成数字。</li>
<li>-p 显示建立相关链接的程序名</li>
</ul>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看ip地址信息</p>
<p>由于一台主机可能同时具备多个网络接口, 查看到的 ip 地址也就可能有多个。</p>
<p>网络接口对应到主机的网卡或者虚拟网卡设备. 一台主机可以具有多个网卡, 也就可以有多个 IP 地址。</p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>Linux umask命令指定在<strong>建立文件时预设的权限掩码</strong>。</p>
<p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，<strong>将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限</strong></p>
<p><strong>语法</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [-S][权限掩码]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<p>-S 　以文字的方式来表示权限掩码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~$ umask</span><br><span class="line"><span class="number">0002</span></span><br><span class="line">fengyun@ubuntu:~$ umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br><span class="line">fengyun@ubuntu:~$ mkdir test1</span><br><span class="line">fengyun@ubuntu:~$ ls -d -l test1/</span><br><span class="line">drwxrwxr-x <span class="number">2</span> fengyun fengyun <span class="number">4096</span> Apr <span class="number">17</span> <span class="number">07</span>:<span class="number">09</span> test1/</span><br></pre></td></tr></table></figure>

<p>注意：在上面的输出信息中，”drwxrwxr-x”=”777-022=775”。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>chmod 在使用时，可以针对指定用户进行文件访问权限的设置或者增减，也可以通过八进制数字的形式设置文件的访问权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#高频选项</span></span><br><span class="line">-R 或 --recursive 　  <span class="comment">#递归处理，将指定目录下的所有文件及子目录一并处理</span></span><br><span class="line">&lt;访问者&gt;+&lt;权限设置&gt; 　  <span class="comment">#开启权限范围的文件或目录的该项权限设置。</span></span><br><span class="line">&lt;访问者&gt;-&lt;权限设置&gt; 　  <span class="comment">#关闭权限范围的文件或目录的该项权限设置。</span></span><br><span class="line">&lt;访问者&gt;=&lt;权限设置&gt; 　  <span class="comment">#指定权限范围的文件或目录的该项权限设置。</span></span><br><span class="line">+t                   <span class="comment">#设置目录文件的沾滞位</span></span><br></pre></td></tr></table></figure>

<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>文件的所有者拥有对文件的权限进行修改的权力，但是若我们想要将这个权力交给另一个用户，也就是修改一个文件的所有者，那么就需要使用chown命令（ps:全称change owner）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选项 -R         <span class="comment">#对目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)</span></span><br></pre></td></tr></table></figure>

<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>文件所属组中成员，具备对一个文件对应所属组的访问权限，若要将这个权力移交到另一个用户组中则需要使用chgrp命令（ps:全称change group）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R或--recursive 　<span class="comment">#递归处理，将指定目录下的所有文件及子目录一并处理。</span></span><br></pre></td></tr></table></figure>

<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>su 命令可让一个普通用户切换为超级用户或其他用户，并可临时拥有所切换用户的权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fengyun@ubuntu:~$ su - root</span><br><span class="line">密码： </span><br><span class="line">root@ubuntu:~<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo 是系统管理员允许让普通用户执行一些或者全部的root命令的一个工具(执行身份一般当然要短暂成为root喽)。</p>
<p>并且sudo不是对shell的一个代替，它是面向每个命令的，对于每个命令都可以使用sudo进行提权操作。使用sudo 提权操作不仅减少了root用户的登录和管理时间，同样也提高了安全性。</p>
<p><strong>/etc/sudoers配置文件的修改</strong>:</p>
<p>任何用户都可以随时使用sudo指令来对自己的操作进行提权吗？</p>
<p>不是这样的，若是这样的话，则root管理员用户形同虚设，只有管理员将指定用户添加入/etc/sudoers中，这个用户才可以进行提权操作，因为它是系统管理员集中的管理用户的使用权限和使用的主机的配置文件。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><img src="/../images/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/640.png" alt="图片"></p>
<p>我们的测试文件test.txt内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I love linux</span><br><span class="line">i love LINUX</span><br><span class="line">i Love Linux</span><br><span class="line">I LOVE LINUX</span><br><span class="line">i love Linu.*</span><br></pre></td></tr></table></figure>

<ul>
<li>-v 选项，反向匹配：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># grep -v love test.txt</span></span><br><span class="line">i Love Linux</span><br><span class="line">I LOVE LINUX</span><br></pre></td></tr></table></figure>

<ul>
<li>-i 选项，忽略大小写：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># grep -i love test.txt</span></span><br><span class="line">I love linux</span><br><span class="line">i love LINUX</span><br><span class="line">i Love Linux</span><br><span class="line">I LOVE LINUX</span><br></pre></td></tr></table></figure>

<ul>
<li>-n 选项，显示匹配行的行号：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># grep -n love test.txt</span></span><br><span class="line">1:I love linux</span><br><span class="line">2:i love LINUX</span><br></pre></td></tr></table></figure>

<ul>
<li>-E 支持扩展正则，| 是扩展正则中的特殊含义的符号，代表任意一个匹配（不是管道哦）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  grep -E &#x27;linux|LINUX&#x27; test.txt</span></span><br><span class="line">I love linux</span><br><span class="line">i love LINUX</span><br><span class="line">I LOVE LINUX</span><br></pre></td></tr></table></figure>

<ul>
<li>-F 不要按正则来解析，就要字符串本身:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  grep -F &quot;Linu.*&quot; test.txt</span></span><br><span class="line">i love Linu.*</span><br></pre></td></tr></table></figure>

<ul>
<li>-c 只显示匹配的行数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | grep -c &quot;root&quot; # 查找passwd文件中有多少行有root</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>高频选项：</p>
<ul>
<li>-name filename : 文件名称符合 filename 的文件 , 大小写敏感</li>
<li>-iname filname : 文件名称符合 name 的文件，忽略大小写</li>
<li>-empty : 空文件</li>
<li>-size：指定文件大小</li>
</ul>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq 命令<strong>用于检查及删除文本文件中重复出现的行列</strong>；如果使用该命令不加任何命令行参数，则视为删除指定文本文件当中重复的行之后进行输出；如果指定输出文件，则输出到指定文件当中。</p>
<p>高频选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c：在每列旁边显示该行重复出现的次数</span><br><span class="line">-u：仅显示出现一次的行</span><br><span class="line">[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据</span><br><span class="line">[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort 命令可以针对文本文件的内容，按行进行排序。在排序的时候以指定分隔符对文本文件进行内容分列。对指定列进行升序或降序排列，并且在排序的同时可以指定是否忽略大小写。</p>
<p>高频选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--<span class="built_in">help</span>][--verison][文件]</span><br><span class="line">-b：忽略每行前面开始的空格字符,空格数量不固定时,该选项几乎是必须要使用的</span><br><span class="line">-f：将小写字母视为大写字母</span><br><span class="line">-h：使用易读性数字(例如:2K、1G)</span><br><span class="line">-k：以哪个区间 (field) 来进行排序</span><br><span class="line">-n：依照数值的大小排序</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入指定的文件</span><br><span class="line">-r：降序</span><br><span class="line">-u：忽略相同行</span><br><span class="line">-t&lt;分隔字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</span><br><span class="line">--<span class="built_in">help</span> 显示帮助。</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure>

<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>读取一行，按照模式进行匹配，匹配上了通过对应的命令进行处理，然后继续下一行的处理</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YAmS9Me1bAbkGJ3oHuGP_w">https://mp.weixin.qq.com/s/YAmS9Me1bAbkGJ3oHuGP_w</a></p>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>AWK是一种样式扫描与处理的工具，其功能与 sed 和 grep 命令类似，却又远远强大于它们。</p>
<p>AWK不仅支持数据的扫描以及样式过滤，同时它还包含样式装入、流控制、数学运算符、进程控制语句甚至于内置变量和函数，几乎具备了一门完整编程语言的精美特性，因此，AWK 创始者们将其定义为样式、扫描、处理语言。</p>
<h3 id="cat-less-more-head-tail"><a href="#cat-less-more-head-tail" class="headerlink" title="cat/less/more/head/tail"></a>cat/less/more/head/tail</h3><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="以一个master进程，多个worker子进程作为整体进程框架"><a href="#以一个master进程，多个worker子进程作为整体进程框架" class="headerlink" title="以一个master进程，多个worker子进程作为整体进程框架"></a>以一个master进程，多个worker子进程作为整体进程框架</h3><ul>
<li>1.可以充分利用多核机器，增强并发处理能力。多个进程可以占用不同的CPU核心来工作</li>
<li>2.多 worker 间可以实现负载均衡。一个请求到来时更容易被分配到负载较轻的worker工作进程中处理。</li>
<li>3.Master 监控并统一管理 worker 行为。在 worker 异常后，可以主动拉起 worker 进程，从而提升了系统的可靠性。并且由 Master 进程控制服务运行中的程序升级、配置项修改等操作，从而增强了整体的动态可扩展与热更的能力。</li>
</ul>
<h3 id="利用单例类实现内存分配，读取配置文件和crc32校验算法"><a href="#利用单例类实现内存分配，读取配置文件和crc32校验算法" class="headerlink" title="利用单例类实现内存分配，读取配置文件和crc32校验算法"></a>利用单例类实现内存分配，读取配置文件和crc32校验算法</h3><p>我使用的是懒汉模式，但实际而言发挥的是饿汉模式，因为懒汉模式不保证线程安全，因此那些内存分配的类，读配置文件的类，crc32校验的类都是在master进程中执行的，执行完之后才fork生成worker子进程，这样我就保证了线程安全</p>
<h3 id="借助epoll-LT模式-同时监听多个I-O实现高并发通讯技术"><a href="#借助epoll-LT模式-同时监听多个I-O实现高并发通讯技术" class="headerlink" title="借助epoll[LT模式]同时监听多个I/O实现高并发通讯技术"></a>借助epoll[LT模式]同时监听多个I/O实现高并发通讯技术</h3><p>首先是4个worker进程都绑定ip和端口，返回不同的监听socket，然后将这个监听socket加入红黑树当中，连接池里面给他分配一个连接，如果三次握手进来了，epoll返回可写事件通知，我就通过epoll的event.data.ptr取出连接池的具体连接，调用监听socket连接的可读函数，这个可读函数会将调用accept()函数返回真正用于通信交流的socket，然后将这个真正用于通信交流的socket加入红黑树中并且分配一个连接池的连接设置好连接的读写处理函数，如果客户端有数据发过来，这个时候epoll会监听到，然后主线程会将数据收取到连接池中，并且会new一块新内存存储整个消息，这个消息除了包头包体以外还加上了消息头，消息头是存储了连接池连接和序号，然后将消息加入到收包的消息队列中，激发一个线程池中的线程来处理消息，线程池里会根据消息的操作码等信息调用相应的逻辑处理函数用来生成发送的包，线程池里面的线程处理完后生成一个发送消息放入发消息队列当中，</p>
<p>然后sem_post激发发消息线程来发包。然后发包线程取到那个消息，通过消息头获取连接池内具体连接，然后用一个<code>atomic&lt;int&gt;iThrowsendCount</code>来标记是否加入epoll监控。对于没加入epoll监控的可以让连接池的连接的发包指针指向消息队列的消息，但如果当前连接已经加入了epoll监控必须等待epoll监控的消息发完了再处理这个连接的包。对于取到的消息如果1.sendsize&gt;0且成功发送了整个包的所有数据，一下就发送出去这很顺利，那么把堆里面的存放消息的那块内存释放掉即可2.sendsize&gt;0但是没有全部发送完毕(EAGAIN)，数据只发出去了一部分，但肯定是因为 发送缓冲区满了，EPOLL_MOD给当前连接增加一个监听可写事件</p>
<h3 id="构建线程池处理业务逻辑，使用状态机解析客户端请求，线程间同步技术包括互斥量，信号量等"><a href="#构建线程池处理业务逻辑，使用状态机解析客户端请求，线程间同步技术包括互斥量，信号量等" class="headerlink" title="构建线程池处理业务逻辑，使用状态机解析客户端请求，线程间同步技术包括互斥量，信号量等"></a>构建线程池处理业务逻辑，使用状态机解析客户端请求，线程间同步技术包括互斥量，信号量等</h3><p>借助pthread_cont_wait()和</p>
<p>对于m_pthreadCond 而言<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex); </code>刚开始时初始状态，没有什么东西来激发它，<strong>会卡在这里，而且m_pthreadMutex会被释放掉；</strong><br>第一个线程执行到这一句的时候，m_pthreadMutex会被释放掉，第二个线程得以在while循环中往下执行。如果有100个线程，最终结果是100个线程都会卡在这里并且m_pthreadMutex会被释放掉。这100个线程都在等待m_pthreadCond这个条件。</p>
<p>pthread_cond_signal唤醒一个等待该条件的线程，也就是可以唤醒卡在<code>pthread_cond_wait(&amp;m_pthreadCond, &amp;m_pthreadMutex)</code>的线程</p>
<h3 id="构建连接池并且实现了对客户端关闭连接的延迟回收"><a href="#构建连接池并且实现了对客户端关闭连接的延迟回收" class="headerlink" title="构建连接池并且实现了对客户端关闭连接的延迟回收"></a>构建连接池并且实现了对客户端关闭连接的延迟回收</h3><p>一个连接，如果我们程序判断这个连接不用了；那么 不 应该把这个连接立即放到空闲队列里，而是 应该放到一个地方；<br>等待一段时间【60】，60秒之后，我再真正的回收这个连接到 连接池/空闲队列 中去，这种连接才可以真正的分配给其他用户使用；为什么要等待60秒，就是需要确保即便用户张三真断线了，那么我执行的该用户的业务逻辑也一定能在这个等待时间内全部完成；这个连接不立即回收是非常重要的，有个时间缓冲非常重要；这个可以在极大程度上确保服务器的稳定。</p>
<h3 id="处理了惊群问题和已知的安全问题如恶意用户持续连入，积压过多数据包等"><a href="#处理了惊群问题和已知的安全问题如恶意用户持续连入，积压过多数据包等" class="headerlink" title="处理了惊群问题和已知的安全问题如恶意用户持续连入，积压过多数据包等"></a>处理了惊群问题和已知的安全问题如恶意用户持续连入，积压过多数据包等</h3><p>该用户收消息太慢【或者干脆不收消息】，累积的该用户的发送队列中有的数据条目数过大，认为是恶意用户，直接切断</p>
<h3 id="一些特点"><a href="#一些特点" class="headerlink" title="一些特点"></a>一些特点</h3><p>消息头 ：连接池的连接指针和序列号（用于判断包是否过时）<br>对于连接池的每个连接都是有一个序号iCurrsequence，连接初始化的时候++iCurrsequence，连接释放的时候++iCurrsequence，因此当收到一个包的时候，将连接连接池的序号iCurrsequence记录在包的消息头中，当处理完这个包后想要发回给客户端的时候可以比较一下包的iCurrsequence与连接池的iCurrsequence是否一致，如果不一致说明连接已经断开了，丢弃即可。</p>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ol>
<li>无法从epoll连接取不出来了，epoll绑定event.data.ptr这个操作只在EPOLL_CTL_ADD的时候做一次即可，但是发现EPOLL_CTL_MOD<strong>似乎会破坏掉ev.data.ptr</strong>，因此不管是EPOLL_CTL_ADD，还是EPOLL_CTL_MOD，ev.data.ptr都要去重新绑定！！！</li>
</ol>
<h3 id="miniOS"><a href="#miniOS" class="headerlink" title="miniOS"></a>miniOS</h3><h3 id="汇编与C语言混合实现了可以人机交互的x86-32位操作系统"><a href="#汇编与C语言混合实现了可以人机交互的x86-32位操作系统" class="headerlink" title="汇编与C语言混合实现了可以人机交互的x86 32位操作系统"></a>汇编与C语言混合实现了可以人机交互的x86 32位操作系统</h3><h3 id="自定义了进程模型并且实现了进程各个状态间的切换"><a href="#自定义了进程模型并且实现了进程各个状态间的切换" class="headerlink" title="自定义了进程模型并且实现了进程各个状态间的切换"></a>自定义了进程模型并且实现了进程各个状态间的切换</h3><h3 id="独立实现了动态内存分配，包括链表分配法和固定小碎片分配法"><a href="#独立实现了动态内存分配，包括链表分配法和固定小碎片分配法" class="headerlink" title="独立实现了动态内存分配，包括链表分配法和固定小碎片分配法"></a>独立实现了动态内存分配，包括链表分配法和固定小碎片分配法</h3><h3 id="实现了进程互斥锁与事件机制，可以控制进程间的执行顺序"><a href="#实现了进程互斥锁与事件机制，可以控制进程间的执行顺序" class="headerlink" title="实现了进程互斥锁与事件机制，可以控制进程间的执行顺序"></a>实现了进程互斥锁与事件机制，可以控制进程间的执行顺序</h3><h3 id="实现了键盘驱动程序和一些shell任务与用户进行交互"><a href="#实现了键盘驱动程序和一些shell任务与用户进行交互" class="headerlink" title="实现了键盘驱动程序和一些shell任务与用户进行交互"></a>实现了键盘驱动程序和一些shell任务与用户进行交互</h3><h3 id="设计并实现了文件系统，可以对硬盘进行读写"><a href="#设计并实现了文件系统，可以对硬盘进行读写" class="headerlink" title="设计并实现了文件系统，可以对硬盘进行读写"></a>设计并实现了文件系统，可以对硬盘进行读写</h3><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官你好，很荣幸今天能够来参加xx面试，我叫冯云，来自华中科技大学，今年大三，我从大一开始成绩就一直保持在前15%这样一个不错的成绩，大二的时候就选择了C++这门语言作为深入学习的一门语言，并且把计算机网络操作系统等核心课程给修完了，大三的时候呢决定直接找工作不读研，并且进一步的学习了C++并且完成了一个服务器项目。</p>
<p>你的优点？</p>
<p>年轻，我是个00后，而且不读研，进去直接工作通常来说是比别人更年轻三岁，意味着我试错成本是更高的，我有更多的时间去发展我的技术</p>
<p>做事比较有条理，上大学时别的同学都喜欢借我的笔记，我的个人物品和学习资料都很有规律，我宿舍的时候，舍友很容易就能找到他们需要用的资料，包括电脑上的文件。我觉得有条理是一种习惯，只要坚持每个人都可以做到。然后可以看看我的博客，分门别类也是比较清楚的</p>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><h3 id="钉钉一面"><a href="#钉钉一面" class="headerlink" title="钉钉一面"></a>钉钉一面</h3><p>使用过哪些种类的智能指针？有什么区别以及使用场合？用的时候的注意事项？</p>
<p>基类与子类的成员的内存分布情况？（代码段，成员变量，虚函数指针）</p>
<p>析构函数抛出异常？</p>
<p>一个指针数组，类型是基类的指针类型，实际存放的是子类的指针？如果执行delete []有什么问题？<br>（第一个对象释放完后，搜索的指针会往后移动，对第二个对象做析构以及内存回收，基类的内存大小可能更小，但是实际而言子类的内存更大，这个时候指针位置可能没有对准子类对象的头部）</p>
<p>右值引用和move（底层执行的是static_cast）</p>
<p>auto 直接声明一个变量会报错吗？（编译器都不知道类型，怎么给他分配内存？当然报错）</p>
<p>constexpr？（修饰变量和函数）</p>
<p>noexcept？如果已经声明了noexcept但是又抛出了异常会怎么样？（会报错）</p>
<p>const？mutable？</p>
<p>volatile？</p>
<p>万能引用？引用折叠？</p>
<p>默认初始化和值初始化？</p>
<p><strong>值初始化：</strong></p>
<p><strong>（1）在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；</strong></p>
<p><strong>（2）静态static变量、*<em>**定义在块作用域外的全局变量，**</em>*如果没有显式的初始值，将执行值初始化；</strong></p>
<p><strong>（3）当我们通过书写形如T()的表达式（例如 int()）显式地请求值初始化时；</strong></p>
<p><strong>默认初始化：</strong></p>
<p><strong>（1）当我们在块作用域内（类内也属于块作用域内）不使用任何初始值定义一个非静态变量时；</strong></p>
<p><strong>（2）当一个类本身含有类类型成员且使用合成的默认构造函数时；</strong></p>
<p><strong>（3）当类类型的成员没有在构造函数初始值列表中显式地初始化时；</strong></p>
<p>同步异步，阻塞非阻塞（还需强化一下）</p>
<p>HTTPS加密（数字签名？）</p>
<p>刷题奇怪函数</p>
<p>tolower()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    s[i] = <span class="built_in">tolower</span>(s[i]);</span><br></pre></td></tr></table></figure>



<h3 id="美团一面"><a href="#美团一面" class="headerlink" title="美团一面"></a>美团一面</h3><ol>
<li><p>vector吗？vector底层是怎么实现的啊</p>
</li>
<li><p>arraylist</p>
</li>
<li><p>map和unordered_map</p>
</li>
<li><p>哈希表拉链法和线性探测法的区别与优缺点（空间局部性去考虑）</p>
</li>
<li><p>map线程安全吗？</p>
</li>
<li><p>哈希做缓存如何提升效率并且保证线程安全？<br><strong>将所有public方法都加上synchronized</strong>： 相当于设置了一把全局锁，所有操作都需要先获取锁（比如直接使用Collections.synchronizedMap()方法对其进行加锁操作），java.util.HashTable就是这么做的，性能很低</p>
<p><strong>2.<strong>由于每个桶在逻辑上是相互独立的，</strong>将每个桶都加一把锁</strong>，如果两个线程各自访问不同的桶，就不需要争抢同一把锁了。这个方案的并发性比单个全局锁的性能要好，不过锁的个数太多，也有很大的开销。</p>
<p><strong>3.锁分离(Lock Stripping)技术：</strong>第2个方法把锁的压力分散到了多个桶，理论上是可行的的，但是假设有1万个桶，就要新建1万个ReentrantLock实例，开销很大。可以将所有的桶均匀的划分为16个部分，<em>*每一部分成为一个段(Segment)，每个段上有一把锁，这样锁的数量就降低到了16个，**JDK 7里的java.util.concurrent.ConcurrentHashMap就是这个思路*<em><strong>。<br><strong>4.</strong> <strong>**在JDK8里，ConcurrentHashMap的实现又有了很大变化*<em><strong>，它</strong>在锁分离的基础上，大量利用了了CAS指令</em>*。并且</strong>底层存储有一个小优化</strong>，当链表长度太长（默认超过8）时，链表就转换为红黑树。链表太长时，增删查改的效率比较低，改为红黑树可以提高性能。</em>***实现的难度有点高，JDK8里的ConcurrentHashMap有6000多行代码，JDK7才1500多行。*</em>**</p>
</li>
<li><p>B+数底层实现，mysql索引为何使用B+树而不是红黑树</p>
</li>
<li><p>自旋锁和互斥锁</p>
</li>
<li><p>TCP/UDP，视频的传输底层用什么协议比较好？TCP如何保证各个数据包的有序性？TCP的重发机制？</p>
</li>
<li><p>算法题：二叉树的最小深度</p>
</li>
</ol>
<h3 id="雷火一面"><a href="#雷火一面" class="headerlink" title="雷火一面"></a>雷火一面</h3><ol>
<li>在 ip 地址为192.168.2.23/255.255.254.0 主机所在的子网里, 广播地址为________________</li>
</ol>
<p>192.168.3.255</p>
<ol start="2">
<li>阅读下面程序，写出在32位系统运行后的结果：________________</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;glad to test something&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = str;</span><br><span class="line">p++; </span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">p1++; </span><br><span class="line">p = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result is %s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>result is to test something</p>
<ol start="3">
<li>有两张mysql的表记录了员工的一些基本信息如下：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1;</span><br><span class="line">id	name	age</span><br><span class="line"><span class="number">1</span>	aaa	<span class="number">25</span></span><br><span class="line"><span class="number">2</span>	bbb	<span class="number">31</span></span><br><span class="line"><span class="number">4</span>	ddd	<span class="number">30</span></span><br><span class="line"><span class="number">5</span>	eee	<span class="number">28</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test2;</span><br><span class="line">id	gender</span><br><span class="line"><span class="number">1</span>	M</span><br><span class="line"><span class="number">2</span>	F</span><br><span class="line"><span class="number">3</span>	F</span><br><span class="line"><span class="number">5</span>	M</span><br></pre></td></tr></table></figure>

<p>两张表的id都是PRIMARY KEY，现在希望查询出所有在test1表和test2表均有记录的员工的信息（即交集），并按照性别和年龄排序（所有女性排在男性前面，同性别再按年龄降序排）。</p>
<p>用一条sql语句实现</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>以下函数中，不能定义为虚函数的有____________ （多选题）</li>
</ol>
<p>A. 构造函数 B. 析构函数 C. 静态成员函数 D. 内联函数 E. operator=</p>
<p>ACD</p>
<ol start="5">
<li>C 语言中下面的表达式中值为 0 的是________________</li>
</ol>
<p>A. 3/5<br>B. 5&gt;&gt;3<br>C. !3<br>D. ~3</p>
<p>ABC</p>
<p>C++11的原子操作</p>
<h3 id="雷火二面"><a href="#雷火二面" class="headerlink" title="雷火二面"></a>雷火二面</h3><ol>
<li>菱形继承的内存分布和问题</li>
<li>map和unordered_map</li>
<li>fork出一个子进程是共用socket吗</li>
<li>自旋锁的底层实现？CAS</li>
<li>内核态和用户态</li>
</ol>
<h3 id="腾讯音乐二面"><a href="#腾讯音乐二面" class="headerlink" title="腾讯音乐二面"></a>腾讯音乐二面</h3><p>1.函数调用栈</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">长烟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yunf194.github.io/2022/03/02/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">http://yunf194.github.io/2022/03/02/202232-C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yunf194.github.io" target="_blank">fengyun's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/p11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/02/202231-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"><img class="prev-cover" src="/images/cover/p11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">左值和右值</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/01/202231-%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src="/images/cover/p11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/20/2022220-bool%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/" title="bool类型和引用"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">bool类型和引用</div></div></a></div><div><a href="/2022/02/20/2022220-const%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="const深度解析"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">const深度解析</div></div></a></div><div><a href="/2022/02/20/2022220-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/" title="编译链接"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">编译链接</div></div></a></div><div><a href="/2022/02/21/2022221-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" title="函数深度分析"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">函数深度分析</div></div></a></div><div><a href="/2022/02/21/2022221-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/" title="程序内存详解"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">程序内存详解</div></div></a></div><div><a href="/2022/02/22/2022222-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" title="动态内存分配"><img class="cover" src="/images/cover/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">动态内存分配</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunf194.github.io/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">长烟</div><div class="author-info__description">交际是分享快乐，独处是消化自我</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunf194"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yunf194" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2846327307@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我明白你会来所以我等</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">类的构造函数、析构函数、赋值函数、拷贝函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">赋值函数和拷贝构造函数的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.</span> <span class="toc-text">移动构造函数与拷贝构造函数对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">构造函数和析构函数抛出异常？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E9%83%A8%E9%83%BD%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8EC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">C++与C的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB-4%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">struct与class的区别(4点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">多态，虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9FC-%E7%9A%84%E5%A4%9A%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是多态？C++的多态是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">内联函数是虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">虚函数实现动态多态的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">虚函数指针、虚函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">虚函数表的结构是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%98%AF%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E7%A1%AE%E5%AE%9A%E8%BF%98%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.7.</span> <span class="toc-text">构造函数能不能为虚函数？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%97%B6%EF%BC%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text">继承时，父类的析构函数是否为虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-%E5%9F%BA%E7%B1%BB%E7%9A%84-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.5.9.</span> <span class="toc-text">在(基类的)构造函数和析构函数中调用虚函数会怎么样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.10.</span> <span class="toc-text">虚函数、纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.11.</span> <span class="toc-text">静态函数可以是虚函数么？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">类的内存模型，继承问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%B8%AD%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%B8%83%E5%B1%80-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">c++中类对象的内存模型(布局)是怎么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3-%E8%8F%B1%E5%BD%A2-%E7%BB%A7%E6%89%BF%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">钻石(菱形)继承存在什么问题，如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">空类有哪些函数？空类的大小？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">请说一下以下几种情况下，下面几个类的大小各是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.6.6.</span> <span class="toc-text">this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84this%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">类的this指针有以下特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E5%A0%86%E6%A0%88%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">this指针调用成员变量时，堆栈会发生什么变化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%9C%9F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">为什么是不可预期的问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">如果在类的析构函数中调用delete this，会发生什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">内存管理（内存分配、内存对齐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E6%A0%88%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E3%80%81%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-number">1.7.1.</span> <span class="toc-text">C++的内存分区：全局区、堆区、栈区、常量区、代码区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">堆和栈的内存有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8CC%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%9D%A5%E5%81%9A%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%83%BD%E5%90%A6%E6%B7%B7%E7%94%A8%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90-%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">什么是内存泄露？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#valgrind%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.6.</span> <span class="toc-text">valgrind原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98new-malloc-delete-free%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.8.</span> <span class="toc-text">内存new&#x2F;malloc&#x2F;delete&#x2F;free使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.9.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.10.</span> <span class="toc-text">各种关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9Fstatic%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">static的作用？static变量什么时候初始化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E9%92%88%E3%80%81%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">const关键字：修饰变量、指针、类对象、类中成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.10.3.</span> <span class="toc-text">extern的作用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explicit%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.10.4.</span> <span class="toc-text">explicit的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.10.5.</span> <span class="toc-text">constexpr的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.10.6.</span> <span class="toc-text">volatile的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.10.7.</span> <span class="toc-text">mutable的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E5%92%8Cdeltype%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.10.8.</span> <span class="toc-text">auto和deltype的作用和区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0default"><span class="toc-number">1.10.9.</span> <span class="toc-text">构造函数default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0delete"><span class="toc-number">1.10.10.</span> <span class="toc-text">构造函数delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">1.11.</span> <span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.</span> <span class="toc-text">C++11新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82"><span class="toc-number">1.13.</span> <span class="toc-text">杂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.1.</span> <span class="toc-text">inline 内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof%E4%B8%8Estrlen%E5%AF%B9%E6%AF%94"><span class="toc-number">1.13.2.</span> <span class="toc-text">sizeof与strlen对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.3.</span> <span class="toc-text">深拷贝与浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.4.</span> <span class="toc-text">指针与引用的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%90%84%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">STL各种容器底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%90%84%E7%A7%8D%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%89%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">STL各种容器的查找、删除和插入的时间复杂度（性能比较）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E6%80%8E%E4%B9%88%E5%81%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%8CAllocator%E6%AC%A1%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8%E7%9A%84push-back%E5%92%8Cemplace-back%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">STL容器的push_back和emplace_back的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E7%9A%84%E6%8E%92%E5%BA%8F%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%8C%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">STL的排序用到了哪种算法，具体如何执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%AF%E8%B4%A8%E6%95%B0%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%EF%BC%9F%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.7.</span> <span class="toc-text">STL 迭代器删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E4%B8%8Eunordered-map%E5%AF%B9%E6%AF%94"><span class="toc-number">2.8.</span> <span class="toc-text">map与unordered_map对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C%E5%92%8Cinsert%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">map的下标操作和insert区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E5%92%8C-set-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.</span> <span class="toc-text">map 和 set 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E2%BE%A5-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">STL ⾥ resize 和 reserve 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">3.1.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-MAC%E5%9C%B0%E5%9D%80%E5%92%8CIP%E5%9C%B0%E5%9D%80%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">说说 MAC地址和IP地址分别有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol-%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">什么是ARP协议 (Address Resolution Protocol)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%B8%BA%E5%95%A5%E6%9C%89IP%E5%9C%B0%E5%9D%80%E8%BF%98%E9%9C%80%E8%A6%81MAC%E5%9C%B0%E5%9D%80%EF%BC%9F%E5%90%8C%E7%90%86%EF%BC%8C%E4%B8%BA%E5%95%A5%E6%9C%89%E4%BA%86MAC%E5%9C%B0%E5%9D%80%E8%BF%98%E9%9C%80%E8%A6%81IP%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E8%BD%AC%E5%8F%91%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">7、网络层转发数据报的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">3.6.</span> <span class="toc-text">8、子网划分、子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP"><span class="toc-number">3.7.</span> <span class="toc-text">9、网络控制报文协议ICMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81ICMP%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9APING%E3%80%81traceroute"><span class="toc-number">3.8.</span> <span class="toc-text">10、ICMP应用举例：PING、traceroute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.9.</span> <span class="toc-text">路由器与交换机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP"><span class="toc-number">3.10.</span> <span class="toc-text">TCP&#x2F;UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">3.11.</span> <span class="toc-text">TCP三次握手及状态变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8F%8A%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">3.12.</span> <span class="toc-text">TCP四次挥手及状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84ACK%E5%92%8CFIN%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88CLOSE-WAIT%E7%8A%B6%E6%80%81%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%89%EF%BC%9F"><span class="toc-number">3.12.0.1.</span> <span class="toc-text">为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E3%80%81%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E3%80%81%E9%A6%96%E9%83%A8%E5%AD%97%E8%8A%82%E3%80%81%E6%89%80%E9%9C%80%E8%B5%84%E6%BA%90%EF%BC%89"><span class="toc-number">3.13.</span> <span class="toc-text">TCP与UDP的区别及应用场景（建立连接、一对一、字节流、流量控制、拥塞控制、首部字节、所需资源）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E3%80%81TCP%E9%A6%96%E9%83%A8%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%88SYN%E3%80%81ACK%E3%80%81FIN%E3%80%81RST%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%EF%BC%89"><span class="toc-number">3.14.</span> <span class="toc-text">UDP、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.15.</span> <span class="toc-text">TCP流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E7%AA%97%E5%8F%A3%EF%BC%88%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E4%B8%BA0%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%89%EF%BC%9F"><span class="toc-number">3.15.0.1.</span> <span class="toc-text">什么是零窗口（接收窗口为0时会怎样）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%88%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E3%80%81%E5%BF%AB%E6%81%A2%E5%A4%8D%E3%80%82%EF%BC%89"><span class="toc-number">3.16.</span> <span class="toc-text">TCP拥塞控制（慢开始、拥塞避免、快重传、快恢复。）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">TCP如何保证可靠性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.18.</span> <span class="toc-text">UDP为什么是不可靠的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-number">3.19.</span> <span class="toc-text">TCP 最大连接数限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%E3%80%82%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">SYN泛洪攻击。如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85"><span class="toc-number">3.21.</span> <span class="toc-text">TCP粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81TCP%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">3.22.</span> <span class="toc-text">22、TCP心跳包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">3.23.</span> <span class="toc-text">24、UDP如何实现可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9A"><span class="toc-number">3.24.</span> <span class="toc-text">应用层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E3%80%82%E9%87%87%E7%94%A8TCP%E8%BF%98%E6%98%AFUDP%E5%8D%8F%E8%AE%AE%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.25.</span> <span class="toc-text">DNS域名系统。采用TCP还是UDP协议？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81FTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.26.</span> <span class="toc-text">26、FTP协议（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.27.</span> <span class="toc-text">27、HTTP请求报文与响应报文首部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-HTTP-1-0%EF%BC%8C1-1%EF%BC%8C2-0-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">3.28.</span> <span class="toc-text">简述 HTTP 1.0，1.1，2.0 的主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E5%AF%B9%E6%AF%94%EF%BC%884%E7%82%B9%EF%BC%89"><span class="toc-number">3.29.</span> <span class="toc-text">HTTP与HTTPS对比（4点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">3.30.</span> <span class="toc-text">HTTPS加密流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%92%8C%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.31.</span> <span class="toc-text">HTTP请求方法和状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-GET%E8%AF%B7%E6%B1%82%E5%92%8C-POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E4%BD%8D%E7%BD%AE%E3%80%81%E6%98%8E%E6%96%87%E5%AF%86%E6%96%87%E3%80%81%E5%AE%89%E5%85%A8%E3%80%81%E9%95%BF%E5%BA%A6%E3%80%81%E5%9C%BA%E6%99%AF%E3%80%91"><span class="toc-number">3.32.</span> <span class="toc-text">说说 GET请求和 POST 请求的区别【位置、明文密文、安全、长度、场景】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcookie%E5%92%8Csession%EF%BC%9F"><span class="toc-number">3.33.</span> <span class="toc-text">什么是cookie和session？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%884%E7%82%B9%EF%BC%89"><span class="toc-number">3.34.</span> <span class="toc-text">Cookie和Session的区别？（4点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%88%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD%EF%BC%8C%E6%90%9E%E6%98%8E%E7%99%BD%E8%BF%99%E4%B8%AA%EF%BC%8C%E7%BD%91%E7%BB%9C%E8%BF%99%E5%9D%97%E5%B0%B1%E5%B7%AE%E4%B8%8D%E5%A4%9A%E4%BA%86%EF%BC%89"><span class="toc-number">3.35.</span> <span class="toc-text">输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%88%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%EF%BC%8C%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%8B%A5%E6%9C%89%E8%B5%84%E6%BA%90%EF%BC%8C%E5%86%85%E5%AD%98%EF%BC%8C%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%81%A5%E5%A3%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">进程与线程区别（资源调度，关系，拥有资源，内存，通信，健壮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">4.1.2.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">进程切换流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.4.</span> <span class="toc-text">进程的调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%94%81%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%81%E4%BF%A1%E5%8F%B7%E3%80%81%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.1.5.</span> <span class="toc-text">线程同步的方式：锁、信号量、信号、屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.1.6.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9APIPE%E3%80%81FIFO%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%81%E4%BF%A1%E5%8F%B7%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81socket"><span class="toc-number">4.1.7.</span> <span class="toc-text">进程间通信：PIPE、FIFO、消息队列、信号量、信号、共享内存、socket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.1.</span> <span class="toc-text">互斥锁与自旋锁的底层区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">孤儿进程与僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%8F%8A%E9%81%BF%E5%85%8D"><span class="toc-number">4.4.</span> <span class="toc-text">死锁及避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%E3%80%81%E4%BC%98%E5%8A%A3%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">4.5.</span> <span class="toc-text">多进程与多线程间的对比、优劣与选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">请你说说什么是守护进程，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94"><span class="toc-number">4.7.</span> <span class="toc-text">8、管道与消息队列对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81fork%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%EF%BC%9A%E8%AF%BB%E6%97%B6%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">4.8.</span> <span class="toc-text">9、fork进程的底层：读时共享，写时复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">进程、线程的中断切换的过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.10.</span> <span class="toc-text">阻塞IO与非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.11.</span> <span class="toc-text">同步与异步的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">静态链接与动态链接的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.12.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.12.2.</span> <span class="toc-text">动态链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">4.13.</span> <span class="toc-text">用户态和内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.14.</span> <span class="toc-text">虚拟内存概念（非常重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81MMU%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.15.</span> <span class="toc-text">17、MMU地址翻译的具体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E7%BC%BA%E9%A1%B5%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.16.</span> <span class="toc-text">18、缺页处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E3%80%81%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95%E3%80%81%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.17.</span> <span class="toc-text">缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E5%87%A0%E4%B9%8E%E5%BF%85%E9%97%AE%EF%BC%8C%E5%9B%9E%E7%AD%94%E5%BE%97%E8%B6%8A%E5%BA%95%E5%B1%82%E8%B6%8A%E5%A5%BD%EF%BC%8C%E8%A6%81%E4%BC%9A%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">4.18.</span> <span class="toc-text">1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%89%8B%E6%92%95%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84server%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88socket%E3%80%81bind%E3%80%81listen%E3%80%81accept%E8%BF%99%E5%9B%9B%E4%B8%AAAPI%E4%B8%80%E5%AE%9A%E8%A6%81%E9%9D%9E%E5%B8%B8%E7%86%9F%E7%BB%83%EF%BC%89"><span class="toc-number">4.19.</span> <span class="toc-text">2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.20.</span> <span class="toc-text">3、线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.21.</span> <span class="toc-text">4、基于事件驱动的reactor模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.22.</span> <span class="toc-text">5、边沿触发与水平触发的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E9%98%BB%E5%A1%9EIO%E5%8C%BA%E5%88%AB"><span class="toc-number">4.23.</span> <span class="toc-text">6、非阻塞IO与阻塞IO区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mySQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">mySQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.1.</span> <span class="toc-text">数据存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">数据库范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.4.</span> <span class="toc-text">索引优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">5.4.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E3%80%82B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.3.</span> <span class="toc-text">Mysql 数据库索引。B+ 树和 B 树的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-B-%E6%A0%91%E6%AF%94-B-%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%99%A4%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%94%A8%E5%88%B0%E4%BA%86%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">5.4.4.</span> <span class="toc-text">为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">5.4.5.</span> <span class="toc-text">聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.4.6.</span> <span class="toc-text">前缀索引和覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">5.4.7.</span> <span class="toc-text">索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">5.4.8.</span> <span class="toc-text">最左前缀原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">5.5.1.</span> <span class="toc-text">事务四大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text">MySQL事务如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.3.</span> <span class="toc-text">事务并发的三大问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.5.4.</span> <span class="toc-text">Mysql 有哪些隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binlog-%E5%92%8C-Redo-log-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.5.5.</span> <span class="toc-text">Binlog 和 Redo log 的区别是什么，分别是什么用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">5.6.</span> <span class="toc-text">MVCC 多版本并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">5.7.</span> <span class="toc-text">MySQL主从复制，读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.7.1.</span> <span class="toc-text">为什么要主从复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">主从复制的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">Linux命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#df%EF%BC%88%E5%85%A8%E7%A7%B0%EF%BC%9Adisk-free%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">df（全称：disk free）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#df-i%E9%80%89%E9%A1%B9"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">df -i选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#du%EF%BC%88%E5%85%A8%E7%A7%B0%EF%BC%9Adisk-usage%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">du（全称：disk usage）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat-proc-cpuinfo"><span class="toc-number">6.3.</span> <span class="toc-text">cat &#x2F;proc&#x2F;cpuinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top%EF%BC%88%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">top（实时进程状态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat-proc-meminfo"><span class="toc-number">6.5.</span> <span class="toc-text">cat &#x2F;proc&#x2F;meminfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-number">6.6.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uname-a"><span class="toc-number">6.7.</span> <span class="toc-text">uname -a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">6.8.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig"><span class="toc-number">6.9.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#umask"><span class="toc-number">6.10.</span> <span class="toc-text">umask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod"><span class="toc-number">6.11.</span> <span class="toc-text">chmod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown"><span class="toc-number">6.12.</span> <span class="toc-text">chown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chgrp"><span class="toc-number">6.13.</span> <span class="toc-text">chgrp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#su"><span class="toc-number">6.14.</span> <span class="toc-text">su</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sudo"><span class="toc-number">6.15.</span> <span class="toc-text">sudo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">6.16.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-number">6.17.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq"><span class="toc-number">6.18.</span> <span class="toc-text">uniq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">6.19.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed"><span class="toc-number">6.20.</span> <span class="toc-text">sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk"><span class="toc-number">6.21.</span> <span class="toc-text">awk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat-less-more-head-tail"><span class="toc-number">6.22.</span> <span class="toc-text">cat&#x2F;less&#x2F;more&#x2F;head&#x2F;tail</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">7.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%80%E4%B8%AAmaster%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E4%B8%AAworker%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BD%9C%E4%B8%BA%E6%95%B4%E4%BD%93%E8%BF%9B%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">7.1.</span> <span class="toc-text">以一个master进程，多个worker子进程作为整体进程框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8D%95%E4%BE%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%8C%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8Ccrc32%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">利用单例类实现内存分配，读取配置文件和crc32校验算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9epoll-LT%E6%A8%A1%E5%BC%8F-%E5%90%8C%E6%97%B6%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AAI-O%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF"><span class="toc-number">7.3.</span> <span class="toc-text">借助epoll[LT模式]同时监听多个I&#x2F;O实现高并发通讯技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E6%9E%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E5%8C%85%E6%8B%AC%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AD%89"><span class="toc-number">7.4.</span> <span class="toc-text">构建线程池处理业务逻辑，使用状态机解析客户端请求，线程间同步技术包括互斥量，信号量等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%9B%9E%E6%94%B6"><span class="toc-number">7.5.</span> <span class="toc-text">构建连接池并且实现了对客户端关闭连接的延迟回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BA%86%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98%E5%92%8C%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%A6%82%E6%81%B6%E6%84%8F%E7%94%A8%E6%88%B7%E6%8C%81%E7%BB%AD%E8%BF%9E%E5%85%A5%EF%BC%8C%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%8C%85%E7%AD%89"><span class="toc-number">7.6.</span> <span class="toc-text">处理了惊群问题和已知的安全问题如恶意用户持续连入，积压过多数据包等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">7.7.</span> <span class="toc-text">一些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE"><span class="toc-number">7.8.</span> <span class="toc-text">困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#miniOS"><span class="toc-number">7.9.</span> <span class="toc-text">miniOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%8F%AF%E4%BB%A5%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%9A%84x86-32%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.10.</span> <span class="toc-text">汇编与C语言混合实现了可以人机交互的x86 32位操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%86%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%BF%9B%E7%A8%8B%E5%90%84%E4%B8%AA%E7%8A%B6%E6%80%81%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">7.11.</span> <span class="toc-text">自定义了进程模型并且实现了进程各个状态间的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%8C%E5%8C%85%E6%8B%AC%E9%93%BE%E8%A1%A8%E5%88%86%E9%85%8D%E6%B3%95%E5%92%8C%E5%9B%BA%E5%AE%9A%E5%B0%8F%E7%A2%8E%E7%89%87%E5%88%86%E9%85%8D%E6%B3%95"><span class="toc-number">7.12.</span> <span class="toc-text">独立实现了动态内存分配，包括链表分配法和固定小碎片分配法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.13.</span> <span class="toc-text">实现了进程互斥锁与事件机制，可以控制进程间的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%86%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%B8%80%E4%BA%9Bshell%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92"><span class="toc-number">7.14.</span> <span class="toc-text">实现了键盘驱动程序和一些shell任务与用户进行交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AF%B9%E7%A1%AC%E7%9B%98%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99"><span class="toc-number">7.15.</span> <span class="toc-text">设计并实现了文件系统，可以对硬盘进行读写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">9.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%89%E9%92%89%E4%B8%80%E9%9D%A2"><span class="toc-number">9.1.</span> <span class="toc-text">钉钉一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">美团一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B7%E7%81%AB%E4%B8%80%E9%9D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">雷火一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B7%E7%81%AB%E4%BA%8C%E9%9D%A2"><span class="toc-number">9.4.</span> <span class="toc-text">雷火二面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E4%BA%8C%E9%9D%A2"><span class="toc-number">9.5.</span> <span class="toc-text">腾讯音乐二面</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GO的双向tls通信"/></a><div class="content"><a class="title" href="/2023/01/07/202317-%E5%9F%BA%E4%BA%8EGO%E7%9A%84%E5%8F%8C%E5%90%91tls%E9%80%9A%E4%BF%A1/" title="基于GO的双向tls通信">基于GO的双向tls通信</a><time datetime="2023-01-06T16:00:00.000Z" title="发表于 2023-01-07 00:00:00">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入"/></a><div class="content"><a class="title" href="/2022/12/07/2022127-SQL%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a><time datetime="2022-12-06T16:00:00.000Z" title="发表于 2022-12-07 00:00:00">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞"><img src="/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传漏洞"/></a><div class="content"><a class="title" href="/2022/12/06/2022127-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" title="文件上传漏洞">文件上传漏洞</a><time datetime="2022-12-05T16:00:00.000Z" title="发表于 2022-12-06 00:00:00">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之包"/></a><div class="content"><a class="title" href="/2022/10/23/20221023-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/" title="Go语言基础之包">Go语言基础之包</a><time datetime="2022-10-22T16:00:00.000Z" title="发表于 2022-10-23 00:00:00">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数"><img src="/images/cover/p25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础之函数"/></a><div class="content"><a class="title" href="/2022/10/22/20221022-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" title="Go语言基础之函数">Go语言基础之函数</a><time datetime="2022-10-21T16:00:00.000Z" title="发表于 2022-10-22 00:00:00">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/p11.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 长烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">其实，我回头等了你好久好久，你都没来</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Yb0FJoeuYRJfbYGupEnFsg6E-gzGzoHsz',
      appKey: 'Pjo4dvB3TbjfY8clnS7fxalh',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://yunf194.github.io/css/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://yunf194.github.io/css/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>